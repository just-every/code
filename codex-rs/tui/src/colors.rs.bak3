// TODO: Fix after upstream merge - theme module removed
// use crate::theme::{current_theme, palette_mode, quantize_color_for_palette, PaletteMode};
use ratatui::style::Color;

// Temporary stub implementations until theme is restored
pub(crate) fn light_blue() -> Color {
    Color::Blue
}

pub(crate) fn success_green() -> Color {
    Color::Green
}

pub(crate) fn success() -> Color {
    Color::Green
}

pub(crate) fn warning() -> Color {
    Color::Yellow
}

pub(crate) fn error() -> Color {
    Color::Red
}

pub(crate) fn primary() -> Color {
    Color::Blue
}

#[allow(dead_code)]
pub(crate) fn secondary() -> Color {
    Color::Cyan
}

pub(crate) fn border() -> Color {
    Color::Gray
}

pub(crate) fn border_dim() -> Color {
    Color::DarkGray
}

#[allow(dead_code)]
pub(crate) fn border_focused() -> Color {
    Color::Blue
}

pub(crate) fn text() -> Color {
    Color::White
}

pub(crate) fn text_dim() -> Color {
    Color::Gray
}

pub(crate) fn text_bright() -> Color {
    Color::White
}

pub(crate) fn spinner() -> Color {
    Color::Blue
}

pub(crate) fn text_mid() -> Color {
    Color::Gray
}

pub(crate) fn info() -> Color {
    Color::Cyan
}

pub(crate) fn dim() -> Color {
    text_dim()
}

pub(crate) fn background() -> Color {
    Color::Black
}

#[allow(dead_code)]
pub(crate) fn selection() -> Color {
    Color::DarkGray
}

pub(crate) fn function() -> Color {
    Color::Yellow
}

pub(crate) fn keyword() -> Color {
    Color::Magenta
}

pub(crate) fn color_to_rgb(c: Color) -> (u8, u8, u8) {
    match c {
        Color::Rgb(r, g, b) => (r, g, b),
        Color::Black => (0, 0, 0),
        Color::White => (255, 255, 255),
        Color::Gray => (192, 192, 192),
        Color::DarkGray => (128, 128, 128),
        Color::Red => (205, 49, 49),
        Color::Green => (13, 188, 121),
        Color::Yellow => (229, 229, 16),
        Color::Blue => (36, 114, 200),
        Color::Magenta => (188, 63, 188),
        Color::Cyan => (17, 168, 205),
        Color::LightRed => (255, 102, 102),
        Color::LightGreen => (102, 255, 178),
        Color::LightYellow => (255, 255, 102),
        Color::LightBlue => (102, 153, 255),
        Color::LightMagenta => (255, 102, 255),
        Color::LightCyan => (102, 255, 255),
        Color::Indexed(i) => ansi256_to_rgb(i),
        Color::Reset => (255, 255, 255),
    }
}

fn ansi256_to_rgb(i: u8) -> (u8, u8, u8) {
    const ANSI16: [(u8, u8, u8); 16] = [
        (0, 0, 0),
        (205, 0, 0),
        (0, 205, 0),
        (205, 205, 0),
        (0, 0, 205),
        (205, 0, 205),
        (0, 205, 205),
        (229, 229, 229),
        (127, 127, 127),
        (255, 102, 102),
        (102, 255, 178),
        (255, 255, 102),
        (102, 153, 255),
        (255, 102, 255),
        (102, 255, 255),
        (255, 255, 255),
    ];

    if i < 16 {
        return ANSI16[i as usize];
    }
    if (16..=231).contains(&i) {
        let idx = i - 16;
        let r = idx / 36;
        let g = (idx % 36) / 6;
        let b = idx % 6;
        let step = [0, 95, 135, 175, 215, 255];
        return (step[r as usize], step[g as usize], step[b as usize]);
    }
    let level = i.saturating_sub(232);
    let v = 8 + 10 * level;
    (v, v, v)
}

#[allow(dead_code)]
pub(crate) fn mix_toward(_from: Color, _to: Color, _t: f32) -> Color {
    Color::Gray
}

pub(crate) fn overlay_scrim() -> Color {
    Color::DarkGray
}

pub(crate) fn assistant_bg() -> Color {
    Color::Black
}

pub(crate) fn code_block_bg() -> Color {
    assistant_bg()
}

pub(crate) fn assistant_hr() -> Color {
    Color::DarkGray
}
