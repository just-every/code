use once_cell::sync::Lazy;
use std::collections::BTreeSet;
use std::collections::HashMap;
use std::collections::hash_map::Entry;
use std::collections::HashSet;
use std::collections::VecDeque;
use std::io;
use std::path::PathBuf;
use std::rc::{Rc, Weak};
use std::sync::Arc;
use std::sync::mpsc::Sender;
use std::sync::Mutex;
use std::sync::atomic::AtomicBool;
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;
use std::sync::OnceLock;
use std::time::{Duration, Instant, SystemTime};
use std::process::Command;

use ratatui::style::Modifier;
use ratatui::style::Style;
use crate::header_wave::HeaderWaveEffect;
use crate::auto_drive_strings;
use crate::auto_drive_style::AutoDriveVariant;
use crate::spinner;
use crate::thread_spawner;

use code_common::elapsed::format_duration;
use code_common::model_presets::ModelPreset;
use code_common::model_presets::builtin_model_presets;
use code_core::ConversationManager;
use code_core::agent_defaults::{agent_model_spec, enabled_agent_model_specs};
use code_core::config::Config;
use code_core::git_info::CommitLogEntry;
use code_core::config_types::AgentConfig;
use code_core::config_types::AutoDriveContinueMode;
use code_core::config_types::Notifications;
use code_core::config_types::ReasoningEffort;
use code_core::config_types::TextVerbosity;
use code_core::plan_tool::{PlanItemArg, StepStatus, UpdatePlanArgs};
use code_core::model_family::derive_default_model_family;
use code_core::model_family::find_family_for_model;
use code_core::account_usage::{
    self,
    RateLimitWarningScope,
    StoredRateLimitSnapshot,
    StoredUsageSummary,
    TokenTotals,
};
use code_core::auth_accounts::{self, StoredAccount};
use code_login::AuthManager;
use code_login::AuthMode;
use code_protocol::mcp_protocol::AuthMode as McpAuthMode;
use code_protocol::protocol::SessionSource;
use code_protocol::num_format::format_with_separators;


mod diff_handlers;
mod agent_install;
mod diff_ui;
mod exec_tools;
mod gh_actions;
mod history_render;
mod help_handlers;
mod settings_handlers;
mod settings_overlay;
mod limits_overlay;
mod interrupts;
mod layout_scroll;
mod message;
mod perf;
mod rate_limit_refresh;
mod streaming;
mod terminal_handlers;
mod terminal;
mod tools;
mod browser_sessions;
mod agent_runs;
mod web_search_sessions;
mod auto_drive_cards;
pub(crate) mod tool_cards;
mod running_tools;
#[cfg(any(test, feature = "test-helpers"))]
pub mod smoke_helpers;
use self::agent_install::{
    start_agent_install_session,
    start_direct_terminal_session,
    start_prompt_terminal_session,
    start_upgrade_terminal_session,
    wrap_command,
};
use code_auto_drive_core::{
    start_auto_coordinator,
    AutoCoordinatorCommand,
    AutoCoordinatorEvent,
    AutoCoordinatorEventSender,
    AutoCoordinatorHandle,
    AutoCoordinatorStatus,
    AutoDriveHistory,
    AutoDriveController,
    AutoRunPhase,
    AutoControllerEffect,
    AutoTurnAgentsAction,
    AutoTurnAgentsTiming,
    AutoTurnCliAction,
    AutoTurnReviewState,
    ReviewCommitDescriptor,
    AutoResolveState,
    AutoResolvePhase,
    AUTO_RESTART_MAX_ATTEMPTS,
    AUTO_RESOLVE_REVIEW_FOLLOWUP,
    CoordinatorContext,
    CoordinatorRouterResponse,
    route_user_message,
    TurnConfig,
    TurnDescriptor,
};
use self::limits_overlay::{LimitsOverlayContent, LimitsTab};
use crate::chrome_launch::ChromeLaunchOption;
use self::rate_limit_refresh::start_rate_limit_refresh;
use self::history_render::{
    CachedLayout, HistoryRenderState, RenderRequest, RenderRequestKind, RenderSettings, VisibleCell,
};
use crate::auto_review::{self, AutoReviewOutcome, BaseCommitSnapshot, PreparedCommitReview};
use code_core::parse_command::ParsedCommand;
use code_core::TextFormat;
use code_core::protocol::AgentMessageDeltaEvent;
use code_core::protocol::ApprovedCommandMatchKind;
use code_core::protocol::AskForApproval;
use code_core::protocol::SandboxPolicy;
use code_core::protocol::AgentMessageEvent;
use code_core::protocol::AgentReasoningDeltaEvent;
use code_core::protocol::AgentReasoningEvent;
use code_core::protocol::AgentReasoningRawContentDeltaEvent;
use code_core::protocol::AgentReasoningRawContentEvent;
use code_core::protocol::AgentReasoningSectionBreakEvent;
use code_core::protocol::AgentStatusUpdateEvent;
use code_core::protocol::ApplyPatchApprovalRequestEvent;
use code_core::protocol::BackgroundEventEvent;
use code_core::protocol::BrowserScreenshotUpdateEvent;
use code_core::protocol::CustomToolCallBeginEvent;
use code_core::protocol::CustomToolCallEndEvent;
use code_core::protocol::ErrorEvent;
use code_core::protocol::Event;
use code_core::protocol::EventMsg;
use code_core::protocol::ExecApprovalRequestEvent;
use code_core::protocol::ExecCommandBeginEvent;
use code_core::protocol::ExecCommandEndEvent;
use code_core::protocol::ExecOutputStream;
use code_core::protocol::InputItem;
use code_core::protocol::SessionConfiguredEvent;
// MCP tool call handlers moved into chatwidget::tools
use code_core::protocol::Op;
use code_core::protocol::ReviewOutputEvent;
use code_core::protocol::{ReviewContextMetadata, ReviewRequest};
use code_core::{cleanup_review_worktree, ReviewWorktreeCleanupToken};
use code_core::protocol::PatchApplyBeginEvent;
use code_core::protocol::PatchApplyEndEvent;
use code_core::protocol::TaskCompleteEvent;
use code_core::protocol::TokenUsage;
use code_core::protocol::TurnDiffEvent;
use crate::bottom_pane::{
    AutoActiveViewModel,
    AutoCoordinatorButton,
    AutoCoordinatorViewModel,
    CountdownState,
    GithubSettingsView,
    McpSettingsView,
    ModelSelectionView,
    NotificationsMode,
    NotificationsSettingsView,
    SettingsSection,
    ThemeSelectionView,
    agent_editor_view::AgentEditorView,
    AutoDriveSettingsView,
    UpdateSettingsView,
    ValidationSettingsView,
};
use crate::bottom_pane::agents_settings_view::SubagentEditorView;
use crate::bottom_pane::mcp_settings_view::{McpServerRow, McpServerRows};
use crate::exec_command::strip_bash_lc_and_escape;
#[cfg(feature = "code-fork")]
use crate::tui_event_extensions::handle_browser_screenshot;
use crate::chatwidget::message::UserMessage;
use tokio::spawn;

pub(crate) const DOUBLE_ESC_HINT: &str = "undo timeline";
const AUTO_ESC_EXIT_HINT: &str = "Press Esc again to exit Auto Drive";
const AUTO_BOOTSTRAP_GOAL_PLACEHOLDER: &str = "Deriving goal from recent conversation";

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub(crate) enum EscIntent {
    DismissModal,
    CloseSettings,
    CloseFilePopup,
    AutoPauseForEdit,
    AutoStopDuringApproval,
    AutoStopActive,
    AutoGoalEnableEdit,
    AutoGoalExitPreserveDraft,
    AutoDismissSummary,
    DiffConfirm,
    AgentsTerminal,
    CancelAgents,
    CancelTask,
    ClearComposer,
    ShowUndoHint,
    OpenUndoTimeline,
    None,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum AutoGoalEscState {
    Inactive,
    NeedsEnableEditing,
    ArmedForExit,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub(crate) struct EscRoute {
    pub intent: EscIntent,
    pub consume: bool,
    pub allows_double_esc: bool,
}

impl EscRoute {
    const fn new(intent: EscIntent, consume: bool, allows_double_esc: bool) -> Self {
        Self {
            intent,
            consume,
            allows_double_esc,
        }
    }
}

impl ChatWidget<'_> {
    fn browser_overlay_progress_line(
        &self,
        width: u16,
        current: Duration,
        total: Duration,
    ) -> Line<'static> {
        let width = width.max(20) as usize;
        let prefix = "▶ ";
        let suffix = format!(
            " {} / {}",
            self.format_overlay_mm_ss(current),
            self.format_overlay_mm_ss(total)
        );
        let slider_width = width
            .saturating_sub(prefix.len())
            .saturating_sub(suffix.chars().count())
            .max(5);

        let progress_ratio = if total.as_millis() == 0 {
            0.0
        } else {
            (current.as_secs_f64() / total.as_secs_f64()).clamp(0.0, 1.0)
        };
        let progress_cells = (progress_ratio * slider_width as f64).round() as usize;

        let mut slider = String::with_capacity(slider_width);
        let pointer_idx = if slider_width <= 1 {
            0
        } else {
            progress_cells.clamp(0, slider_width.saturating_sub(1))
        };
        for i in 0..slider_width {
            if i == pointer_idx {
                slider.push('◉');
            } else {
                slider.push('─');
            }
        }

        let mut spans: Vec<Span> = Vec::new();
        spans.push(Span::styled(prefix.to_string(), Style::default().fg(crate::colors::text())));
        spans.push(Span::styled(
            slider,
            Style::default()
                .fg(crate::colors::primary())
                .add_modifier(Modifier::BOLD),
        ));
        spans.push(Span::styled(
            suffix,
            Style::default().fg(crate::colors::text()),
        ));

        Line::from(spans)
    }

    fn format_overlay_mm_ss(&self, duration: Duration) -> String {
        let total_secs = duration.as_secs();
        let minutes = total_secs / 60;
        let seconds = total_secs % 60;
        format!("{:02}:{:02}", minutes, seconds)
    }

    fn normalize_action_time_label(&self, label: &str) -> String {
        if let Some((minutes, seconds)) = label.split_once('m') {
            let minutes = minutes.trim().parse::<u64>().unwrap_or(0);
            let seconds = seconds
                .trim()
                .trim_start_matches(char::is_whitespace)
                .trim_end_matches('s')
                .parse::<u64>()
                .unwrap_or(0);
            return format!("{:02}:{:02}", minutes, seconds);
        }
        if let Some(stripped) = label.strip_suffix('s') {
            if let Ok(seconds) = stripped.trim().parse::<u64>() {
                return format!("00:{:02}", seconds.min(59));
            }
        }
        label.to_string()
    }
}
use code_git_tooling::{
    create_ghost_commit,
    restore_ghost_commit,
    CreateGhostCommitOptions,
    GhostCommit,
    GitToolingError,
};
use crossterm::event::KeyEvent;
use crossterm::event::KeyEventKind;
use image::imageops::FilterType;
use ratatui::buffer::Buffer;
use ratatui::layout::Constraint;
use ratatui::layout::Layout;
use ratatui::layout::Rect;
use ratatui::text::Line;
use ratatui::widgets::Widget;
use ratatui::widgets::WidgetRef;
use ratatui_image::picker::Picker;
use std::cell::{Cell, RefCell};
use std::sync::mpsc;
use tokio::sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender};

fn history_cell_logging_enabled() -> bool {
    static ENABLED: OnceLock<bool> = OnceLock::new();
    if let Ok(value) = std::env::var("CODEX_TRACE_HISTORY") {
        let trimmed = value.trim();
        if !matches!(trimmed, "" | "0") {
            return true;
        }
    }
    *ENABLED.get_or_init(|| {
        if let Ok(value) = std::env::var("CODE_BUFFER_DIFF_TRACE_CELLS") {
            return !matches!(value.trim(), "" | "0");
        }
        if let Ok(value) = std::env::var("CODE_BUFFER_DIFF_METRICS") {
            return !matches!(value.trim(), "" | "0");
        }
        false
    })
}
use serde_json::{self, Value as JsonValue};
use tracing::{info, warn};
// use image::GenericImageView;

const TOKENS_PER_MILLION: f64 = 1_000_000.0;
const INPUT_COST_PER_MILLION_USD: f64 = 1.25;
const CACHED_INPUT_COST_PER_MILLION_USD: f64 = 0.125;
const OUTPUT_COST_PER_MILLION_USD: f64 = 10.0;
const STATUS_LABEL_INDENT: &str = "   ";
const STATUS_LABEL_TARGET_WIDTH: usize = 7;
const STATUS_LABEL_GAP: usize = 2;
const STATUS_CONTENT_PREFIX: &str = "    ";
const STATUS_TOKENS_PREFIX: &str = "             ";
const RESUME_PLACEHOLDER_MESSAGE: &str = "Resuming previous session...";
const RESUME_NO_HISTORY_NOTICE: &str =
    "No saved messages for this session. Start typing to continue.";
const ENABLE_WARP_STRIPES: bool = false;

fn auto_continue_from_config(mode: AutoDriveContinueMode) -> AutoContinueMode {
    match mode {
        AutoDriveContinueMode::Immediate => AutoContinueMode::Immediate,
        AutoDriveContinueMode::TenSeconds => AutoContinueMode::TenSeconds,
        AutoDriveContinueMode::SixtySeconds => AutoContinueMode::SixtySeconds,
        AutoDriveContinueMode::Manual => AutoContinueMode::Manual,
    }
}

fn auto_continue_to_config(mode: AutoContinueMode) -> AutoDriveContinueMode {
    match mode {
        AutoContinueMode::Immediate => AutoDriveContinueMode::Immediate,
        AutoContinueMode::TenSeconds => AutoDriveContinueMode::TenSeconds,
        AutoContinueMode::SixtySeconds => AutoDriveContinueMode::SixtySeconds,
        AutoContinueMode::Manual => AutoDriveContinueMode::Manual,
    }
}

fn status_field_prefix(label: &str) -> String {
    let padding = STATUS_LABEL_GAP
        .saturating_add(STATUS_LABEL_TARGET_WIDTH.saturating_sub(label.len()));
    format!(
        "{indent}{label}:{spaces}",
        indent = STATUS_LABEL_INDENT,
        label = label,
        spaces = " ".repeat(padding)
    )
}

fn status_content_prefix() -> String {
    STATUS_CONTENT_PREFIX.to_string()
}

fn status_tokens_prefix() -> &'static str {
    STATUS_TOKENS_PREFIX
}

fn describe_cloud_error(err: &CloudTaskError) -> String {
    match err {
        CloudTaskError::Msg(message) => message.clone(),
        other => other.to_string(),
    }
}

use crate::account_label::{account_display_label, account_mode_priority};
use crate::app_event::{
    AppEvent,
    AutoContinueMode,
    BackgroundPlacement,
    TerminalAfter,
    TerminalCommandGate,
    TerminalLaunch,
    TerminalRunController,
};
use crate::app_event_sender::AppEventSender;
use crate::bottom_pane::CustomPromptView;
use crate::bottom_pane::list_selection_view::{ListSelectionView, SelectionItem};
use crate::bottom_pane::CloudTasksView;
use crate::bottom_pane::validation_settings_view;
use crate::bottom_pane::validation_settings_view::{GroupStatus, ToolRow};
use crate::bottom_pane::BottomPane;
use crate::bottom_pane::BottomPaneParams;
use crate::bottom_pane::{UndoTimelineEntry, UndoTimelineEntryKind, UndoTimelineView};
use crate::bottom_pane::CancellationEvent;
use crate::bottom_pane::InputResult;
use crate::bottom_pane::LoginAccountsState;
use crate::bottom_pane::LoginAccountsView;
use crate::bottom_pane::LoginAddAccountState;
use crate::bottom_pane::LoginAddAccountView;
use crate::bottom_pane::UpdateSharedState;
use crate::height_manager::HeightEvent;
use crate::height_manager::HeightManager;
use crate::history_cell;
use crate::history_cell::clean_wait_command;
#[cfg(target_os = "macos")]
use crate::agent_install_helpers::macos_brew_formula_for_command;
use crate::history_cell::ExecCell;
use crate::history_cell::HistoryCell;
use crate::history_cell::HistoryCellType;
use crate::history_cell::PatchEventType;
use crate::history_cell::PlainHistoryCell;
use crate::history_cell::PlanUpdateCell;
use crate::history_cell::DiffCell;
use crate::history_cell::{AutoDriveActionKind, AutoDriveStatus};
use crate::history::state::PatchEventType as HistoryPatchEventType;
use crate::history::state::{
    AssistantMessageState,
    AssistantStreamDelta,
    AssistantStreamState,
    DiffLineKind,
    DiffRecord,
    ExecWaitNote,
    HistoryDomainEvent,
    HistoryDomainRecord,
    HistoryId,
    HistoryRecord,
    HistoryMutation,
    HistorySnapshot,
    HistoryState,
    InlineSpan,
    MessageLine,
    MessageLineKind,
    PlainMessageKind,
    PlainMessageRole,
    PlainMessageState,
    MessageMetadata,
    OrderKeySnapshot,
    PatchFailureMetadata,
    PatchRecord,
    RateLimitLegendEntry,
    RateLimitsRecord,
    TextTone,
    TextEmphasis,
};
use crate::cloud_tasks_service::CloudEnvironment;
use crate::sanitize::{sanitize_for_tui, Mode as SanitizeMode, Options as SanitizeOptions};
use crate::slash_command::{ProcessedCommand, SlashCommand};
use crate::live_wrap::RowBuilder;
use crate::streaming::StreamKind;
use crate::streaming::controller::AppEventHistorySink;
use crate::util::buffer::fill_rect;
use crate::user_approval_widget::ApprovalRequest;
pub(crate) use self::terminal::{
    PendingCommand,
    PendingCommandAction,
    PendingManualTerminal,
    TerminalOverlay,
    TerminalState,
};
use code_browser::BrowserManager;
use code_core::config::find_code_home;
use code_core::config::resolve_code_path_for_read;
use code_core::config::set_github_actionlint_on_patch;
use code_core::config::set_github_check_on_push;
use code_core::config::set_validation_group_enabled;
use code_core::config::set_validation_tool_enabled;
use code_file_search::FileMatch;
use code_cloud_tasks_client::{ApplyOutcome, CloudTaskError, CreatedTask, TaskSummary};
use code_protocol::models::ContentItem;
use code_protocol::models::ResponseItem;
use code_core::config_types::{validation_tool_category, ValidationCategory};
use code_core::protocol::RateLimitSnapshotEvent;
use code_core::protocol::ValidationGroup;
use crate::rate_limits_view::{build_limits_view, RateLimitResetInfo, DEFAULT_GRID_CONFIG};
use crate::session_log;
use code_core::review_format::format_review_findings_block;
use chrono::{DateTime, Datelike, Duration as ChronoDuration, Local, TimeZone, Timelike, Utc};
use crossterm::event::KeyCode;
use crossterm::event::KeyModifiers;
use ratatui::style::Stylize;
use ratatui::symbols::scrollbar as scrollbar_symbols;
use ratatui::text::Span;
use ratatui::text::Text as RtText;
use textwrap::wrap;
use unicode_segmentation::UnicodeSegmentation;
use unicode_width::UnicodeWidthStr;
use ratatui::widgets::Block;
use ratatui::widgets::Borders;
use ratatui::widgets::Clear;
use ratatui::widgets::Paragraph;
use ratatui::widgets::Scrollbar;
use ratatui::widgets::ScrollbarOrientation;
use ratatui::widgets::ScrollbarState;
use ratatui::widgets::StatefulWidget;
use serde::Deserialize;
use serde::Serialize;

#[derive(Debug, Serialize, Deserialize)]
struct CachedConnection {
    port: Option<u16>,
    ws: Option<String>,
}

async fn read_cached_connection() -> Option<(Option<u16>, Option<String>)> {
    let code_home = find_code_home().ok()?;
    let path = resolve_code_path_for_read(&code_home, std::path::Path::new("cache.json"));
    let bytes = tokio::fs::read(path).await.ok()?;
    let parsed: CachedConnection = serde_json::from_slice(&bytes).ok()?;
    Some((parsed.port, parsed.ws))
}

async fn write_cached_connection(port: Option<u16>, ws: Option<String>) -> std::io::Result<()> {
    if port.is_none() && ws.is_none() {
        return Ok(());
    }
    if let Ok(code_home) = find_code_home() {
        let path = code_home.join("cache.json");
        let obj = CachedConnection { port, ws };
        let data = serde_json::to_vec_pretty(&obj).unwrap_or_else(|_| b"{}".to_vec());
        if let Some(dir) = path.parent() {
            let _ = tokio::fs::create_dir_all(dir).await;
        }
        tokio::fs::write(path, data).await?;
    }
    Ok(())
}

struct RunningCommand {
    command: Vec<String>,
    parsed: Vec<ParsedCommand>,
    // Index of the in-history Exec cell for this call, if inserted
    history_index: Option<usize>,
    history_id: Option<HistoryId>,
    // Aggregated exploration entry (history index, entry index) when grouped
    explore_entry: Option<(usize, usize)>,
    stdout: String,
    stderr: String,
    wait_total: Option<Duration>,
    wait_active: bool,
    wait_notes: Vec<(String, bool)>,
}

const RATE_LIMIT_WARNING_THRESHOLDS: [f64; 3] = [50.0, 75.0, 90.0];
const RATE_LIMIT_REFRESH_INTERVAL: chrono::Duration = chrono::Duration::minutes(10);

const MAX_TRACKED_GHOST_COMMITS: usize = 20;
const GHOST_SNAPSHOT_NOTICE_THRESHOLD: Duration = Duration::from_secs(1);
const GHOST_SNAPSHOT_TIMEOUT: Duration = Duration::from_secs(30);

#[derive(Clone)]
struct RateLimitWarning {
    scope: RateLimitWarningScope,
    threshold: f64,
    message: String,
}

#[derive(Default)]
struct RateLimitWarningState {
    weekly_index: usize,
    hourly_index: usize,
}

impl RateLimitWarningState {
    fn take_warnings(
        &mut self,
        secondary_used_percent: f64,
        primary_used_percent: f64,
    ) -> Vec<RateLimitWarning> {
        let mut warnings = Vec::new();

        let mut next_weekly_index = self.weekly_index;
        while next_weekly_index < RATE_LIMIT_WARNING_THRESHOLDS.len()
            && secondary_used_percent >= RATE_LIMIT_WARNING_THRESHOLDS[next_weekly_index]
        {
            next_weekly_index += 1;
        }
        if next_weekly_index > self.weekly_index {
            let threshold = RATE_LIMIT_WARNING_THRESHOLDS[next_weekly_index - 1];
            warnings.push(RateLimitWarning {
                scope: RateLimitWarningScope::Secondary,
                threshold,
                message: format!(
                    "Secondary usage exceeded {threshold:.0}% of the limit. Run /limits for detailed usage."
                ),
            });
            self.weekly_index = next_weekly_index;
        }

        let mut next_hourly_index = self.hourly_index;
        while next_hourly_index < RATE_LIMIT_WARNING_THRESHOLDS.len()
            && primary_used_percent >= RATE_LIMIT_WARNING_THRESHOLDS[next_hourly_index]
        {
            next_hourly_index += 1;
        }
        if next_hourly_index > self.hourly_index {
            let threshold = RATE_LIMIT_WARNING_THRESHOLDS[next_hourly_index - 1];
            warnings.push(RateLimitWarning {
                scope: RateLimitWarningScope::Primary,
                threshold,
                message: format!(
                    "Hourly usage exceeded {threshold:.0}% of the limit. Run /limits for detailed usage."
                ),
            });
            self.hourly_index = next_hourly_index;
        }

        warnings
    }

    fn reset(&mut self) {
        self.weekly_index = 0;
        self.hourly_index = 0;
    }
}

#[derive(Clone)]
struct GhostSnapshotsDisabledReason {
    message: String,
    hint: Option<String>,
}

#[derive(Clone, Copy)]
struct ConversationSnapshot {
    user_turns: usize,
    assistant_turns: usize,
    history_len: usize,
    order_len: usize,
    order_dbg_len: usize,
}

impl ConversationSnapshot {
    fn new(user_turns: usize, assistant_turns: usize) -> Self {
        Self {
            user_turns,
            assistant_turns,
            history_len: 0,
            order_len: 0,
            order_dbg_len: 0,
        }
    }
}

#[derive(Clone)]
pub(crate) struct GhostState {
    snapshots: Vec<GhostSnapshot>,
    disabled: bool,
    disabled_reason: Option<GhostSnapshotsDisabledReason>,
    queue: VecDeque<(u64, GhostSnapshotRequest)>,
    active: Option<(u64, GhostSnapshotRequest)>,
    next_id: u64,
    pending_dispatches: VecDeque<PendingSnapshotDispatch>,
    queued_user_messages: VecDeque<UserMessage>,
}

#[cfg(test)]
pub(super) type CaptureAutoTurnCommitStub = Box<
    dyn Fn(&'static str, Option<String>) -> Result<GhostCommit, GitToolingError> + Send + Sync,
>;

#[cfg(test)]
pub(super) static CAPTURE_AUTO_TURN_COMMIT_STUB: Lazy<Mutex<Option<CaptureAutoTurnCommitStub>>> =
    Lazy::new(|| Mutex::new(None));

#[cfg(test)]
pub(super) type GitDiffNameOnlyBetweenStub =
    Box<dyn Fn(String, String) -> Result<Vec<String>, String> + Send + Sync>;

#[cfg(test)]
pub(super) static GIT_DIFF_NAME_ONLY_BETWEEN_STUB: Lazy<Mutex<Option<GitDiffNameOnlyBetweenStub>>> =
    Lazy::new(|| Mutex::new(None));

#[cfg(test)]
pub(super) static AUTO_STUB_LOCK: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));

#[derive(Deserialize)]
struct AutoResolveDecision {
    status: String,
    #[serde(default)]
    rationale: Option<String>,
}

pub(crate) struct ChatWidget<'a> {
    app_event_tx: AppEventSender,
    code_op_tx: UnboundedSender<Op>,
    bottom_pane: BottomPane<'a>,
    auth_manager: Arc<AuthManager>,
    login_view_state: Option<Weak<RefCell<LoginAccountsState>>>,
    login_add_view_state: Option<Weak<RefCell<LoginAddAccountState>>>,
    active_exec_cell: Option<ExecCell>,
    history_cells: Vec<Box<dyn HistoryCell>>, // Store all history in memory
    history_cell_ids: Vec<Option<HistoryId>>,
    history_render: HistoryRenderState,
    render_theme_epoch: u64,
    history_state: HistoryState,
    history_snapshot_dirty: bool,
    history_snapshot_last_flush: Option<Instant>,
    config: Config,
    history_debug_events: Option<RefCell<Vec<String>>>,
    latest_upgrade_version: Option<String>,
    initial_user_message: Option<UserMessage>,
    total_token_usage: TokenUsage,
    last_token_usage: TokenUsage,
    rate_limit_snapshot: Option<RateLimitSnapshotEvent>,
    rate_limit_warnings: RateLimitWarningState,
    rate_limit_fetch_inflight: bool,
    rate_limit_last_fetch_at: Option<DateTime<Utc>>,
    rate_limit_primary_next_reset_at: Option<DateTime<Utc>>,
    rate_limit_secondary_next_reset_at: Option<DateTime<Utc>>,
    content_buffer: String,
    // Buffer for streaming assistant answer text; we do not surface partial
    // We wait for the final AgentMessage event and then emit the full text
    // at once into scrollback so the history contains a single message.
    // Cache of the last finalized assistant message to suppress immediate duplicates
    last_assistant_message: Option<String>,
    // Track the ID of the current streaming message to prevent duplicates
    // Track the ID of the current streaming reasoning to prevent duplicates
    exec: ExecState,
    tools_state: ToolState,
    live_builder: RowBuilder,
    header_wave: HeaderWaveEffect,
    browser_overlay_visible: bool,
    browser_overlay_state: BrowserOverlayState,
    // Store pending image paths keyed by their placeholder text
    pending_images: HashMap<String, PathBuf>,
    // (removed) pending non-image files are no longer tracked; non-image paths remain as plain text
    welcome_shown: bool,
    // Path to the latest browser screenshot and URL for display
    latest_browser_screenshot: Arc<Mutex<Option<(PathBuf, String)>>>,
    browser_autofix_requested: Arc<AtomicBool>,
    // Cached image protocol to avoid recreating every frame (path, area, protocol)
    cached_image_protocol:
        std::cell::RefCell<Option<(PathBuf, Rect, ratatui_image::protocol::Protocol)>>,
    // Cached picker to avoid recreating every frame
    cached_picker: std::cell::RefCell<Option<Picker>>,

    // Cached cell size (width,height) in pixels
    cached_cell_size: std::cell::OnceCell<(u16, u16)>,
    git_branch_cache: RefCell<GitBranchCache>,

    // Terminal information from startup
    terminal_info: crate::tui::TerminalInfo,
    // Agent tracking for multi-agent tasks
    active_agents: Vec<AgentInfo>,
    agents_ready_to_start: bool,
    last_agent_prompt: Option<String>,
    agent_context: Option<String>,
    agent_task: Option<String>,
    recent_agent_hint: Option<String>,
    suppress_next_agent_hint: bool,
    active_review_hint: Option<String>,
    active_review_prompt: Option<String>,
    auto_resolve_state: Option<AutoResolveState>,
    // New: coordinator-provided hints for the next Auto turn
    pending_turn_descriptor: Option<TurnDescriptor>,
    pending_auto_turn_config: Option<TurnConfig>,
    pending_review_commit: Option<ReviewCommitDescriptor>,
    auto_review_cleanup: Option<ReviewWorktreeCleanupToken>,
    auto_review_pending: bool,
    overall_task_status: String,
    active_plan_title: Option<String>,
    /// Runtime timing per-agent (by id) to improve visibility in the HUD
    agent_runtime: HashMap<String, AgentRuntime>,
    // Sparkline data for showing agent activity (using RefCell for interior mutability)
    // Each tuple is (value, is_completed) where is_completed indicates if any agent was complete at that time
    sparkline_data: std::cell::RefCell<Vec<(u64, bool)>>,
    last_sparkline_update: std::cell::RefCell<std::time::Instant>,
    // Stream controller for managing streaming content
    stream: crate::streaming::controller::StreamController,
    // Stream lifecycle state (kind, closures, sequencing, cancel)
    stream_state: StreamState,
    // Interrupt manager for handling cancellations
    interrupts: interrupts::InterruptManager,

    // Guard for out-of-order exec events: track call_ids that already ended
    ended_call_ids: HashSet<ExecCallId>,
    /// Exec call_ids that were explicitly cancelled by user interrupt. Used to
    /// drop any late ExecEnd events so we don't render duplicate cells.
    canceled_exec_call_ids: HashSet<ExecCallId>,

    // Accumulated diff/session state
    diffs: DiffsState,

    // Help overlay state
    help: HelpState,

    // Settings overlay state
    settings: SettingsState,

    // Limits overlay state
    limits: LimitsState,

    // Terminal overlay state
    terminal: TerminalState,
    pending_manual_terminal: HashMap<u64, PendingManualTerminal>,

    // Persisted selection for Agents overview
    agents_overview_selected_index: usize,

    // State for the Agents Terminal view
    agents_terminal: AgentsTerminalState,

    pending_upgrade_notice: Option<(u64, String)>,

    // Cached visible rows for the diff overlay body to clamp scrolling (kept within diffs)

    // Centralized height manager (always enabled)
    height_manager: RefCell<HeightManager>,

    // Aggregated layout and scroll state
    layout: LayoutState,

    // True when connected to external Chrome via CDP; affects HUD titles
    browser_is_external: bool,

    // Most recent theme snapshot used to retint pre-rendered lines
    last_theme: crate::theme::Theme,

    // Performance tracing (opt-in via /perf)
    perf_state: PerfState,
    // Current session id (from SessionConfigured)
    session_id: Option<uuid::Uuid>,

    // Pending diagnostics integration
    next_cli_text_format: Option<TextFormat>,

    // Pending jump-back state (reversible until submit)

    // Track active task ids so we don't drop the working status while any
    // agent/sub‑agent is still running (long‑running sessions can interleave).
    active_task_ids: HashSet<String>,

    // --- Queued user message support ---
    // Messages typed while a task is running are kept here and rendered
    // at the bottom as "(queued)" until the next turn begins. At that
    // point we submit one queued message and move its cell into the
    // normal history within the new turn window.
    queued_user_messages: std::collections::VecDeque<UserMessage>,
    pending_dispatched_user_messages: std::collections::VecDeque<String>,
    // Number of user prompts we pre-pended to history just before starting
    // a new turn; used to anchor the next turn window so assistant output
    // appears after them.
    pending_user_prompts_for_next_turn: usize,
    ghost_snapshots: Vec<GhostSnapshot>,
    ghost_snapshots_disabled: bool,
    ghost_snapshots_disabled_reason: Option<GhostSnapshotsDisabledReason>,
    ghost_snapshot_queue: VecDeque<(u64, GhostSnapshotRequest)>,
    active_ghost_snapshot: Option<(u64, GhostSnapshotRequest)>,
    next_ghost_snapshot_id: u64,
    pending_snapshot_dispatches: VecDeque<PendingSnapshotDispatch>,

    auto_drive_card_sequence: u64,
    auto_drive_variant: AutoDriveVariant,
    auto_state: AutoDriveController,
    auto_goal_escape_state: AutoGoalEscState,
    auto_handle: Option<AutoCoordinatorHandle>,
    auto_history: AutoDriveHistory,
    auto_turn_review_state: Option<AutoTurnReviewState>,
    auto_pending_goal_request: bool,
    auto_goal_bootstrap_done: bool,
    cloud_tasks_selected_env: Option<CloudEnvironment>,
    cloud_tasks_environments: Vec<CloudEnvironment>,
    cloud_tasks_last_tasks: Vec<TaskSummary>,
    cloud_tasks_best_of_n: usize,
    cloud_tasks_creation_inflight: bool,
    cloud_task_apply_tickets: HashMap<(String, bool), BackgroundOrderTicket>,
    cloud_task_create_ticket: Option<BackgroundOrderTicket>,

    // Event sequencing to preserve original order across streaming/tool events
    // and stream-related flags moved into stream_state

    // Strict global ordering for history: every cell has a required key
    // (req, out, seq). No unordered inserts and no turn windows.
    cell_order_seq: Vec<OrderKey>,
    // Debug: per-cell order info string rendered in the UI to diagnose ordering.
    cell_order_dbg: Vec<Option<String>>,
    // Routing for reasoning stream ids -> existing CollapsibleReasoningCell index
    reasoning_index: HashMap<String, usize>,
    // Stable per-(kind, stream_id) ordering, derived from OrderMeta.
    stream_order_seq: HashMap<(StreamKind, String), OrderKey>,
    // Resume-aware bias applied to provider request ordinals for restored sessions.
    order_request_bias: u64,
    resume_expected_next_request: Option<u64>,
    resume_provider_baseline: Option<u64>,
    // Track last provider request_ordinal seen so internal messages can be
    // assigned request_index = last_seen + 1 (with out = -1).
    last_seen_request_index: u64,
    // Synthetic request index used for internal-only messages; always >= last_seen_request_index
    current_request_index: u64,
    // Monotonic seq for internal messages to keep intra-request order stable
    internal_seq: u64,
    // Show order overlay when true (from --order)
    show_order_overlay: bool,

    // One-time hint to teach input history navigation
    scroll_history_hint_shown: bool,

    // Track and manage the access-mode background status cell so mode changes
    // replace the existing status instead of stacking multiple entries.
    access_status_idx: Option<usize>,
    /// When true, render without the top status bar and HUD so the normal
    /// terminal scrollback remains usable (Ctrl+T standard terminal mode).
    pub(crate) standard_terminal_mode: bool,
    // Pending system notes to inject into the agent's conversation history
    // before the next user turn. Each entry is sent in order ahead of the
    // user's visible prompt.
    pending_agent_notes: Vec<String>,

    // Stable synthetic request bucket for pre‑turn system notices (set on first use)
    synthetic_system_req: Option<u64>,
    // Map of system notice ids to their history index for in-place replacement
    system_cell_by_id: std::collections::HashMap<String, usize>,
    // Per-request counters for UI-issued background order metadata
    ui_background_seq_counters: HashMap<u64, Arc<AtomicU64>>,
    // Track the largest order key we have assigned so far to keep tail inserts monotonic
    last_assigned_order: Option<OrderKey>,
    replay_history_depth: usize,
    resume_placeholder_visible: bool,
}

#[derive(Clone)]
pub(crate) struct BackgroundOrderTicket {
    request_ordinal: u64,
    seq_counter: Arc<AtomicU64>,
}

impl BackgroundOrderTicket {
    pub(crate) fn next_order(&self) -> code_core::protocol::OrderMeta {
        let seq = self.seq_counter.fetch_add(1, Ordering::SeqCst);
        code_core::protocol::OrderMeta {
            request_ordinal: self.request_ordinal,
            output_index: Some(i32::MAX as u32),
            sequence_number: Some(seq),
        }
    }

}

#[derive(Clone)]
struct GhostSnapshot {
    commit: GhostCommit,
    captured_at: DateTime<Local>,
    summary: Option<String>,
    conversation: ConversationSnapshot,
    history: HistorySnapshot,
}

#[derive(Clone, Copy)]
enum UndoPreviewRole {
    User,
    Assistant,
}

impl GhostSnapshot {
    fn new(
        commit: GhostCommit,
        summary: Option<String>,
        conversation: ConversationSnapshot,
        history: HistorySnapshot,
    ) -> Self {
        let summary = summary.and_then(|text| {
            let trimmed = text.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_string())
            }
        });
        Self {
            commit,
            captured_at: Local::now(),
            summary,
            conversation,
            history,
        }
    }

    fn commit(&self) -> &GhostCommit {
        &self.commit
    }

    fn short_id(&self) -> String {
        self.commit.id().chars().take(8).collect()
    }

    fn summary_snippet(&self, max_len: usize) -> Option<String> {
        let summary = self.summary.as_ref()?;
        let mut snippet = String::new();
        let mut truncated = false;
        for word in summary.split_whitespace() {
            if !snippet.is_empty() {
                snippet.push(' ');
            }
            snippet.push_str(word);
            if snippet.chars().count() > max_len {
                truncated = true;
                break;
            }
        }

        if snippet.chars().count() > max_len {
            truncated = true;
            snippet = snippet.chars().take(max_len).collect();
        }

        if truncated {
            snippet.push('…');
        }

        Some(snippet)
    }

    fn age_from(&self, now: DateTime<Local>) -> Option<std::time::Duration> {
        now.signed_duration_since(self.captured_at).to_std().ok()
    }
}

#[derive(Clone)]
struct GhostSnapshotRequest {
    summary: Option<String>,
    conversation: ConversationSnapshot,
    history: HistorySnapshot,
    started_at: Instant,
}

impl GhostSnapshotRequest {
    fn new(
        summary: Option<String>,
        conversation: ConversationSnapshot,
        history: HistorySnapshot,
    ) -> Self {
        Self {
            summary,
            conversation,
            history,
            started_at: Instant::now(),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum GhostSnapshotJobHandle {
    Scheduled(u64),
    Skipped,
}

#[derive(Clone)]
enum PendingSnapshotDispatch {
    Queued { job_id: u64, message: UserMessage },
}

impl PendingSnapshotDispatch {
    fn job_id(&self) -> u64 {
        match self {
            PendingSnapshotDispatch::Queued { job_id, .. } => *job_id,
        }
    }
}

#[derive(Default)]
struct GitBranchCache {
    value: Option<String>,
    last_head_mtime: Option<SystemTime>,
    last_refresh: Option<Instant>,
}

#[derive(Debug, Clone, Default)]
struct AgentRuntime {
    /// First time this agent entered Running
    started_at: Option<Instant>,
    /// Time of the latest status update we observed
    last_update: Option<Instant>,
    /// Time the agent reached a terminal state (Completed/Failed)
    completed_at: Option<Instant>,
}

#[derive(Debug, Clone)]
struct AgentTerminalEntry {
    name: String,
    batch_id: Option<String>,
    batch_label: Option<String>,
    batch_prompt: Option<String>,
    batch_context: Option<String>,
    model: Option<String>,
    status: AgentStatus,
    last_progress: Option<String>,
    result: Option<String>,
    error: Option<String>,
    logs: Vec<AgentLogEntry>,
}

impl AgentTerminalEntry {
    fn new(
        name: String,
        model: Option<String>,
        status: AgentStatus,
        batch_id: Option<String>,
    ) -> Self {
        Self {
            name,
            batch_id,
            batch_label: None,
            batch_prompt: None,
            batch_context: None,
            model,
            status,
            last_progress: None,
            result: None,
            error: None,
            logs: Vec::new(),
        }
    }

    fn push_log(&mut self, kind: AgentLogKind, message: impl Into<String>) {
        let msg = message.into();
        if self
            .logs
            .last()
            .map(|entry| entry.kind == kind && entry.message == msg)
            .unwrap_or(false)
        {
            return;
        }
        self.logs.push(AgentLogEntry {
            timestamp: Local::now(),
            kind,
            message: msg,
        });
        const MAX_HISTORY: usize = 500;
        if self.logs.len() > MAX_HISTORY {
            let excess = self.logs.len() - MAX_HISTORY;
            self.logs.drain(0..excess);
        }
    }
}

#[derive(Debug, Clone)]
struct AgentLogEntry {
    timestamp: DateTime<Local>,
    kind: AgentLogKind,
    message: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum AgentLogKind {
    Status,
    Progress,
    Result,
    Error,
}

struct AgentsTerminalState {
    active: bool,
    selected_index: usize,
    order: Vec<String>,
    entries: HashMap<String, AgentTerminalEntry>,
    scroll_offsets: HashMap<String, u16>,
    saved_scroll_offset: u16,
    shared_context: Option<String>,
    shared_task: Option<String>,
    focus: AgentsTerminalFocus,
}

#[derive(Default, Clone)]
struct AgentBatchMetadata {
    label: Option<String>,
    prompt: Option<String>,
    context: Option<String>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum AgentsSidebarEntry {
    Overview(Option<String>),
    Agent(String),
}

#[derive(Clone, Debug)]
struct AgentsSidebarGroup {
    batch_id: Option<String>,
    label: String,
    agent_ids: Vec<String>,
}

fn short_batch_label(batch_id: &str) -> String {
    let compact: String = batch_id.chars().filter(|c| *c != '-').collect();
    let source = if compact.is_empty() { batch_id } else { compact.as_str() };
    let short: String = source.chars().take(8).collect();
    if short.is_empty() {
        "Batch".to_string()
    } else {
        format!("Batch {short}")
    }
}

impl AgentsSidebarEntry {
    fn scroll_key(&self) -> String {
        match self {
            AgentsSidebarEntry::Agent(id) => format!("agent:{id}"),
            AgentsSidebarEntry::Overview(Some(batch)) => format!("batch:{batch}"),
            AgentsSidebarEntry::Overview(None) => "batch:__adhoc__".to_string(),
        }
    }
}

impl AgentsTerminalState {
    fn new() -> Self {
        Self {
            active: false,
            selected_index: 0,
            order: Vec::new(),
            entries: HashMap::new(),
            scroll_offsets: HashMap::new(),
            saved_scroll_offset: 0,
            shared_context: None,
            shared_task: None,
            focus: AgentsTerminalFocus::Sidebar,
        }
    }

    fn reset(&mut self) {
        self.selected_index = 0;
        self.order.clear();
        self.entries.clear();
        self.scroll_offsets.clear();
        self.shared_context = None;
        self.shared_task = None;
        self.focus = AgentsTerminalFocus::Sidebar;
    }

    fn current_sidebar_entry(&self) -> Option<AgentsSidebarEntry> {
        let entries = self.sidebar_entries();
        entries.get(self.selected_index).cloned()
    }

    fn focus_sidebar(&mut self) {
        self.focus = AgentsTerminalFocus::Sidebar;
    }

    fn focus_detail(&mut self) {
        self.focus = AgentsTerminalFocus::Detail;
    }

    fn focus(&self) -> AgentsTerminalFocus {
        self.focus
    }

    fn clamp_selected_index(&mut self) {
        let entries = self.sidebar_entries();
        if entries.is_empty() {
            self.selected_index = 0;
        } else if self.selected_index >= entries.len() {
            self.selected_index = entries.len().saturating_sub(1);
        }
    }

    fn sidebar_entries(&self) -> Vec<AgentsSidebarEntry> {
        let mut out = Vec::new();
        for group in self.sidebar_groups() {
            out.push(AgentsSidebarEntry::Overview(group.batch_id.clone()));
            for agent_id in group.agent_ids {
                out.push(AgentsSidebarEntry::Agent(agent_id));
            }
        }
        out
    }

    fn sidebar_groups(&self) -> Vec<AgentsSidebarGroup> {
        let mut groups: Vec<AgentsSidebarGroup> = Vec::new();
        let mut group_lookup: HashMap<Option<String>, usize> = HashMap::new();
        for id in &self.order {
            if let Some(entry) = self.entries.get(id) {
                let key = entry.batch_id.clone();
                let idx = if let Some(idx) = group_lookup.get(&key) {
                    *idx
                } else {
                    let label = entry
                        .batch_label
                        .as_ref()
                        .and_then(|value| {
                            let trimmed = value.trim();
                            (!trimmed.is_empty()).then(|| trimmed.to_string())
                        })
                        .or_else(|| {
                            key.as_ref().map(|batch| short_batch_label(batch))
                        })
                        .unwrap_or_else(|| "Ad-hoc Agents".to_string());
                    let idx = groups.len();
                    group_lookup.insert(key.clone(), idx);
                    groups.push(AgentsSidebarGroup {
                        batch_id: key.clone(),
                        label,
                        agent_ids: Vec::new(),
                    });
                    idx
                };
                if let Some(group) = groups.get_mut(idx) {
                    group.agent_ids.push(id.clone());
                }
            }
        }
        groups
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum AgentsTerminalFocus {
    Sidebar,
    Detail,
}

// ---------- Stable ordering & routing helpers ----------
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
struct OrderKey {
    req: u64,
    out: i32,
    seq: u64,
}

impl Ord for OrderKey {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match self.req.cmp(&other.req) {
            std::cmp::Ordering::Equal => match self.out.cmp(&other.out) {
                std::cmp::Ordering::Equal => self.seq.cmp(&other.seq),
                o => o,
            },
            o => o,
        }
    }
}

impl PartialOrd for OrderKey {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl From<OrderKeySnapshot> for OrderKey {
    fn from(snapshot: OrderKeySnapshot) -> Self {
        Self {
            req: snapshot.req,
            out: snapshot.out,
            seq: snapshot.seq,
        }
    }
}

impl From<OrderKey> for OrderKeySnapshot {
    fn from(key: OrderKey) -> Self {
        OrderKeySnapshot {
            req: key.req,
            out: key.out,
            seq: key.seq,
        }
    }
}

// Removed legacy turn-window logic; ordering is strictly global.

// Global guard to prevent overlapping background screenshot captures and to rate-limit them
static BG_SHOT_IN_FLIGHT: Lazy<AtomicBool> = Lazy::new(|| AtomicBool::new(false));
static BG_SHOT_LAST_START_MS: Lazy<AtomicU64> = Lazy::new(|| AtomicU64::new(0));
static MERGE_LOCKS: Lazy<Mutex<HashMap<PathBuf, Arc<tokio::sync::Mutex<()>>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));

use self::diff_ui::DiffBlock;
use self::diff_ui::DiffConfirm;
use self::diff_ui::DiffOverlay;
use self::settings_overlay::{
    AgentOverviewRow,
    AutoDriveSettingsContent,
    AgentsSettingsContent,
    GithubSettingsContent,
    LimitsSettingsContent,
    ChromeSettingsContent,
    McpSettingsContent,
    ModelSettingsContent,
    NotificationsSettingsContent,
    ThemeSettingsContent,
    UpdatesSettingsContent,
    ValidationSettingsContent,
    SettingsOverlayView,
    SettingsOverviewRow,
};
use ratatui::text::Line as RtLine;
use ratatui::text::Span as RtSpan;


use self::perf::PerfStats;

#[derive(Debug, Clone)]
struct AgentInfo {
    // Stable id to correlate updates
    id: String,
    // Display name
    name: String,
    // Current status
    status: AgentStatus,
    // Batch identifier reported by the core (if any)
    batch_id: Option<String>,
    // Optional model name
    model: Option<String>,
    // Final success message when completed
    result: Option<String>,
    // Final error message when failed
    error: Option<String>,
    // Most recent progress line from core
    last_progress: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
enum AgentStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

fn agent_status_from_str(status: &str) -> AgentStatus {
    match status {
        "pending" => AgentStatus::Pending,
        "running" => AgentStatus::Running,
        "completed" => AgentStatus::Completed,
        "failed" => AgentStatus::Failed,
        "cancelled" => AgentStatus::Cancelled,
        _ => AgentStatus::Pending,
    }
}

fn agent_status_label(status: AgentStatus) -> &'static str {
    match status {
        AgentStatus::Pending => "Pending",
        AgentStatus::Running => "Running",
        AgentStatus::Completed => "Completed",
        AgentStatus::Failed => "Failed",
        AgentStatus::Cancelled => "Cancelled",
    }
}

fn agent_status_color(status: AgentStatus) -> ratatui::style::Color {
    match status {
        AgentStatus::Pending => crate::colors::warning(),
        AgentStatus::Running => crate::colors::info(),
        AgentStatus::Completed => crate::colors::success(),
        AgentStatus::Failed => crate::colors::error(),
        AgentStatus::Cancelled => crate::colors::warning(),
    }
}

fn agent_log_label(kind: AgentLogKind) -> &'static str {
    match kind {
        AgentLogKind::Status => "status",
        AgentLogKind::Progress => "progress",
        AgentLogKind::Result => "result",
        AgentLogKind::Error => "error",
    }
}

fn agent_log_color(kind: AgentLogKind) -> ratatui::style::Color {
    match kind {
        AgentLogKind::Status => crate::colors::info(),
        AgentLogKind::Progress => crate::colors::primary(),
        AgentLogKind::Result => crate::colors::success(),
        AgentLogKind::Error => crate::colors::error(),
    }
}

use self::message::create_initial_user_message;

// Newtype IDs for clarity across exec/tools/streams
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(super) struct ExecCallId(pub String);
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(super) struct ToolCallId(pub String);
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(super) struct StreamId(pub String);

impl From<String> for ExecCallId {
    fn from(s: String) -> Self {
        ExecCallId(s)
    }
}
impl From<&str> for ExecCallId {
    fn from(s: &str) -> Self {
        ExecCallId(s.to_string())
    }
}

fn wait_target_from_params(params: Option<&String>, call_id: &str) -> String {
    if let Some(raw) = params {
        if let Ok(json) = serde_json::from_str::<serde_json::Value>(raw) {
            if let Some(for_value) = json.get("for").and_then(|v| v.as_str()) {
                let cleaned = clean_wait_command(for_value);
                if !cleaned.is_empty() {
                    return cleaned;
                }
            }
            if let Some(cid) = json.get("call_id").and_then(|v| v.as_str()) {
                return format!("call {}", cid);
            }
        }
    }
    format!("call {}", call_id)
}

fn wait_exec_call_id_from_params(params: Option<&String>) -> Option<ExecCallId> {
    params
        .and_then(|raw| serde_json::from_str::<serde_json::Value>(raw).ok())
        .and_then(|json| json.get("call_id").and_then(|v| v.as_str()).map(|s| ExecCallId(s.to_string())))
}

impl std::fmt::Display for ExecCallId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl AsRef<str> for ExecCallId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl From<String> for ToolCallId {
    fn from(s: String) -> Self {
        ToolCallId(s)
    }
}
impl From<&str> for ToolCallId {
    fn from(s: &str) -> Self {
        ToolCallId(s.to_string())
    }
}
impl std::fmt::Display for ToolCallId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl AsRef<str> for ToolCallId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl From<String> for StreamId {
    fn from(s: String) -> Self {
        StreamId(s)
    }
}
impl From<&str> for StreamId {
    fn from(s: &str) -> Self {
        StreamId(s.to_string())
    }
}
impl std::fmt::Display for StreamId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl AsRef<str> for StreamId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

// ---- System notice ordering helpers ----
#[derive(Copy, Clone)]
enum SystemPlacement {
    /// Place near the top of the current request (before most provider output)
    EarlyInCurrent,
    /// Place at the end of the current request window (after provider output)
    EndOfCurrent,
    /// Place before the first user prompt of the very first request
    /// (used for pre-turn UI confirmations like theme/spinner changes)
    PrePromptInCurrent,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum AutoDriveRole {
    User,
    Assistant,
}

impl ChatWidget<'_> {
    const MAX_UNDO_CONVERSATION_MESSAGES: usize = 8;
    const MAX_UNDO_PREVIEW_CHARS: usize = 160;
    const MAX_UNDO_FILE_LINES: usize = 24;

    fn fmt_short_duration(&self, d: Duration) -> String {
        let s = d.as_secs();
        let h = s / 3600;
        let m = (s % 3600) / 60;
        let sec = s % 60;
        if h > 0 {
            format!("{}h{}m", h, m)
        } else if m > 0 {
            format!("{}m{}s", m, sec)
        } else {
            format!("{}s", sec)
        }
    }
    fn is_branch_worktree_path(path: &std::path::Path) -> bool {
        for ancestor in path.ancestors() {
            if ancestor
                .file_name()
                .map(|name| name == std::ffi::OsStr::new("branches"))
                .unwrap_or(false)
            {
                let mut higher = ancestor.parent();
                while let Some(dir) = higher {
                    if dir
                        .file_name()
                        .map(|name| name == std::ffi::OsStr::new(".code"))
                        .unwrap_or(false)
                    {
                        return true;
                    }
                    higher = dir.parent();
                }
            }
        }
        false
    }

    fn merge_lock_for_repo(path: &std::path::Path) -> Arc<tokio::sync::Mutex<()>> {
        let key = path.to_path_buf();
        let mut locks = MERGE_LOCKS.lock().unwrap();
        match locks.entry(key) {
            Entry::Occupied(existing) => existing.get().clone(),
            Entry::Vacant(slot) => slot.insert(Arc::new(tokio::sync::Mutex::new(()))).clone(),
        }
    }

    async fn git_short_status(path: &std::path::Path) -> Result<String, String> {
        use tokio::process::Command;
        match Command::new("git")
            .current_dir(path)
            .args(["status", "--short"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => Ok(String::from_utf8_lossy(&out.stdout).to_string()),
            Ok(out) => {
                let stderr_s = String::from_utf8_lossy(&out.stderr).trim().to_string();
                let stdout_s = String::from_utf8_lossy(&out.stdout).trim().to_string();
                if !stderr_s.is_empty() {
                    Err(stderr_s)
                } else if !stdout_s.is_empty() {
                    Err(stdout_s)
                } else {
                    let code = out
                        .status
                        .code()
                        .map(|c| format!("exit status {c}"))
                        .unwrap_or_else(|| "terminated by signal".to_string());
                    Err(format!("git status failed: {}", code))
                }
            }
            Err(err) => Err(err.to_string()),
        }
    }

    async fn git_diff_stat(path: &std::path::Path) -> Result<String, String> {
        use tokio::process::Command;
        match Command::new("git")
            .current_dir(path)
            .args(["diff", "--stat"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => Ok(String::from_utf8_lossy(&out.stdout).to_string()),
            Ok(out) => {
                let stderr_s = String::from_utf8_lossy(&out.stderr).trim().to_string();
                let stdout_s = String::from_utf8_lossy(&out.stdout).trim().to_string();
                if !stderr_s.is_empty() {
                    Err(stderr_s)
                } else if !stdout_s.is_empty() {
                    Err(stdout_s)
                } else {
                    let code = out
                        .status
                        .code()
                        .map(|c| format!("exit status {c}"))
                        .unwrap_or_else(|| "terminated by signal".to_string());
                    Err(format!("git diff --stat failed: {code}"))
                }
            }
            Err(err) => Err(err.to_string()),
        }
    }

    /// Compute an OrderKey for system (non‑LLM) notices in a way that avoids
    /// creating multiple synthetic request buckets before the first provider turn.
    fn system_order_key(
        &mut self,
        placement: SystemPlacement,
        order: Option<&code_core::protocol::OrderMeta>,
    ) -> OrderKey {
        // If the provider supplied OrderMeta, honor it strictly.
        if let Some(om) = order {
            return self.provider_order_key_from_order_meta(om);
        }

        // Derive a stable request bucket for system notices when OrderMeta is absent.
        // Default to the current provider request if known; else use a sticky
        // pre-turn synthetic req=1 to group UI confirmations before the first turn.
        // If a user prompt for the next turn is already queued, attach new
        // system notices to the upcoming request to avoid retroactive inserts.
        let mut req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            if self.synthetic_system_req.is_none() {
                self.synthetic_system_req = Some(1);
            }
            self.synthetic_system_req.unwrap_or(1)
        };
        if order.is_none() && self.pending_user_prompts_for_next_turn > 0 {
            req = req.saturating_add(1);
        }

        self.internal_seq = self.internal_seq.saturating_add(1);
        let mut out = match placement {
            SystemPlacement::EarlyInCurrent => i32::MIN + 2,
            SystemPlacement::EndOfCurrent => i32::MAX,
            SystemPlacement::PrePromptInCurrent => i32::MIN,
        };

        if order.is_none()
            && self.pending_user_prompts_for_next_turn > 0
            && matches!(placement, SystemPlacement::EarlyInCurrent)
        {
            out = i32::MIN;
        }

        let mut key = OrderKey {
            req,
            out,
            seq: self.internal_seq,
        };

        if matches!(placement, SystemPlacement::EndOfCurrent) {
            let reference = self
                .last_assigned_order
                .or_else(|| self.cell_order_seq.iter().copied().max());
            if let Some(max_key) = reference {
                if key <= max_key {
                    key = Self::order_key_successor(max_key);
                }
            }
        }

        self.internal_seq = self.internal_seq.max(key.seq);
        self.last_assigned_order = Some(match self.last_assigned_order {
            Some(prev) => prev.max(key),
            None => key,
        });

        key
    }

    fn background_tail_request_ordinal(&mut self) -> u64 {
        let mut req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            *self.synthetic_system_req.get_or_insert(1)
        };
        if self.pending_user_prompts_for_next_turn > 0 {
            req = req.saturating_add(1);
        }
        if let Some(last) = self.last_assigned_order {
            req = req.max(last.req);
        }
        if let Some(max_req) = self.ui_background_seq_counters.keys().copied().max() {
            req = req.max(max_req);
        }
        req
    }

    fn background_order_ticket_for_req(&mut self, req: u64) -> BackgroundOrderTicket {
        let seed = self
            .last_assigned_order
            .filter(|key| key.req == req)
            .map(|key| key.seq.saturating_add(1))
            .unwrap_or(0);

        let counter = self
            .ui_background_seq_counters
            .entry(req)
            .or_insert_with(|| Arc::new(AtomicU64::new(seed)))
            .clone();

        if seed > 0 {
            let current = counter.load(Ordering::SeqCst);
            if current < seed {
                counter.store(seed, Ordering::SeqCst);
            }
        }
        BackgroundOrderTicket {
            request_ordinal: req,
            seq_counter: counter,
        }
    }

    fn background_tail_order_ticket_internal(&mut self) -> BackgroundOrderTicket {
        let req = self.background_tail_request_ordinal();
        self.background_order_ticket_for_req(req)
    }

    fn background_before_next_output_request_ordinal(&mut self) -> u64 {
        if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            *self.synthetic_system_req.get_or_insert(1)
        }
    }

    fn background_before_next_output_ticket_internal(&mut self) -> BackgroundOrderTicket {
        let req = self.background_before_next_output_request_ordinal();
        self.background_order_ticket_for_req(req)
    }

    pub(crate) fn make_background_tail_ticket(&mut self) -> BackgroundOrderTicket {
        self.background_tail_order_ticket_internal()
    }

    pub(crate) fn make_background_before_next_output_ticket(&mut self) -> BackgroundOrderTicket {
        self.background_before_next_output_ticket_internal()
    }

    fn auto_card_next_order_key(&mut self) -> OrderKey {
        let ticket = self.make_background_tail_ticket();
        let meta = ticket.next_order();
        self.provider_order_key_from_order_meta(&meta)
    }

    fn auto_card_start(&mut self, goal: Option<String>) {
        let order_key = self.auto_card_next_order_key();
        auto_drive_cards::start_session(self, order_key, goal);
    }

    fn auto_card_add_action(&mut self, message: String, kind: AutoDriveActionKind) {
        let order_key = self.auto_card_next_order_key();
        let had_tracker = self.tools_state.auto_drive_tracker.is_some();
        auto_drive_cards::record_action(self, order_key, message.clone(), kind);
        if !had_tracker {
            self.push_background_tail(message);
        }
    }

    fn auto_card_set_status(&mut self, status: AutoDriveStatus) {
        if self.tools_state.auto_drive_tracker.is_some() {
            let order_key = self.auto_card_next_order_key();
            auto_drive_cards::set_status(self, order_key, status);
        }
    }

    fn auto_card_set_goal(&mut self, goal: Option<String>) {
        if self.tools_state.auto_drive_tracker.is_none() {
            return;
        }
        let order_key = self.auto_card_next_order_key();
        auto_drive_cards::update_goal(self, order_key, goal);
    }

    fn auto_card_finalize(
        &mut self,
        message: Option<String>,
        status: AutoDriveStatus,
        kind: AutoDriveActionKind,
    ) {
        let had_tracker = self.tools_state.auto_drive_tracker.is_some();
        let order_key = self.auto_card_next_order_key();
        auto_drive_cards::finalize(self, order_key, message.clone(), status, kind);
        if !had_tracker {
            if let Some(msg) = message {
                self.push_background_tail(msg);
            }
        }
        auto_drive_cards::clear(self);
    }

    fn spawn_conversation_runtime(
        &mut self,
        config: Config,
        auth_manager: Arc<AuthManager>,
        code_op_rx: UnboundedReceiver<Op>,
    ) {
        let ticket = self.make_background_tail_ticket();
        let ticket_for_submit = ticket.clone();
        let app_event_tx_clone = self.app_event_tx.clone();

        tokio::spawn(async move {
            let mut code_op_rx = code_op_rx;
            let conversation_manager = ConversationManager::new(
                auth_manager.clone(),
                SessionSource::Cli,
            );
            let resume_path = config.experimental_resume.clone();
            let new_conversation = match resume_path {
                Some(path) => conversation_manager
                    .resume_conversation_from_rollout(config.clone(), path, auth_manager.clone())
                    .await,
                None => conversation_manager.new_conversation(config).await,
            };

            let new_conversation = match new_conversation {
                Ok(conv) => conv,
                Err(e) => {
                    tracing::error!("failed to initialize conversation: {e}");
                    app_event_tx_clone.send_background_event_with_ticket(
                        &ticket,
                        format!(
                            "❌ Failed to initialize model session: {}.\n• Ensure an OpenAI API key is set (CODE_OPENAI_API_KEY / OPENAI_API_KEY) or run `code login`.\n• Also verify config.cwd is an absolute path.",
                            e
                        ),
                    );
                    return;
                }
            };

            let event = Event {
                id: new_conversation.conversation_id.to_string(),
                event_seq: 0,
                msg: EventMsg::SessionConfigured(new_conversation.session_configured),
                order: None,
            };
            app_event_tx_clone.send(AppEvent::CodexEvent(event));

            let conversation = new_conversation.conversation;
            let conversation_clone = conversation.clone();
            let app_event_tx_submit = app_event_tx_clone.clone();
            let ticket_for_submit = ticket_for_submit.clone();

            tokio::spawn(async move {
                while let Some(op) = code_op_rx.recv().await {
                    if let Err(e) = conversation_clone.submit(op).await {
                        tracing::error!("failed to submit op: {e}");
                        app_event_tx_submit.send_background_event_with_ticket(
                            &ticket_for_submit,
                            format!("⚠️ Failed to submit Op to core: {}", e),
                        );
                    }
                }
            });

            while let Ok(event) = conversation.next_event().await {
                app_event_tx_clone.send(AppEvent::CodexEvent(event));
            }
            // (debug end notice removed)
        });
    }

    fn consume_pending_prompt_for_ui_only_turn(&mut self) {
        if self.pending_user_prompts_for_next_turn > 0 {
            self.pending_user_prompts_for_next_turn -= 1;
        }
        if !self.pending_dispatched_user_messages.is_empty() {
            self.pending_dispatched_user_messages.pop_front();
        }
    }

    fn background_tail_order_meta(&mut self) -> code_core::protocol::OrderMeta {
        self.background_tail_order_ticket_internal().next_order()
    }

    fn send_background_tail_ordered(&mut self, message: impl Into<String>) {
        let order = self.background_tail_order_meta();
        self.app_event_tx
            .send_background_event_with_order(message.into(), order);
    }

    fn rebuild_ui_background_seq_counters(&mut self) {
        self.ui_background_seq_counters.clear();
        let mut next_per_req: HashMap<u64, u64> = HashMap::new();
        for key in &self.cell_order_seq {
            if key.out == i32::MAX {
                let next = key.seq.saturating_add(1);
                let entry = next_per_req.entry(key.req).or_insert(0);
                *entry = (*entry).max(next);
            }
        }
        for (req, next) in next_per_req {
            self.ui_background_seq_counters
                .insert(req, Arc::new(AtomicU64::new(next)));
        }
    }

    /// Insert or replace a system notice cell with consistent ordering.
    /// If `id_for_replace` is provided and we have a prior index for it, replace in place.
    fn push_system_cell(
        &mut self,
        cell: Box<dyn HistoryCell>,
        placement: SystemPlacement,
        id_for_replace: Option<String>,
        order: Option<&code_core::protocol::OrderMeta>,
        tag: &'static str,
        record: Option<HistoryDomainRecord>,
    ) {
        if let Some(id) = id_for_replace.as_ref() {
            if let Some(&idx) = self.system_cell_by_id.get(id) {
                if let Some(record) = record.clone() {
                    self.history_replace_with_record(idx, cell, record);
                } else {
                    self.history_replace_at(idx, cell);
                }
                return;
            }
        }
        let key = self.system_order_key(placement, order);
        let pos = self.history_insert_with_key_global_tagged(cell, key, tag, record);
        if let Some(id) = id_for_replace {
            self.system_cell_by_id.insert(id, pos);
        }
    }

    /// Decide where to place a UI confirmation right now.
    /// If we're truly pre-turn (no provider traffic yet, and no queued prompt),
    /// place before the first user prompt. Otherwise, append to end of current.
    fn ui_placement_for_now(&self) -> SystemPlacement {
        if self.last_seen_request_index == 0 && self.pending_user_prompts_for_next_turn == 0 {
            SystemPlacement::PrePromptInCurrent
        } else {
            SystemPlacement::EndOfCurrent
        }
    }
    pub(crate) fn enable_perf(&mut self, enable: bool) {
        self.perf_state.enabled = enable;
    }
    pub(crate) fn perf_summary(&self) -> String {
        self.perf_state.stats.borrow().summary()
    }
    // Build an ordered key from model-provided OrderMeta. Callers must
    // guarantee presence by passing a concrete reference (compile-time guard).
    fn raw_order_key_from_order_meta(om: &code_core::protocol::OrderMeta) -> OrderKey {
        // sequence_number can be None on some terminal events; treat as 0 for stable placement
        OrderKey {
            req: om.request_ordinal,
            out: om.output_index.map(|v| v as i32).unwrap_or(0),
            seq: om.sequence_number.unwrap_or(0),
        }
    }

    fn provider_order_key_from_order_meta(&mut self, om: &code_core::protocol::OrderMeta) -> OrderKey {
        let mut key = Self::raw_order_key_from_order_meta(om);
        key.req = self.apply_request_bias(key.req);
        key
    }

    fn apply_request_bias(&mut self, provider_req: u64) -> u64 {
        if self.resume_provider_baseline.is_none() {
            if let Some(target) = self.resume_expected_next_request {
                self.resume_provider_baseline = Some(provider_req);
                if provider_req <= target {
                    self.order_request_bias = target.saturating_sub(provider_req);
                } else {
                    self.order_request_bias = 0;
                }
                self.resume_expected_next_request = None;
            }
        }
        provider_req.saturating_add(self.order_request_bias)
    }

    // Track latest request index observed from provider so internal inserts can anchor to it.
    fn note_order(&mut self, order: Option<&code_core::protocol::OrderMeta>) {
        if let Some(om) = order {
            let is_background_sentinel = om.output_index == Some(i32::MAX as u32);
            let is_initial_session = self.last_seen_request_index == 0;
            if is_background_sentinel && is_initial_session {
                return;
            }
            let req = self.apply_request_bias(om.request_ordinal);
            self.last_seen_request_index = self.last_seen_request_index.max(req);
        }
    }

    fn debug_fmt_order_key(ok: OrderKey) -> String {
        format!("O:req={} out={} seq={}", ok.req, ok.out, ok.seq)
    }

    fn order_key_successor(after: OrderKey) -> OrderKey {
        if after.seq != u64::MAX {
            return OrderKey {
                req: after.req,
                out: after.out,
                seq: after.seq.saturating_add(1),
            };
        }

        if after.out != i32::MAX {
            return OrderKey {
                req: after.req,
                out: after.out.saturating_add(1),
                seq: 0,
            };
        }

        OrderKey {
            req: after.req.saturating_add(1),
            out: i32::MIN,
            seq: 0,
        }
    }

    // Allocate a key that places an internal (non‑model) event at the point it
    // occurs during the current request, instead of sinking it to the end.
    //
    // Strategy:
    // - If an OrderMeta is provided, honor it (strict model ordering).
    // - Otherwise, if a new turn is queued (a user prompt was just inserted),
    //   anchor immediately after that prompt within the upcoming request so
    //   the notice appears in the right window.
    // - Otherwise, derive a key within the current request:
    //   * If there is any existing cell in this request, append after the
    //     latest key in this request (req = last_seen, out/seq bumped).
    //   * If no cells exist for this request yet, place near the top of this
    //     request (after headers/prompts) so provider output can follow.
    fn near_time_key(&mut self, order: Option<&code_core::protocol::OrderMeta>) -> OrderKey {
        if let Some(om) = order {
            return self.provider_order_key_from_order_meta(om);
        }

        // If we just staged a user prompt for the next request, keep using the
        // next‑turn anchor so the background item lands with that turn.
        if self.pending_user_prompts_for_next_turn > 0 {
            return self.next_req_key_after_prompt();
        }

        let req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            // No provider traffic yet: allocate a synthetic request bucket.
            // Use the same path as next_internal_key() to keep monotonicity.
            if self.current_request_index < self.last_seen_request_index {
                self.current_request_index = self.last_seen_request_index;
            }
            self.current_request_index = self.current_request_index.saturating_add(1);
            self.current_request_index
        };

        // Scan for the latest key within this request to append after.
        let mut last_in_req: Option<OrderKey> = None;
        for k in &self.cell_order_seq {
            if k.req == req {
                last_in_req = Some(match last_in_req {
                    Some(prev) => {
                        if *k > prev {
                            *k
                        } else {
                            prev
                        }
                    }
                    None => *k,
                });
            }
        }

        self.internal_seq = self.internal_seq.saturating_add(1);
        match last_in_req {
            Some(last) => OrderKey {
                req,
                out: last.out,
                seq: last.seq.saturating_add(1),
            },
            None => OrderKey {
                req,
                out: i32::MIN + 2,
                seq: self.internal_seq,
            },
        }
    }

    /// Like near_time_key but never advances to the next request when a prompt is queued.
    /// Use this for late, provider-origin items that lack OrderMeta (e.g., PlanUpdate)
    /// so they remain attached to the current/last request instead of jumping forward.
    fn near_time_key_current_req(
        &mut self,
        order: Option<&code_core::protocol::OrderMeta>,
    ) -> OrderKey {
        if let Some(om) = order {
            return self.provider_order_key_from_order_meta(om);
        }
        let req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            if self.current_request_index < self.last_seen_request_index {
                self.current_request_index = self.last_seen_request_index;
            }
            self.current_request_index = self.current_request_index.saturating_add(1);
            self.current_request_index
        };

        let mut last_in_req: Option<OrderKey> = None;
        for k in &self.cell_order_seq {
            if k.req == req {
                last_in_req = Some(match last_in_req {
                    Some(prev) => {
                        if *k > prev {
                            *k
                        } else {
                            prev
                        }
                    }
                    None => *k,
                });
            }
        }
        self.internal_seq = self.internal_seq.saturating_add(1);
        match last_in_req {
            Some(last) => OrderKey {
                req,
                out: last.out,
                seq: last.seq.saturating_add(1),
            },
            None => OrderKey {
                req,
                out: i32::MIN + 2,
                seq: self.internal_seq,
            },
        }
    }

    // After inserting a non‑reasoning cell during streaming, restore the
    // in‑progress indicator on the latest reasoning cell so the ellipsis
    // remains visible while the model continues.
    fn restore_reasoning_in_progress_if_streaming(&mut self) {
        if !self.stream.is_write_cycle_active() {
            return;
        }
        if let Some(idx) = self.history_cells.iter().rposition(|c| {
            c.as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                .is_some()
        }) {
            if let Some(rc) = self.history_cells[idx]
                .as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            {
                rc.set_in_progress(true);
            }
        }
    }

    fn apply_plan_terminal_title(&mut self, title: Option<String>) {
        if self.active_plan_title == title {
            return;
        }
        self.active_plan_title = title.clone();
        self.app_event_tx
            .send(AppEvent::SetTerminalTitle { title });
    }
    // Allocate a new synthetic key for internal (non-LLM) messages at the bottom of the
    // current (active) request: (req = last_seen, out = +∞, seq = monotonic).
    fn next_internal_key(&mut self) -> OrderKey {
        // Anchor to the current provider request if known; otherwise step a synthetic counter.
        let mut req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            // Ensure current_request_index always moves forward
            if self.current_request_index < self.last_seen_request_index {
                self.current_request_index = self.last_seen_request_index;
            }
            self.current_request_index = self.current_request_index.saturating_add(1);
            self.current_request_index
        };
        if self.pending_user_prompts_for_next_turn > 0 {
            let next_req = self.last_seen_request_index.saturating_add(1);
            if req < next_req {
                req = next_req;
            }
        }
        if self.current_request_index < req {
            self.current_request_index = req;
        }
        self.internal_seq = self.internal_seq.saturating_add(1);
        // Place internal notices at the end of the current request window by using
        // a maximal out so they sort after any model-provided output_index.
        OrderKey {
            req,
            out: i32::MAX,
            seq: self.internal_seq,
        }
    }

    /// Show the "Shift+Up/Down" input history hint the first time the user scrolls.
    pub(super) fn maybe_show_history_nav_hint_on_first_scroll(&mut self) {
        if self.scroll_history_hint_shown {
            return;
        }
        self.scroll_history_hint_shown = true;
        self.bottom_pane.flash_footer_notice_for(
            "Use Shift+Up/Down to use previous input".to_string(),
            std::time::Duration::from_secs(6),
        );
    }

    pub(super) fn perf_track_scroll_delta(&self, before: u16, after: u16) {
        if !self.perf_state.enabled {
            return;
        }
        if before == after {
            return;
        }
        let delta = before.abs_diff(after) as u64;
        {
            let mut stats = self.perf_state.stats.borrow_mut();
            stats.record_scroll_trigger(delta);
        }
        let pending = self
            .perf_state
            .pending_scroll_rows
            .get()
            .saturating_add(delta);
        self.perf_state.pending_scroll_rows.set(pending);
    }

    // Synthetic key for internal content that should appear at the TOP of the NEXT request
    // (e.g., the user’s prompt preceding the model’s output for that turn).
    fn next_req_key_top(&mut self) -> OrderKey {
        let req = self.last_seen_request_index.saturating_add(1);
        self.internal_seq = self.internal_seq.saturating_add(1);
        OrderKey {
            req,
            out: i32::MIN,
            seq: self.internal_seq,
        }
    }

    // Synthetic key for a user prompt that should appear just after banners but
    // still before any model output within the next request.
    fn next_req_key_prompt(&mut self) -> OrderKey {
        let req = self.last_seen_request_index.saturating_add(1);
        self.internal_seq = self.internal_seq.saturating_add(1);
        OrderKey {
            req,
            out: i32::MIN + 1,
            seq: self.internal_seq,
        }
    }

    // Synthetic key for internal notices tied to the upcoming turn that
    // should appear immediately after the user prompt but still before any
    // model output for that turn.
    fn next_req_key_after_prompt(&mut self) -> OrderKey {
        let req = self.last_seen_request_index.saturating_add(1);
        self.internal_seq = self.internal_seq.saturating_add(1);
        OrderKey {
            req,
            out: i32::MIN + 2,
            seq: self.internal_seq,
        }
    }
    /// Returns true if any agents are actively running (Pending or Running), or we're about to start them.
    /// Agents in terminal states (Completed/Failed) do not keep the spinner visible.
    fn agents_are_actively_running(&self) -> bool {
        if self.agents_ready_to_start {
            return true;
        }
        self.active_agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Pending | AgentStatus::Running))
    }

    fn has_cancelable_agents(&self) -> bool {
        self
            .active_agents
            .iter()
            .any(|agent| matches!(agent.status, AgentStatus::Pending | AgentStatus::Running))
    }

    fn collect_cancelable_agents(&self) -> (Vec<String>, Vec<String>) {
        let mut batch_ids: BTreeSet<String> = BTreeSet::new();
        let mut agent_ids: BTreeSet<String> = BTreeSet::new();

        for agent in &self.active_agents {
            if !matches!(agent.status, AgentStatus::Pending | AgentStatus::Running) {
                continue;
            }

            if let Some(batch) = agent.batch_id.as_ref() {
                let trimmed = batch.trim();
                if !trimmed.is_empty() {
                    batch_ids.insert(trimmed.to_string());
                    continue;
                }
            }

            let trimmed_id = agent.id.trim();
            if !trimmed_id.is_empty() {
                agent_ids.insert(trimmed_id.to_string());
            }
        }

        (
            batch_ids.into_iter().collect(),
            agent_ids.into_iter().collect(),
        )
    }

    fn cancel_active_agents(&mut self) -> bool {
        let (batch_ids, agent_ids) = self.collect_cancelable_agents();
        if batch_ids.is_empty() && agent_ids.is_empty() {
            return false;
        }

        let mut status_parts = Vec::new();
        if !batch_ids.is_empty() {
            let count = batch_ids.len();
            status_parts.push(if count == 1 {
                "1 batch".to_string()
            } else {
                format!("{count} batches")
            });
        }
        if !agent_ids.is_empty() {
            let count = agent_ids.len();
            status_parts.push(if count == 1 {
                "1 agent".to_string()
            } else {
                format!("{count} agents")
            });
        }

        let descriptor = if status_parts.is_empty() {
            "agents".to_string()
        } else {
            status_parts.join(", ")
        };
        let auto_active = self.auto_state.is_active();
        let non_agent_activity =
            self.has_running_commands_or_tools() || !self.active_task_ids.is_empty();
        self.push_background_tail(format!("Cancelling {descriptor}…"));
        self.bottom_pane
            .update_status_text("Cancelling agents…".to_string());
        self.bottom_pane.set_task_running(true);
        self.submit_op(Op::CancelAgents { batch_ids, agent_ids });

        // Mark agents locally so Esc can progress to stopping Auto Drive even if
        // backend acknowledgements arrive later.
        self.agents_ready_to_start = false;
        for agent in &mut self.active_agents {
            if matches!(agent.status, AgentStatus::Pending | AgentStatus::Running) {
                agent.status = AgentStatus::Cancelled;
            }
        }
        let status_message = if auto_active {
            "Agents cancelled. Esc stops Auto Drive.".to_string()
        } else if non_agent_activity {
            "Agents cancelled. Esc cancels the running command.".to_string()
        } else {
            "Agents cancelled.".to_string()
        };
        self.bottom_pane.update_status_text(status_message);
        self.bottom_pane
            .set_task_running(auto_active || non_agent_activity);

        if auto_active {
            self.show_auto_drive_exit_hint();
        } else if self
            .bottom_pane
            .standard_terminal_hint()
            .is_some_and(|hint| hint == AUTO_ESC_EXIT_HINT)
        {
            self.bottom_pane.set_standard_terminal_hint(None);
        }
        self.request_redraw();

        true
    }

    /// Hide the bottom spinner/status if the UI is idle (no streams, tools, agents, or tasks).
    fn maybe_hide_spinner(&mut self) {
        let any_tools_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty();
        let any_streaming = self.stream.is_write_cycle_active();
        let any_agents_active = self.agents_are_actively_running();
        let any_tasks_active = !self.active_task_ids.is_empty();
        let terminal_running = self.terminal_is_running();
        if !(any_tools_running
            || any_streaming
            || any_agents_active
            || any_tasks_active
            || terminal_running)
        {
            self.bottom_pane.set_task_running(false);
            self.bottom_pane.update_status_text(String::new());
        }
    }

    #[inline]
    fn overall_task_status_for(agents: &[AgentInfo]) -> &'static str {
        if agents.is_empty() {
            "preparing"
        } else if agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Running))
        {
            "running"
        } else if agents
            .iter()
            .all(|a| matches!(a.status, AgentStatus::Completed))
        {
            "complete"
        } else if agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Failed))
        {
            "failed"
        } else if agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Cancelled))
        {
            "cancelled"
        } else {
            "planning"
        }
    }

    /// Mark all tracked agents as having reached a terminal state when a turn finishes.
    fn finalize_agent_activity(&mut self) {
        if self.active_agents.is_empty()
            && self.agent_runtime.is_empty()
            && self.agents_terminal.entries.is_empty()
        {
            self.agents_ready_to_start = false;
            return;
        }

        for agent in self.active_agents.iter_mut() {
            if matches!(agent.status, AgentStatus::Pending | AgentStatus::Running) {
                agent.status = AgentStatus::Completed;
            }
        }

        for entry in self.agents_terminal.entries.values_mut() {
            if matches!(entry.status, AgentStatus::Pending | AgentStatus::Running) {
                entry.status = AgentStatus::Completed;
                entry.push_log(
                    AgentLogKind::Status,
                    format!("Status → {}", agent_status_label(AgentStatus::Completed)),
                );
            }
        }

        self.agents_ready_to_start = false;
        let status = Self::overall_task_status_for(&self.active_agents);
        self.overall_task_status = status.to_string();
    }


    fn remove_background_completion_message(&mut self, call_id: &str) {
        if let Some(idx) = self.history_cells.iter().rposition(|cell| {
            matches!(cell.kind(), HistoryCellType::BackgroundEvent)
                && cell
                    .as_any()
                    .downcast_ref::<PlainHistoryCell>()
                    .map(|plain| {
                        plain.state().lines.iter().any(|line| {
                            line.spans
                                .iter()
                                .any(|span| span.text.contains(call_id))
                        })
                    })
                    .unwrap_or(false)
        }) {
            self.history_remove_at(idx);
        }
    }


    /// Flush any ExecEnd events that arrived before their matching ExecBegin.
    /// We briefly stash such ends to allow natural pairing when the Begin shows up
    /// shortly after. If the pairing window expires, render a fallback completed
    /// Exec cell so users still see the output in history.
    pub(crate) fn flush_pending_exec_ends(&mut self) {
        use std::time::Duration;
        use std::time::Instant;
        let now = Instant::now();
        // Collect keys to avoid holding a mutable borrow while iterating
        let mut ready: Vec<ExecCallId> = Vec::new();
        for (k, (_ev, _order, t0)) in self.exec.pending_exec_ends.iter() {
            if now.saturating_duration_since(*t0) >= Duration::from_millis(110) {
                ready.push(k.clone());
            }
        }
        for key in &ready {
            if let Some((ev, order, _t0)) = self.exec.pending_exec_ends.remove(&key) {
                // Regardless of whether a Begin has arrived by now, handle the End;
                // handle_exec_end_now pairs with a running Exec if present, or falls back.
                self.handle_exec_end_now(ev, &order);
            }
        }
        if !ready.is_empty() {
            self.request_redraw();
        }
    }

    fn finalize_all_running_as_interrupted(&mut self) {
        exec_tools::finalize_all_running_as_interrupted(self);
    }

    fn finalize_all_running_due_to_answer(&mut self) {
        exec_tools::finalize_all_running_due_to_answer(self);
    }
    fn perf_label_for_item(&self, item: &dyn HistoryCell) -> String {
        use crate::history_cell::ExecKind;
        use crate::history::state::ExecStatus;
        use crate::history_cell::HistoryCellType;
        use crate::history_cell::PatchKind;
        use crate::history_cell::ToolCellStatus;
        match item.kind() {
            HistoryCellType::Plain => "Plain".to_string(),
            HistoryCellType::User => "User".to_string(),
            HistoryCellType::Assistant => "Assistant".to_string(),
            HistoryCellType::Reasoning => "Reasoning".to_string(),
            HistoryCellType::Error => "Error".to_string(),
            HistoryCellType::Exec { kind, status } => {
                let k = match kind {
                    ExecKind::Read => "Read",
                    ExecKind::Search => "Search",
                    ExecKind::List => "List",
                    ExecKind::Run => "Run",
                };
                let s = match status {
                    ExecStatus::Running => "Running",
                    ExecStatus::Success => "Success",
                    ExecStatus::Error => "Error",
                };
                format!("Exec:{}:{}", k, s)
            }
            HistoryCellType::Tool { status } => {
                let s = match status {
                    ToolCellStatus::Running => "Running",
                    ToolCellStatus::Success => "Success",
                    ToolCellStatus::Failed => "Failed",
                };
                format!("Tool:{}", s)
            }
            HistoryCellType::Patch { kind } => {
                let k = match kind {
                    PatchKind::Proposed => "Proposed",
                    PatchKind::ApplyBegin => "ApplyBegin",
                    PatchKind::ApplySuccess => "ApplySuccess",
                    PatchKind::ApplyFailure => "ApplyFailure",
                };
                format!("Patch:{}", k)
            }
            HistoryCellType::PlanUpdate => "PlanUpdate".to_string(),
            HistoryCellType::BackgroundEvent => "BackgroundEvent".to_string(),
            HistoryCellType::Notice => "Notice".to_string(),
            HistoryCellType::Diff => "Diff".to_string(),
            HistoryCellType::Image => "Image".to_string(),
            HistoryCellType::AnimatedWelcome => "AnimatedWelcome".to_string(),
            HistoryCellType::Loading => "Loading".to_string(),
        }
    }

    pub(crate) fn show_resume_picker(&mut self) {
        // Discover candidates
        let cwd = self.config.cwd.clone();
        let code_home = self.config.code_home.clone();
        let candidates = crate::resume::discovery::list_sessions_for_cwd(&cwd, &code_home);
        if candidates.is_empty() {
            self.push_background_tail("No past sessions found for this folder".to_string());
            return;
        }
        // Convert to simple rows with aligned columns and human-friendly times
        fn human_ago(ts: &str) -> String {
            use chrono::DateTime;
            use chrono::Utc;
            if let Ok(dt) = DateTime::parse_from_rfc3339(ts) {
                let now = Utc::now();
                let delta = now.signed_duration_since(dt.with_timezone(&Utc));
                let secs = delta.num_seconds().max(0);
                let mins = secs / 60;
                let hours = mins / 60;
                let days = hours / 24;
                if days >= 7 {
                    // Show date for older entries
                    return dt.format("%Y-%m-%d").to_string();
                }
                if days >= 1 {
                    return format!("{}d ago", days);
                }
                if hours >= 1 {
                    return format!("{}h ago", hours);
                }
                if mins >= 1 {
                    return format!("{}m ago", mins);
                }
                return "just now".to_string();
            }
            ts.to_string()
        }

        let rows: Vec<crate::bottom_pane::resume_selection_view::ResumeRow> = candidates
            .into_iter()
            .map(|c| {
                let modified = human_ago(&c.modified_ts.unwrap_or_default());
                let created = human_ago(&c.created_ts.unwrap_or_default());
                let msgs = format!("{}", c.message_count);
                let branch = c.branch.unwrap_or_else(|| "-".to_string());
                let mut summary = c.snippet.unwrap_or_else(|| c.subtitle.unwrap_or_default());
                const SNIPPET_MAX: usize = 64;
                if summary.chars().count() > SNIPPET_MAX {
                    summary = summary.chars().take(SNIPPET_MAX).collect::<String>() + "…";
                }
                crate::bottom_pane::resume_selection_view::ResumeRow {
                    modified,
                    created,
                    msgs,
                    branch,
                    summary,
                    path: c.path,
                }
            })
            .collect();
        let title = format!("Resume Session — {}", cwd.display());
        let subtitle = Some(String::new());
        self.bottom_pane
            .show_resume_selection(title, subtitle, rows);
    }

    /// Render a single recorded ResponseItem into history without executing tools
    fn render_replay_item(&mut self, item: ResponseItem) {
        match item {
            ResponseItem::Message { id, role, content } => {
                let message_id = id;
                let mut text = String::new();
                for c in content {
                    match c {
                        ContentItem::OutputText { text: t }
                        | ContentItem::InputText { text: t } => {
                            if !text.is_empty() {
                                text.push('\n');
                            }
                            text.push_str(&t);
                        }
                        _ => {}
                    }
                }
                let text = text.trim();
                if text.is_empty() {
                    return;
                }
                if role == "user" {
                    if text.starts_with("<user_action>") {
                        return;
                    }
                    if let Some(expected) = self.pending_dispatched_user_messages.front() {
                        if expected.trim() == text {
                            self.pending_dispatched_user_messages.pop_front();
                            return;
                        }
                    }
                }
                if text.starts_with("== System Status ==") {
                    return;
            }
            if role == "assistant" {
                let normalized_new = Self::normalize_text(text);
                if let Some(last_cell) = self.history_cells.last() {
                    if let Some(existing) = last_cell
                        .as_any()
                        .downcast_ref::<crate::history_cell::AssistantMarkdownCell>()
                    {
                        let normalized_existing =
                            Self::normalize_text(existing.markdown());
                        if normalized_existing == normalized_new {
                            tracing::debug!(
                                "replay: skipping duplicate assistant message"
                            );
                            return;
                        }
                    }
                }
                let mut lines: Vec<ratatui::text::Line<'static>> = Vec::new();
                crate::markdown::append_markdown(text, &mut lines, &self.config);
                self.insert_final_answer_with_id(message_id, lines, text.to_string());
                return;
            }
                if role == "user" {
                    let key = self.next_internal_key();
                    let state = history_cell::new_user_prompt(text.to_string());
                    let _ = self.history_insert_plain_state_with_key(state, key, "epilogue");

                    if let Some(front) = self.queued_user_messages.front() {
                        if front.display_text.trim() == text.trim() {
                            self.queued_user_messages.pop_front();
                            self.refresh_queued_user_messages();
                        }
                    }
                } else {
                    let mut lines = Vec::new();
                    crate::markdown::append_markdown(text, &mut lines, &self.config);
                    let key = self.next_internal_key();
                    let state = history_cell::plain_message_state_from_lines(
                        lines,
                        history_cell::HistoryCellType::Assistant,
                    );
                    let _ = self.history_insert_plain_state_with_key(state, key, "epilogue");
                }
            }
            ResponseItem::FunctionCall { name, arguments, call_id, .. } => {
                let pretty_args = serde_json::from_str::<JsonValue>(&arguments)
                    .and_then(|v| serde_json::to_string_pretty(&v))
                    .unwrap_or_else(|_| arguments.clone());
                let mut message = format!("🔧 Tool call: {}", name);
                if !pretty_args.trim().is_empty() {
                    message.push_str("\n");
                    message.push_str(&pretty_args);
                }
                if !call_id.is_empty() {
                    message.push_str(&format!("\ncall_id: {}", call_id));
                }
                let key = self.next_internal_key();
                let _ = self.history_insert_with_key_global_tagged(
                    Box::new(crate::history_cell::new_background_event(message)),
                    key,
                    "background",
                    None,
                );
            }
            ResponseItem::Reasoning { summary, .. } => {
                for s in summary {
                    let code_protocol::models::ReasoningItemReasoningSummary::SummaryText { text } =
                        s;
                    // Reasoning cell – use the existing reasoning output styling
                    let sink = crate::streaming::controller::AppEventHistorySink(
                        self.app_event_tx.clone(),
                    );
                    streaming::begin(self, StreamKind::Reasoning, None);
                    let _ = self.stream.apply_final_reasoning(&text, &sink);
                    // finalize immediately for static replay
                    self.stream
                        .finalize(crate::streaming::StreamKind::Reasoning, true, &sink);
                }
            }
            ResponseItem::FunctionCallOutput { output, call_id, .. } => {
                let mut content = output.content.clone();
                let mut metadata_summary = String::new();
                if let Ok(v) = serde_json::from_str::<JsonValue>(&content) {
                    if let Some(s) = v.get("output").and_then(|x| x.as_str()) {
                        content = s.to_string();
                    }
                    if let Some(meta) = v.get("metadata").and_then(|m| m.as_object()) {
                        let mut parts = Vec::new();
                        if let Some(code) = meta.get("exit_code").and_then(|x| x.as_i64()) {
                            parts.push(format!("exit_code={}", code));
                        }
                        if let Some(duration) =
                            meta.get("duration_seconds").and_then(|x| x.as_f64())
                        {
                            parts.push(format!("duration={:.2}s", duration));
                        }
                        if !parts.is_empty() {
                            metadata_summary = parts.join(", ");
                        }
                    }
                }
                let mut message = String::new();
                if !content.trim().is_empty() {
                    message.push_str(content.trim_end());
                }
                if !metadata_summary.is_empty() {
                    if !message.is_empty() {
                        message.push_str("\n\n");
                    }
                    message.push_str(&format!("({})", metadata_summary));
                }
                if !call_id.is_empty() {
                    if !message.is_empty() {
                        message.push_str("\n");
                    }
                    message.push_str(&format!("call_id: {}", call_id));
                }
                if message.trim().is_empty() {
                    return;
                }
                let key = self.next_internal_key();
                let _ = self.history_insert_with_key_global_tagged(
                    Box::new(crate::history_cell::new_background_event(message)),
                    key,
                    "background",
                    None,
                );
            }
            _ => {
                // Ignore other item kinds for replay (tool calls, etc.)
            }
        }
    }

    fn render_cached_lines(
        &self,
        item: &dyn HistoryCell,
        layout: &CachedLayout,
        area: Rect,
        buf: &mut Buffer,
        skip_rows: u16,
    ) {
        if area.width == 0 || area.height == 0 {
            return;
        }

        let total = layout.lines.len() as u16;
        if skip_rows >= total {
            return;
        }

        debug_assert_eq!(layout.lines.len(), layout.rows.len());

        let cell_bg = match item.kind() {
            crate::history_cell::HistoryCellType::Assistant => crate::colors::assistant_bg(),
            _ => crate::colors::background(),
        };

        if matches!(item.kind(), crate::history_cell::HistoryCellType::Assistant) {
            let bg_style = Style::default()
                .bg(cell_bg)
                .fg(crate::colors::text());
            fill_rect(buf, area, Some(' '), bg_style);
        }

        let max_rows = area.height.min(total.saturating_sub(skip_rows));
        let buf_width = buf.area.width as usize;
        let offset_x = area.x.saturating_sub(buf.area.x) as usize;
        let offset_y = area.y.saturating_sub(buf.area.y) as usize;
        let row_width = area.width as usize;

        for (visible_offset, src_index) in (skip_rows as usize..skip_rows as usize + max_rows as usize)
            .enumerate()
        {
            let src_row = layout
                .rows
                .get(src_index)
                .map(|row| row.as_ref())
                .unwrap_or(&[]);

            let dest_y = offset_y + visible_offset;
            if dest_y >= buf.area.height as usize {
                break;
            }
            let start = dest_y * buf_width + offset_x;
            if start >= buf.content.len() {
                break;
            }
            let max_width = row_width.min(buf_width.saturating_sub(offset_x));
            let end = (start + max_width).min(buf.content.len());
            if end <= start {
                continue;
            }
            let dest_slice = &mut buf.content[start..end];

            let copy_len = src_row.len().min(dest_slice.len());
            if copy_len == dest_slice.len() {
                if copy_len > 0 {
                    dest_slice.clone_from_slice(&src_row[..copy_len]);
                }
            } else {
                for (dst, src) in dest_slice.iter_mut().zip(src_row.iter()).take(copy_len) {
                    dst.clone_from(src);
                }
                for cell in dest_slice.iter_mut().skip(copy_len) {
                    cell.reset();
                }
            }

            for cell in dest_slice.iter_mut() {
                if cell.bg == ratatui::style::Color::Reset {
                    cell.bg = cell_bg;
                }
            }
        }
    }
    /// Trigger fade on the welcome cell when the composer expands (e.g., slash popup).
    pub(crate) fn on_composer_expanded(&mut self) {
        for cell in &self.history_cells {
            cell.trigger_fade();
        }
        self.request_redraw();
    }
    /// If the user is at or near the bottom, keep following new messages.
    /// We treat "near" as within 3 rows, matching our scroll step.
    fn autoscroll_if_near_bottom(&mut self) {
        layout_scroll::autoscroll_if_near_bottom(self);
    }

    fn clear_reasoning_in_progress(&mut self) {
        let last_reasoning_index = self
            .history_cells
            .iter()
            .enumerate()
            .rev()
            .find_map(|(idx, cell)| {
                cell.as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    .map(|_| idx)
            });

        let mut changed = false;
        for (idx, cell) in self.history_cells.iter().enumerate() {
            if let Some(reasoning_cell) = cell
                .as_any()
                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            {
                if !reasoning_cell.is_in_progress() {
                    continue;
                }

                let keep_in_progress = !self.config.tui.show_reasoning
                    && Some(idx) == last_reasoning_index
                    && reasoning_cell.is_collapsed()
                    && !reasoning_cell.collapsed_has_summary();

                if keep_in_progress {
                    continue;
                }

                reasoning_cell.set_in_progress(false);
                changed = true;
            }
        }

        if changed {
            self.invalidate_height_cache();
        }
    }

    fn is_reasoning_anchor(cell: &Box<dyn history_cell::HistoryCell>) -> bool {
        cell
            .as_any()
            .downcast_ref::<history_cell::ExploreAggregationCell>()
            .is_some()
            || cell
                .as_any()
                .downcast_ref::<history_cell::AgentRunCell>()
                .is_some()
    }

    fn reasoning_preview(lines: &[Line<'static>]) -> String {
        const MAX_LINES: usize = 3;
        const MAX_CHARS: usize = 120;
        let mut previews: Vec<String> = Vec::new();
        for line in lines.iter().take(MAX_LINES) {
            let mut text = String::new();
            for span in &line.spans {
                text.push_str(span.content.as_ref());
            }
            if text.chars().count() > MAX_CHARS {
                let mut truncated: String = text.chars().take(MAX_CHARS).collect();
                truncated.push('…');
                previews.push(truncated);
            } else {
                previews.push(text);
            }
        }
        if previews.is_empty() {
            String::new()
        } else {
            previews.join(" ⏐ ")
        }
    }

    fn refresh_reasoning_collapsed_visibility(&mut self) {
        let show = self.config.tui.show_reasoning;
        let mut needs_invalidate = false;
        if show {
            for cell in &self.history_cells {
                if let Some(reasoning_cell) = cell
                    .as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                {
                    if reasoning_cell.set_hide_when_collapsed(false) {
                        needs_invalidate = true;
                    }
                }
            }
        } else {
            use std::collections::HashSet;
            let mut hide_indices: HashSet<usize> = HashSet::new();
            let len = self.history_cells.len();
            let mut idx = 0usize;
            while idx < len {
                if !Self::is_reasoning_anchor(&self.history_cells[idx]) {
                    idx += 1;
                    continue;
                }
                let mut reasoning_indices: Vec<usize> = Vec::new();
                let mut j = idx + 1;
                while j < len {
                    let cell = &self.history_cells[j];

                    if cell.should_remove() {
                        j += 1;
                        continue;
                    }

                    if cell
                        .as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                        .is_some()
                    {
                        reasoning_indices.push(j);
                        j += 1;
                        continue;
                    }

                    match cell.kind() {
                        history_cell::HistoryCellType::PlanUpdate
                        | history_cell::HistoryCellType::Loading => {
                            j += 1;
                            continue;
                        }
                        _ => {}
                    }

                    if cell
                        .as_any()
                        .downcast_ref::<history_cell::WaitStatusCell>()
                        .is_some()
                    {
                        j += 1;
                        continue;
                    }

                    if cell.display_lines_trimmed().is_empty() {
                        j += 1;
                        continue;
                    }

                    break;
                }
                if reasoning_indices.len() > 1 {
                    for &ri in &reasoning_indices[..reasoning_indices.len() - 1] {
                        hide_indices.insert(ri);
                    }
                }
                idx = j;
            }

            for (i, cell) in self.history_cells.iter().enumerate() {
                if let Some(reasoning_cell) = cell
                    .as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                {
                    if hide_indices.contains(&i) {
                        if reasoning_cell.set_hide_when_collapsed(true) {
                            needs_invalidate = true;
                        }
                    } else if reasoning_cell.set_hide_when_collapsed(false) {
                        needs_invalidate = true;
                    }
                }
            }
        }

        if needs_invalidate {
            self.invalidate_height_cache();
            self.request_redraw();
        }

        self.refresh_explore_trailing_flags();
    }

    /// Handle streaming delta for both answer and reasoning
    // Legacy helper removed: streaming now requires explicit sequence numbers.
    // Call sites should invoke `streaming::delta_text(self, kind, id, delta, seq)` directly.

    /// Defer or handle an interrupt based on whether we're streaming
    fn defer_or_handle<F1, F2>(&mut self, defer_fn: F1, handle_fn: F2)
    where
        F1: FnOnce(&mut interrupts::InterruptManager),
        F2: FnOnce(&mut Self),
    {
        if self.is_write_cycle_active() {
            defer_fn(&mut self.interrupts);
        } else {
            handle_fn(self);
        }
    }

    // removed: next_sequence; plan updates are inserted immediately

    // Removed order-adjustment helpers; ordering now uses stable order keys on insert.

    /// Mark that the widget needs to be redrawn
    fn mark_needs_redraw(&mut self) {
        // Clean up fully faded cells before redraw. If any are removed,
        // invalidate the height cache since indices shift and our cache is
        // keyed by (idx,width).
        let before_len = self.history_cells.len();
        if before_len > 0 {
            let old_cells = std::mem::take(&mut self.history_cells);
            let old_ids = std::mem::take(&mut self.history_cell_ids);
            debug_assert_eq!(
                old_cells.len(),
                old_ids.len(),
                "history ids out of sync with cells"
            );
            let mut removed_any = false;
            let mut kept_cells = Vec::with_capacity(old_cells.len());
            let mut kept_ids = Vec::with_capacity(old_ids.len());
            for (cell, id) in old_cells.into_iter().zip(old_ids.into_iter()) {
                if cell.should_remove() {
                    removed_any = true;
                    continue;
                }
                kept_ids.push(id);
                kept_cells.push(cell);
            }
            self.history_cells = kept_cells;
            self.history_cell_ids = kept_ids;
            if removed_any {
                self.invalidate_height_cache();
            }
        } else if !self.history_cell_ids.is_empty() {
            self.history_cell_ids.clear();
        }

        // Send a redraw event to trigger UI update
        self.app_event_tx.send(AppEvent::RequestRedraw);
    }

    /// Clear memoized cell heights (called when history/content changes)
    fn invalidate_height_cache(&mut self) {
        self.history_render.invalidate_height_cache();
    }

    fn fallback_lines_for_record(
        &self,
        cell: &dyn HistoryCell,
        record: &HistoryRecord,
    ) -> Option<Vec<Line<'static>>> {
        if cell.has_custom_render() {
            return None;
        }

        let lines = cell.display_lines_trimmed();
        if !lines.is_empty() || matches!(record, HistoryRecord::Reasoning(_)) {
            Some(lines)
        } else {
            Some(history_cell::lines_from_record(record, &self.config))
        }
    }
    /// Handle exec approval request immediately
    fn handle_exec_approval_now(&mut self, _id: String, ev: ExecApprovalRequestEvent) {
        // Use call_id as the approval correlation id so responses map to the
        // exact pending approval in core (supports multiple approvals per turn).
        let approval_id = ev.call_id.clone();
        let ticket = self.make_background_before_next_output_ticket();
        self.bottom_pane
            .push_approval_request(ApprovalRequest::Exec {
                id: approval_id,
                command: ev.command,
                reason: ev.reason,
            }, ticket);
    }

    /// Handle apply patch approval request immediately
    fn handle_apply_patch_approval_now(&mut self, _id: String, ev: ApplyPatchApprovalRequestEvent) {
        let ApplyPatchApprovalRequestEvent {
            call_id,
            changes,
            reason,
            grant_root,
        } = ev;

        // Clone for session storage before moving into history
        let changes_clone = changes.clone();
        // Surface the patch summary in the main conversation
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global(
            Box::new(history_cell::new_patch_event(
                history_cell::PatchEventType::ApprovalRequest,
                changes,
            )),
            key,
        );
        // Record change set for session diff popup (latest last)
        self.diffs.session_patch_sets.push(changes_clone);
        // For any new paths, capture an original baseline snapshot the first time we see them
        if let Some(last) = self.diffs.session_patch_sets.last() {
            for (src_path, chg) in last.iter() {
                match chg {
                    code_core::protocol::FileChange::Update {
                        move_path: Some(dest_path),
                        ..
                    } => {
                        if let Some(baseline) =
                            self.diffs.baseline_file_contents.get(src_path).cloned()
                        {
                            // Mirror baseline under destination so tabs use the new path
                            self.diffs
                                .baseline_file_contents
                                .entry(dest_path.clone())
                                .or_insert(baseline);
                        } else if !self.diffs.baseline_file_contents.contains_key(dest_path) {
                            // Snapshot from source (pre-apply)
                            let baseline = std::fs::read_to_string(src_path).unwrap_or_default();
                            self.diffs
                                .baseline_file_contents
                                .insert(dest_path.clone(), baseline);
                        }
                    }
                    _ => {
                        if !self.diffs.baseline_file_contents.contains_key(src_path) {
                            let baseline = std::fs::read_to_string(src_path).unwrap_or_default();
                            self.diffs
                                .baseline_file_contents
                                .insert(src_path.clone(), baseline);
                        }
                    }
                }
            }
        }
        // Enable Ctrl+D footer hint now that we have diffs to show
        self.bottom_pane.set_diffs_hint(true);

        // Push the approval request to the bottom pane, keyed by call_id
        let request = ApprovalRequest::ApplyPatch {
            id: call_id,
            reason,
            grant_root,
        };
        let ticket = self.make_background_before_next_output_ticket();
        self.bottom_pane.push_approval_request(request, ticket);
    }

    /// Handle exec command begin immediately
    fn handle_exec_begin_now(
        &mut self,
        ev: ExecCommandBeginEvent,
        order: &code_core::protocol::OrderMeta,
    ) {
        exec_tools::handle_exec_begin_now(self, ev, order);
    }

    /// Handle exec command end immediately
    fn handle_exec_end_now(
        &mut self,
        ev: ExecCommandEndEvent,
        order: &code_core::protocol::OrderMeta,
    ) {
        exec_tools::handle_exec_end_now(self, ev, order);
    }

    fn build_patch_failure_metadata(stdout: &str, stderr: &str) -> PatchFailureMetadata {
        fn sanitize(text: &str) -> String {
            let normalized = history_cell::normalize_overwrite_sequences(text);
            sanitize_for_tui(
                &normalized,
                SanitizeMode::AnsiPreserving,
                SanitizeOptions {
                    expand_tabs: true,
                    tabstop: 4,
                    debug_markers: false,
                },
            )
        }

        fn excerpt(input: &str) -> Option<String> {
            let trimmed = input.trim();
            if trimmed.is_empty() {
                return None;
            }
            const MAX_CHARS: usize = 2_000;
            const MAX_LINES: usize = 20;
            let mut excerpt = String::new();
            let mut remaining = MAX_CHARS;
            for (idx, line) in trimmed.lines().enumerate() {
                if idx >= MAX_LINES || remaining == 0 {
                    break;
                }
                let line = line.trim_end_matches('\r');
                let mut line_chars = line.chars();
                let mut chunk = String::new();
                while remaining > 0 {
                    if let Some(ch) = line_chars.next() {
                        let width = ch.len_utf8();
                        if width > remaining {
                            break;
                        }
                        chunk.push(ch);
                        remaining -= width;
                    } else {
                        break;
                    }
                }
                if chunk.len() < line.len() {
                    chunk.push('…');
                    remaining = 0;
                }
                if !excerpt.is_empty() {
                    excerpt.push('\n');
                }
                excerpt.push_str(&chunk);
                if remaining == 0 {
                    break;
                }
            }
            Some(excerpt)
        }

        let sanitized_stdout = sanitize(stdout);
        let sanitized_stderr = sanitize(stderr);
        let message = sanitized_stderr
            .lines()
            .map(str::trim)
            .find(|line| !line.is_empty())
            .map(|line| line.to_string())
            .unwrap_or_else(|| "Patch application failed".to_string());

        PatchFailureMetadata {
            message,
            stdout_excerpt: excerpt(&sanitized_stdout),
            stderr_excerpt: excerpt(&sanitized_stderr),
        }
    }

    /// If a completed exec cell sits at `idx`, attempt to merge it into the
    /// previous cell when they represent the same action header (e.g., Search, Read).

    // MCP tool call handlers now live in chatwidget::tools

    /// Handle patch apply end immediately
    fn handle_patch_apply_end_now(&mut self, ev: PatchApplyEndEvent) {
        if ev.success {
            if let Some(idx) = self.history_cells.iter().rposition(|cell| {
                matches!(
                    cell.kind(),
                    crate::history_cell::HistoryCellType::Patch {
                        kind: crate::history_cell::PatchKind::ApplyBegin
                    } | crate::history_cell::HistoryCellType::Patch {
                        kind: crate::history_cell::PatchKind::Proposed
                    }
                )
            }) {
                if let Some(record) = self
                    .history_cells
                    .get(idx)
                    .and_then(|existing| history_cell::record_from_cell(existing.as_ref()))
                {
                    if let HistoryRecord::Patch(mut patch_record) = record {
                        patch_record.patch_type = HistoryPatchEventType::ApplySuccess;
                        let record_index = self
                            .record_index_for_cell(idx)
                            .unwrap_or_else(|| self.record_index_for_position(idx));
                        let mutation = self
                            .history_state
                            .apply_domain_event(HistoryDomainEvent::Replace {
                                index: record_index,
                                record: HistoryDomainRecord::Patch(patch_record.clone()),
                            });
                        if let Some(id) = self.apply_mutation_to_cell_index(idx, mutation) {
                            if idx < self.history_cell_ids.len() {
                                self.history_cell_ids[idx] = Some(id);
                            }
                            self.maybe_hide_spinner();
                            return;
                        }
                    }
                }
            }
            self.maybe_hide_spinner();
            return;
        }

        let failure_meta = Self::build_patch_failure_metadata(&ev.stdout, &ev.stderr);
        if let Some(idx) = self.history_cells.iter().rposition(|cell| {
            matches!(
                cell.kind(),
                crate::history_cell::HistoryCellType::Patch {
                    kind: crate::history_cell::PatchKind::ApplyBegin
                } | crate::history_cell::HistoryCellType::Patch {
                    kind: crate::history_cell::PatchKind::Proposed
                }
            )
        }) {
            if let Some(record) = self
                .history_cells
                .get(idx)
                .and_then(|existing| history_cell::record_from_cell(existing.as_ref()))
            {
                if let HistoryRecord::Patch(mut patch_record) = record {
                    patch_record.patch_type = HistoryPatchEventType::ApplyFailure;
                    patch_record.failure = Some(failure_meta.clone());
                    let record_index = self
                        .record_index_for_cell(idx)
                        .unwrap_or_else(|| self.record_index_for_position(idx));
                    let mutation = self
                        .history_state
                        .apply_domain_event(HistoryDomainEvent::Replace {
                            index: record_index,
                            record: HistoryDomainRecord::Patch(patch_record.clone()),
                        });
                    if let Some(_id) = self.apply_mutation_to_cell_index(idx, mutation) {
                        self.maybe_hide_spinner();
                        return;
                    }
                }
            }
        }

        let record = PatchRecord {
            id: HistoryId::ZERO,
            patch_type: HistoryPatchEventType::ApplyFailure,
            changes: HashMap::new(),
            failure: Some(failure_meta),
        };
        let cell = history_cell::PatchSummaryCell::from_record(record.clone());
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global_tagged(
            Box::new(cell),
            key,
            "patch-failure",
            Some(HistoryDomainRecord::Patch(record)),
        );
        self.maybe_hide_spinner();
    }

    /// Get or create the global browser manager
    async fn get_browser_manager() -> Arc<BrowserManager> {
        code_browser::global::get_or_create_browser_manager().await
    }

    pub(crate) fn insert_str(&mut self, s: &str) {
        if self.auto_state.should_show_goal_entry()
            && matches!(self.auto_goal_escape_state, AutoGoalEscState::Inactive)
            && !s.trim().is_empty()
        {
            self.auto_goal_escape_state = AutoGoalEscState::NeedsEnableEditing;
        }
        self.bottom_pane.insert_str(s);
    }

    // Removed: pending insert sequencing is not used under strict ordering.

    pub(crate) fn register_pasted_image(&mut self, placeholder: String, path: std::path::PathBuf) {
        self.pending_images.insert(placeholder, path);
        self.request_redraw();
    }

    fn parse_message_with_images(&mut self, text: String) -> UserMessage {
        use std::path::Path;

        // Common image extensions
        const IMAGE_EXTENSIONS: &[&str] = &[
            ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".svg", ".ico", ".tiff", ".tif",
        ];
        // We keep a visible copy of the original (normalized) text for history
        let mut display_text = text.clone();
        let mut ordered_items: Vec<InputItem> = Vec::new();

        // First, handle [image: ...] placeholders from drag-and-drop
        let placeholder_regex = regex_lite::Regex::new(r"\[image: [^\]]+\]").unwrap();
        let mut cursor = 0usize;
        for mat in placeholder_regex.find_iter(&text) {
            // Push preceding text as a text item (if any)
            if mat.start() > cursor {
                let chunk = &text[cursor..mat.start()];
                if !chunk.trim().is_empty() {
                    ordered_items.push(InputItem::Text {
                        text: chunk.to_string(),
                    });
                }
            }

            let placeholder = mat.as_str();
            if placeholder.starts_with("[image:") {
                if let Some(path) = self.pending_images.remove(placeholder) {
                    // Emit a small marker followed by the image so the LLM sees placement
                    let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("image");
                    let marker = format!("[image: {}]", filename);
                    ordered_items.push(InputItem::Text { text: marker });
                    ordered_items.push(InputItem::LocalImage { path });
                } else {
                    // Unknown placeholder: preserve as text
                    ordered_items.push(InputItem::Text {
                        text: placeholder.to_string(),
                    });
                }
            } else {
                // Unknown placeholder type; preserve
                ordered_items.push(InputItem::Text {
                    text: placeholder.to_string(),
                });
            }
            cursor = mat.end();
        }
        // Push any remaining trailing text
        if cursor < text.len() {
            let chunk = &text[cursor..];
            if !chunk.trim().is_empty() {
                ordered_items.push(InputItem::Text {
                    text: chunk.to_string(),
                });
            }
        }

        // Then check for direct file paths typed into the message (no placeholder).
        // We conservatively append these at the end to avoid mis-ordering text.
        // This keeps the behavior consistent while still including the image.
        // We do NOT strip them from display_text so the user sees what they typed.
        let words: Vec<String> = text.split_whitespace().map(String::from).collect();
        for word in &words {
            if word.starts_with("[image:") {
                continue;
            }
            let is_image_path = IMAGE_EXTENSIONS
                .iter()
                .any(|ext| word.to_lowercase().ends_with(ext));
            if !is_image_path {
                continue;
            }
            let path = Path::new(word);
            if path.exists() {
                // Add a marker then the image so the LLM has contextual placement info
                let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("image");
                ordered_items.push(InputItem::Text {
                    text: format!("[image: {}]", filename),
                });
                ordered_items.push(InputItem::LocalImage {
                    path: path.to_path_buf(),
                });
            }
        }

        // Non-image paths are left as-is in the text; the model may choose to read them.

        // Preserve user formatting (retain newlines) but normalize whitespace:
        // - Normalize CRLF -> LF
        // - Trim trailing spaces per line
        // - Remove any completely blank lines at the start and end
        display_text = display_text.replace("\r\n", "\n");
        let mut _lines_tmp: Vec<String> = display_text
            .lines()
            .map(|l| l.trim_end().to_string())
            .collect();
        while _lines_tmp.first().map_or(false, |s| s.trim().is_empty()) {
            _lines_tmp.remove(0);
        }
        while _lines_tmp.last().map_or(false, |s| s.trim().is_empty()) {
            _lines_tmp.pop();
        }
        display_text = _lines_tmp.join("\n");

        UserMessage {
            display_text,
            ordered_items,
            suppress_persistence: false,
        }
    }

    /// Periodic tick to commit at most one queued line to history,
    /// animating the output.
    pub(crate) fn on_commit_tick(&mut self) {
        streaming::on_commit_tick(self);
    }
    fn is_write_cycle_active(&self) -> bool {
        streaming::is_write_cycle_active(self)
    }

    fn flush_interrupt_queue(&mut self) {
        let mut mgr = std::mem::take(&mut self.interrupts);
        mgr.flush_all(self);
        self.interrupts = mgr;
    }

    fn on_error(&mut self, message: String) {
        // Treat transient stream errors (which the core will retry) differently
        // from fatal errors so the status spinner remains visible while we wait.
        let lower = message.to_lowercase();
        let is_transient = lower.contains("retrying")
            || lower.contains("stream disconnected")
            || lower.contains("stream error")
            || lower.contains("stream closed")
            || lower.contains("timeout")
            || lower.contains("temporar");

        if is_transient {
            // Keep task running and surface a concise status in the input header.
            self.bottom_pane.set_task_running(true);
            self.bottom_pane.update_status_text(message.clone());
            // Add a dim background event instead of a hard error cell to avoid
            // alarming users during auto-retries.
            self.push_background_tail(message);
            // Do NOT clear running state or streams; the retry will resume them.
            self.request_redraw();
            return;
        }

        // Fatal error path: show an error cell and clear running state.
        self.clear_resume_placeholder();
        let key = self.next_internal_key();
        let state = history_cell::new_error_event(message.clone());
        let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
        let _ = self.history_insert_with_key_global_tagged(
            Box::new(cell),
            key,
            "epilogue",
            Some(HistoryDomainRecord::Plain(state)),
        );
        self.bottom_pane.set_task_running(false);
        self.exec.running_commands.clear();
        self.stream.clear_all();
        self.stream_state.drop_streaming = false;
        self.agents_ready_to_start = false;
        self.active_task_ids.clear();
        self.maybe_hide_spinner();
        self.mark_needs_redraw();
    }

    fn interrupt_running_task(&mut self) {
        let bottom_running = self.bottom_pane.is_task_running();
        let exec_related_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty();

        if !(bottom_running || exec_related_running) {
            return;
        }

        let mut has_wait_running = false;
        for (call_id, entry) in self.tools_state.running_custom_tools.iter() {
            if let Some(idx) = running_tools::resolve_entry_index(self, entry, &call_id.0)
            {
                if let Some(cell) = self.history_cells.get(idx).and_then(|c| c
                    .as_any()
                    .downcast_ref::<history_cell::RunningToolCallCell>())
                {
                    if cell.has_title("Waiting") {
                        has_wait_running = true;
                        break;
                    }
                }
            }
        }

        self.active_exec_cell = None;
        // Finalize any visible running indicators as interrupted (Exec/Web/Custom)
        self.finalize_all_running_as_interrupted();
        if bottom_running {
            self.bottom_pane.clear_ctrl_c_quit_hint();
        }
        // Stop any active UI streams immediately so output ceases at once.
        self.finalize_active_stream();
        self.stream_state.drop_streaming = true;
        // Surface an explicit notice in history so users see confirmation.
        if !has_wait_running {
            self.push_background_tail("Cancelled by user.".to_string());
        }
        self.submit_op(Op::Interrupt);
        // Immediately drop the running status so the next message can be typed/run,
        // even if backend cleanup (and Error event) arrives slightly later.
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.clear_live_ring();
        // Reset with max width to disable wrapping
        self.live_builder = RowBuilder::new(usize::MAX);
        // Stream state is now managed by StreamController
        self.content_buffer.clear();
        // Defensive: clear transient flags so UI can quiesce
        self.agents_ready_to_start = false;
        self.active_task_ids.clear();
        // Restore any queued messages back into the composer so the user can
        // immediately press Enter to resume the conversation where they left off.
        if !self.queued_user_messages.is_empty() {
            let existing_input = self.bottom_pane.composer_text();
            let mut segments: Vec<String> = Vec::new();

            let mut queued_block = String::new();
            for (i, qm) in self.queued_user_messages.iter().enumerate() {
                if i > 0 {
                    queued_block.push_str("\n\n");
                }
                queued_block.push_str(qm.display_text.trim_end());
            }
            if !queued_block.trim().is_empty() {
                segments.push(queued_block);
            }

            if !existing_input.trim().is_empty() {
                segments.push(existing_input);
            }

            let combined = segments.join("\n\n");
            self.clear_composer();
            if !combined.is_empty() {
                self.insert_str(&combined);
            }
            self.queued_user_messages.clear();
            self.bottom_pane.update_status_text(String::new());
            self.pending_dispatched_user_messages.clear();
            self.refresh_queued_user_messages();
        }
        self.maybe_hide_spinner();
        self.request_redraw();
    }
    fn layout_areas(&self, area: Rect) -> Vec<Rect> {
        layout_scroll::layout_areas(self, area)
    }
    fn finalize_active_stream(&mut self) {
        streaming::finalize_active_stream(self);
    }
    // Strict stream order key helpers
    fn seed_stream_order_key(&mut self, kind: StreamKind, id: &str, key: OrderKey) {
        self.stream_order_seq.insert((kind, id.to_string()), key);
    }
    // Try to fetch a seeded stream order key. Callers must handle None.
    fn try_stream_order_key(&self, kind: StreamKind, id: &str) -> Option<OrderKey> {
        self.stream_order_seq.get(&(kind, id.to_string())).copied()
    }
    pub(crate) fn new(
        mut config: Config,
        app_event_tx: AppEventSender,
        initial_prompt: Option<String>,
        initial_images: Vec<PathBuf>,
        enhanced_keys_supported: bool,
        terminal_info: crate::tui::TerminalInfo,
        show_order_overlay: bool,
        latest_upgrade_version: Option<String>,
    ) -> Self {
        let mapped_theme = crate::theme::map_theme_for_palette(
            config.tui.theme.name,
            config.tui.theme.is_dark,
        );
        config.tui.theme.name = mapped_theme;

        let (code_op_tx, code_op_rx) = unbounded_channel::<Op>();

        let auth_manager = AuthManager::shared_with_mode_and_originator(
            config.code_home.clone(),
            AuthMode::ApiKey,
            config.responses_originator_header.clone(),
        );

        // Browser manager is now handled through the global state
        // The core session will use the same global manager when browser tools are invoked

        // Add initial animated welcome message to history (top of first request)
        let history_cells: Vec<Box<dyn HistoryCell>> = Vec::new();
        // Insert later via history_push_top_next_req once struct is constructed

        // Removed the legacy startup tip for /resume.

        // Initialize image protocol for rendering screenshots

        let auto_drive_variant = AutoDriveVariant::from_env();

        let bottom_pane = BottomPane::new(BottomPaneParams {
            app_event_tx: app_event_tx.clone(),
            has_input_focus: true,
            enhanced_keys_supported,
            using_chatgpt_auth: config.using_chatgpt_auth,
            auto_drive_variant,
        });

        let mut new_widget = Self {
            app_event_tx: app_event_tx.clone(),
            code_op_tx,
            bottom_pane,
            auth_manager: auth_manager.clone(),
            login_view_state: None,
            login_add_view_state: None,
            active_exec_cell: None,
            history_cells,
            config: config.clone(),
            history_debug_events: if history_cell_logging_enabled() {
                Some(RefCell::new(Vec::new()))
            } else {
                None
            },
            latest_upgrade_version: latest_upgrade_version.clone(),
            initial_user_message: create_initial_user_message(
                initial_prompt.unwrap_or_default(),
                initial_images,
            ),
            total_token_usage: TokenUsage::default(),
            last_token_usage: TokenUsage::default(),
            rate_limit_snapshot: None,
            rate_limit_warnings: RateLimitWarningState::default(),
            rate_limit_fetch_inflight: false,
            rate_limit_last_fetch_at: None,
            rate_limit_primary_next_reset_at: None,
            rate_limit_secondary_next_reset_at: None,
            content_buffer: String::new(),
            last_assistant_message: None,
            exec: ExecState {
                running_commands: HashMap::new(),
                running_explore_agg_index: None,
                pending_exec_ends: HashMap::new(),
                suppressed_exec_end_call_ids: HashSet::new(),
                suppressed_exec_end_order: VecDeque::new(),
            },
            canceled_exec_call_ids: HashSet::new(),
            tools_state: ToolState::default(),
            // Use max width to disable wrapping during streaming
            // Text will be properly wrapped when displayed based on terminal width
            live_builder: RowBuilder::new(usize::MAX),
            header_wave: {
                let effect = HeaderWaveEffect::new();
                if ENABLE_WARP_STRIPES {
                    effect.set_enabled(true, Instant::now());
                } else {
                    effect.set_enabled(false, Instant::now());
                }
                effect
            },
            browser_overlay_visible: false,
            browser_overlay_state: BrowserOverlayState::default(),
            pending_images: HashMap::new(),
            welcome_shown: false,
            latest_browser_screenshot: Arc::new(Mutex::new(None)),
            browser_autofix_requested: Arc::new(AtomicBool::new(false)),
            cached_image_protocol: RefCell::new(None),
            cached_picker: RefCell::new(terminal_info.picker.clone()),
            cached_cell_size: std::cell::OnceCell::new(),
            git_branch_cache: RefCell::new(GitBranchCache::default()),
            terminal_info,
            active_agents: Vec::new(),
            agents_ready_to_start: false,
            last_agent_prompt: None,
            agent_context: None,
            agent_task: None,
            recent_agent_hint: None,
            suppress_next_agent_hint: false,
            active_review_hint: None,
            active_review_prompt: None,
            auto_resolve_state: None,
            pending_turn_descriptor: None,
            pending_auto_turn_config: None,
            pending_review_commit: None,
            auto_review_cleanup: None,
            auto_review_pending: false,
            overall_task_status: "preparing".to_string(),
            active_plan_title: None,
            agent_runtime: HashMap::new(),
            sparkline_data: std::cell::RefCell::new(Vec::new()),
            last_sparkline_update: std::cell::RefCell::new(std::time::Instant::now()),
            stream: crate::streaming::controller::StreamController::new(config.clone()),
            stream_state: StreamState {
                current_kind: None,
                closed_answer_ids: HashSet::new(),
                closed_reasoning_ids: HashSet::new(),
                seq_answer_final: None,
                drop_streaming: false,
            },
            interrupts: interrupts::InterruptManager::new(),
            ended_call_ids: HashSet::new(),
            diffs: DiffsState {
                session_patch_sets: Vec::new(),
                baseline_file_contents: HashMap::new(),
                overlay: None,
                confirm: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            help: HelpState {
                overlay: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            settings: SettingsState::default(),
            limits: LimitsState::default(),
            terminal: TerminalState::default(),
            pending_manual_terminal: HashMap::new(),
            agents_overview_selected_index: 0,
            agents_terminal: AgentsTerminalState::new(),
            pending_upgrade_notice: None,
            history_render: HistoryRenderState::new(),
            render_theme_epoch: 0,
            history_state: HistoryState::new(),
            history_snapshot_dirty: false,
            history_snapshot_last_flush: None,
            history_cell_ids: Vec::new(),
            height_manager: RefCell::new(HeightManager::new(
                crate::height_manager::HeightManagerConfig::default(),
            )),
            layout: LayoutState {
                scroll_offset: 0,
                last_max_scroll: std::cell::Cell::new(0),
                last_history_viewport_height: std::cell::Cell::new(0),
                vertical_scrollbar_state: std::cell::RefCell::new(ScrollbarState::default()),
                scrollbar_visible_until: std::cell::Cell::new(None),
                last_bottom_reserved_rows: std::cell::Cell::new(0),
                last_frame_height: std::cell::Cell::new(0),
                last_frame_width: std::cell::Cell::new(0),
            },
            last_theme: crate::theme::current_theme(),
            perf_state: PerfState {
                enabled: false,
                stats: RefCell::new(PerfStats::default()),
                pending_scroll_rows: Cell::new(0),
            },
            session_id: None,
            active_task_ids: HashSet::new(),
            queued_user_messages: std::collections::VecDeque::new(),
            pending_dispatched_user_messages: std::collections::VecDeque::new(),
            pending_user_prompts_for_next_turn: 0,
            ghost_snapshots: Vec::new(),
            ghost_snapshots_disabled: false,
            ghost_snapshots_disabled_reason: None,
            ghost_snapshot_queue: VecDeque::new(),
            active_ghost_snapshot: None,
            next_ghost_snapshot_id: 0,
            pending_snapshot_dispatches: VecDeque::new(),
            auto_drive_card_sequence: 0,
            auto_drive_variant,
            auto_state: AutoDriveController::default(),
            auto_goal_escape_state: AutoGoalEscState::Inactive,
            auto_handle: None,
            auto_history: AutoDriveHistory::new(),
            auto_turn_review_state: None,
            auto_pending_goal_request: false,
            auto_goal_bootstrap_done: false,
            cloud_tasks_selected_env: None,
            cloud_tasks_environments: Vec::new(),
            cloud_tasks_last_tasks: Vec::new(),
            cloud_tasks_best_of_n: 1,
            cloud_tasks_creation_inflight: false,
            cloud_task_apply_tickets: HashMap::new(),
            cloud_task_create_ticket: None,
            browser_is_external: false,
            next_cli_text_format: None,
            // Stable ordering & routing init
            cell_order_seq: vec![OrderKey {
                req: 0,
                out: -1,
                seq: 0,
            }],
            cell_order_dbg: vec![None; 1],
            reasoning_index: HashMap::new(),
            stream_order_seq: HashMap::new(),
            order_request_bias: 0,
            resume_expected_next_request: None,
            resume_provider_baseline: None,
            last_seen_request_index: 0,
            current_request_index: 0,
            internal_seq: 0,
            show_order_overlay,
            scroll_history_hint_shown: false,
            access_status_idx: None,
            pending_agent_notes: Vec::new(),
            synthetic_system_req: None,
            system_cell_by_id: HashMap::new(),
            ui_background_seq_counters: HashMap::new(),
            last_assigned_order: None,
            standard_terminal_mode: !config.tui.alternate_screen,
            replay_history_depth: 0,
            resume_placeholder_visible: false,
        };
        new_widget.spawn_conversation_runtime(config.clone(), auth_manager.clone(), code_op_rx);
        if let Ok(Some(active_id)) = auth_accounts::get_active_account_id(&config.code_home) {
            if let Ok(records) = account_usage::list_rate_limit_snapshots(&config.code_home) {
                if let Some(record) = records.into_iter().find(|r| r.account_id == active_id) {
                    new_widget.rate_limit_primary_next_reset_at = record.primary_next_reset_at;
                    new_widget.rate_limit_secondary_next_reset_at = record.secondary_next_reset_at;
                }
            }
        }
        // Seed footer access indicator based on current config
        new_widget.apply_access_mode_indicator_from_config();
        // Insert the welcome cell as top-of-first-request so future model output
        // appears below it. Also insert the Popular commands immediately so users
        // don't wait for MCP initialization to finish.
        let mut w = new_widget;
        let auto_defaults = w.config.auto_drive.clone();
        w.auto_state.review_enabled = auto_defaults.review_enabled;
        w.auto_state.subagents_enabled = auto_defaults.agents_enabled;
        w.auto_state.cross_check_enabled = auto_defaults.cross_check_enabled;
        w.auto_state.qa_automation_enabled = auto_defaults.qa_automation_enabled;
        w.auto_state.continue_mode = auto_continue_from_config(auto_defaults.continue_mode);
        w.auto_state.reset_countdown();
        w.auto_goal_escape_state = AutoGoalEscState::Inactive;
        w.set_standard_terminal_mode(!config.tui.alternate_screen);
        if config.experimental_resume.is_none() {
            w.history_push_top_next_req(history_cell::new_animated_welcome()); // tag: prelude
            let connecting_mcp = !w.config.mcp_servers.is_empty();
            if !w.config.auto_upgrade_enabled {
                if let Some(upgrade_cell) =
                    history_cell::new_upgrade_prelude(w.latest_upgrade_version.as_deref())
                {
                    w.history_push_top_next_req(upgrade_cell);
                }
            }
            let notice_state = history_cell::new_popular_commands_notice(
                false,
                w.latest_upgrade_version.as_deref(),
            );
            let notice_key = w.next_req_key_top();
            let _ = w.history_insert_plain_state_with_key(notice_state, notice_key, "prelude");
            if connecting_mcp {
                // Render connecting status as a separate cell with standard gutter and spacing
                w.history_push_top_next_req(history_cell::new_connecting_mcp_status());
            }
            // Mark welcome as shown to avoid duplicating the Popular commands section
            // when SessionConfigured arrives shortly after.
            w.welcome_shown = true;
        } else {
            w.welcome_shown = true;
            w.insert_resume_placeholder();
        }
        w.maybe_start_auto_upgrade_task();
        w
    }

    /// Construct a ChatWidget from an existing conversation (forked session).
    pub(crate) fn new_from_existing(
        config: Config,
        conversation: std::sync::Arc<code_core::CodexConversation>,
        session_configured: SessionConfiguredEvent,
        app_event_tx: AppEventSender,
        enhanced_keys_supported: bool,
        terminal_info: crate::tui::TerminalInfo,
        show_order_overlay: bool,
        latest_upgrade_version: Option<String>,
        auth_manager: Arc<AuthManager>,
        show_welcome: bool,
    ) -> Self {
        let (code_op_tx, mut code_op_rx) = unbounded_channel::<Op>();

        let auto_drive_variant = AutoDriveVariant::from_env();

        // Forward events from existing conversation
        let app_event_tx_clone = app_event_tx.clone();
        tokio::spawn(async move {
            // Send the provided SessionConfigured to the UI first
            let event = Event {
                id: "fork".to_string(),
                event_seq: 0,
                msg: EventMsg::SessionConfigured(session_configured),
                order: None,
            };
            app_event_tx_clone.send(AppEvent::CodexEvent(event));

            let conversation_clone = conversation.clone();
            tokio::spawn(async move {
                while let Some(op) = code_op_rx.recv().await {
                    let id = conversation_clone.submit(op).await;
                    if let Err(e) = id {
                        tracing::error!("failed to submit op: {e}");
                    }
                }
            });

            while let Ok(event) = conversation.next_event().await {
                app_event_tx_clone.send(AppEvent::CodexEvent(event));
            }
        });

        // Basic widget state mirrors `new`
        let history_cells: Vec<Box<dyn HistoryCell>> = Vec::new();

        let bottom_pane = BottomPane::new(BottomPaneParams {
            app_event_tx: app_event_tx.clone(),
            has_input_focus: true,
            enhanced_keys_supported,
            using_chatgpt_auth: config.using_chatgpt_auth,
            auto_drive_variant,
        });

        let mut w = Self {
            app_event_tx: app_event_tx.clone(),
            code_op_tx,
            bottom_pane,
            auth_manager: auth_manager.clone(),
            login_view_state: None,
            login_add_view_state: None,
            active_exec_cell: None,
            history_cells,
            config: config.clone(),
            history_debug_events: if history_cell_logging_enabled() {
                Some(RefCell::new(Vec::new()))
            } else {
                None
            },
            latest_upgrade_version: latest_upgrade_version.clone(),
            initial_user_message: None,
            total_token_usage: TokenUsage::default(),
            last_token_usage: TokenUsage::default(),
            rate_limit_snapshot: None,
            rate_limit_warnings: RateLimitWarningState::default(),
            rate_limit_fetch_inflight: false,
            rate_limit_last_fetch_at: None,
            rate_limit_primary_next_reset_at: None,
            rate_limit_secondary_next_reset_at: None,
            content_buffer: String::new(),
            last_assistant_message: None,
            exec: ExecState {
                running_commands: HashMap::new(),
                running_explore_agg_index: None,
                pending_exec_ends: HashMap::new(),
                suppressed_exec_end_call_ids: HashSet::new(),
                suppressed_exec_end_order: VecDeque::new(),
            },
            canceled_exec_call_ids: HashSet::new(),
            tools_state: ToolState {
                running_custom_tools: HashMap::new(),
                web_search_sessions: HashMap::new(),
                web_search_by_call: HashMap::new(),
                web_search_by_order: HashMap::new(),
                running_wait_tools: HashMap::new(),
                running_kill_tools: HashMap::new(),
                browser_sessions: HashMap::new(),
                browser_session_by_call: HashMap::new(),
                browser_session_by_order: HashMap::new(),
                browser_last_key: None,
                agent_runs: HashMap::new(),
                agent_run_by_call: HashMap::new(),
                agent_run_by_order: HashMap::new(),
                agent_run_by_batch: HashMap::new(),
                agent_run_by_agent: HashMap::new(),
                agent_last_key: None,
                auto_drive_tracker: None,
            },
            live_builder: RowBuilder::new(usize::MAX),
            header_wave: {
                let effect = HeaderWaveEffect::new();
                if ENABLE_WARP_STRIPES {
                    effect.set_enabled(true, Instant::now());
                } else {
                    effect.set_enabled(false, Instant::now());
                }
                effect
            },
            browser_overlay_visible: false,
            browser_overlay_state: BrowserOverlayState::default(),
            pending_images: HashMap::new(),
            welcome_shown: false,
            latest_browser_screenshot: Arc::new(Mutex::new(None)),
            browser_autofix_requested: Arc::new(AtomicBool::new(false)),
            cached_image_protocol: RefCell::new(None),
            cached_picker: RefCell::new(terminal_info.picker.clone()),
            cached_cell_size: std::cell::OnceCell::new(),
            git_branch_cache: RefCell::new(GitBranchCache::default()),
            terminal_info,
            active_agents: Vec::new(),
            agents_ready_to_start: false,
            last_agent_prompt: None,
            agent_context: None,
            agent_task: None,
            recent_agent_hint: None,
            suppress_next_agent_hint: false,
            active_review_hint: None,
            active_review_prompt: None,
            auto_resolve_state: None,
            pending_turn_descriptor: None,
            pending_auto_turn_config: None,
            pending_review_commit: None,
            auto_review_cleanup: None,
            auto_review_pending: false,
            overall_task_status: "preparing".to_string(),
            active_plan_title: None,
            agent_runtime: HashMap::new(),
            sparkline_data: std::cell::RefCell::new(Vec::new()),
            last_sparkline_update: std::cell::RefCell::new(std::time::Instant::now()),
            stream: crate::streaming::controller::StreamController::new(config.clone()),
            stream_state: StreamState {
                current_kind: None,
                closed_answer_ids: HashSet::new(),
                closed_reasoning_ids: HashSet::new(),
                seq_answer_final: None,
                drop_streaming: false,
            },
            interrupts: interrupts::InterruptManager::new(),
            ended_call_ids: HashSet::new(),
            diffs: DiffsState {
                session_patch_sets: Vec::new(),
                baseline_file_contents: HashMap::new(),
                overlay: None,
                confirm: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            help: HelpState {
                overlay: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            settings: SettingsState::default(),
            limits: LimitsState::default(),
            terminal: TerminalState::default(),
            pending_manual_terminal: HashMap::new(),
            agents_overview_selected_index: 0,
            agents_terminal: AgentsTerminalState::new(),
            pending_upgrade_notice: None,
            history_render: HistoryRenderState::new(),
            render_theme_epoch: 0,
            history_state: HistoryState::new(),
            history_snapshot_dirty: false,
            history_snapshot_last_flush: None,
            history_cell_ids: Vec::new(),
            height_manager: RefCell::new(HeightManager::new(
                crate::height_manager::HeightManagerConfig::default(),
            )),
            layout: LayoutState {
                scroll_offset: 0,
                last_max_scroll: std::cell::Cell::new(0),
                last_history_viewport_height: std::cell::Cell::new(0),
                vertical_scrollbar_state: std::cell::RefCell::new(ScrollbarState::default()),
                scrollbar_visible_until: std::cell::Cell::new(None),
                last_bottom_reserved_rows: std::cell::Cell::new(0),
                last_frame_height: std::cell::Cell::new(0),
                last_frame_width: std::cell::Cell::new(0),
            },
            last_theme: crate::theme::current_theme(),
            perf_state: PerfState {
                enabled: false,
                stats: RefCell::new(PerfStats::default()),
                pending_scroll_rows: Cell::new(0),
            },
            session_id: None,
            active_task_ids: HashSet::new(),
            queued_user_messages: std::collections::VecDeque::new(),
            pending_dispatched_user_messages: std::collections::VecDeque::new(),
            pending_user_prompts_for_next_turn: 0,
            ghost_snapshots: Vec::new(),
            ghost_snapshots_disabled: false,
            ghost_snapshots_disabled_reason: None,
            ghost_snapshot_queue: VecDeque::new(),
            active_ghost_snapshot: None,
            next_ghost_snapshot_id: 0,
            pending_snapshot_dispatches: VecDeque::new(),
            auto_drive_card_sequence: 0,
            auto_drive_variant,
            auto_state: AutoDriveController::default(),
            auto_goal_escape_state: AutoGoalEscState::Inactive,
            auto_handle: None,
            auto_history: AutoDriveHistory::new(),
            auto_turn_review_state: None,
            auto_pending_goal_request: false,
            auto_goal_bootstrap_done: false,
            cloud_tasks_selected_env: None,
            cloud_tasks_environments: Vec::new(),
            cloud_tasks_last_tasks: Vec::new(),
            cloud_tasks_best_of_n: 1,
            cloud_tasks_creation_inflight: false,
            cloud_task_apply_tickets: HashMap::new(),
            cloud_task_create_ticket: None,
            browser_is_external: false,
            next_cli_text_format: None,
            // Strict ordering init for forked widget
            cell_order_seq: vec![OrderKey {
                req: 0,
                out: -1,
                seq: 0,
            }],
            cell_order_dbg: vec![None; 1],
            reasoning_index: HashMap::new(),
            stream_order_seq: HashMap::new(),
            order_request_bias: 0,
            resume_expected_next_request: None,
            resume_provider_baseline: None,
            last_seen_request_index: 0,
            current_request_index: 0,
            internal_seq: 0,
            show_order_overlay,
            scroll_history_hint_shown: false,
            access_status_idx: None,
            standard_terminal_mode: !config.tui.alternate_screen,
            pending_agent_notes: Vec::new(),
            synthetic_system_req: None,
            system_cell_by_id: HashMap::new(),
            ui_background_seq_counters: HashMap::new(),
            last_assigned_order: None,
            replay_history_depth: 0,
            resume_placeholder_visible: false,
        };
        if let Ok(Some(active_id)) = auth_accounts::get_active_account_id(&config.code_home) {
            if let Ok(records) = account_usage::list_rate_limit_snapshots(&config.code_home) {
                if let Some(record) = records.into_iter().find(|r| r.account_id == active_id) {
                    w.rate_limit_primary_next_reset_at = record.primary_next_reset_at;
                    w.rate_limit_secondary_next_reset_at = record.secondary_next_reset_at;
                }
            }
        }
        w.set_standard_terminal_mode(!config.tui.alternate_screen);
        if show_welcome {
            w.history_push_top_next_req(history_cell::new_animated_welcome());
        }
        w.maybe_start_auto_upgrade_task();
        w
    }

    fn auto_drive_lines_to_string(lines: Vec<Line<'static>>) -> String {
        let mut rows: Vec<String> = Vec::new();
        for line in lines {
            let mut row = String::new();
            for span in line.spans {
                row.push_str(span.content.as_ref());
            }
            rows.push(row);
        }
        while rows
            .last()
            .map(|line| line.trim().is_empty())
            .unwrap_or(false)
        {
            rows.pop();
        }
        rows.join("\n")
    }

    fn auto_drive_role_for_kind(kind: HistoryCellType) -> Option<AutoDriveRole> {
        use AutoDriveRole::{Assistant, User};
        match kind {
            HistoryCellType::User => Some(Assistant),
            HistoryCellType::Assistant
            | HistoryCellType::Reasoning
            | HistoryCellType::Error
            | HistoryCellType::Exec { .. }
            | HistoryCellType::Patch { .. }
            | HistoryCellType::PlanUpdate
            | HistoryCellType::BackgroundEvent
            | HistoryCellType::Notice
            | HistoryCellType::Diff
            | HistoryCellType::Plain
            | HistoryCellType::Image => Some(User),
            HistoryCellType::Tool { status } => match status {
                crate::history_cell::ToolCellStatus::Running => None,
                crate::history_cell::ToolCellStatus::Success
                | crate::history_cell::ToolCellStatus::Failed => Some(User),
            },
            HistoryCellType::AnimatedWelcome | HistoryCellType::Loading => None,
        }
    }

    fn auto_drive_cell_text(cell: &dyn HistoryCell) -> Option<String> {
        let text = Self::auto_drive_lines_to_string(cell.display_lines());
        if text.trim().is_empty() {
            None
        } else {
            Some(text)
        }
    }

    fn auto_drive_make_user_message(
        text: String,
    ) -> Option<code_protocol::models::ResponseItem> {
        if text.trim().is_empty() {
            return None;
        }
        use code_protocol::models::{ContentItem, ResponseItem};
        Some(ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![ContentItem::InputText { text }],
        })
    }

    fn auto_drive_make_assistant_message(
        text: String,
    ) -> Option<code_protocol::models::ResponseItem> {
        if text.trim().is_empty() {
            return None;
        }
        use code_protocol::models::{ContentItem, ResponseItem};
        Some(ResponseItem::Message {
            id: None,
            role: "assistant".to_string(),
            content: vec![ContentItem::OutputText { text }],
        })
    }

    fn auto_drive_normalize_diff_path(raw: &str) -> Option<String> {
        let trimmed = raw.trim();
        if trimmed == "/dev/null" {
            return None;
        }
        let normalized = trimmed
            .strip_prefix("a/")
            .or_else(|| trimmed.strip_prefix("b/"))
            .unwrap_or(trimmed);
        Some(normalized.to_string())
    }

    fn auto_drive_diff_summary(record: &DiffRecord) -> Option<String> {
        use std::collections::BTreeMap;

        let mut stats: BTreeMap<String, (u32, u32)> = BTreeMap::new();
        let mut current_file: Option<String> = None;

        for hunk in &record.hunks {
            for line in &hunk.lines {
                match line.kind {
                    DiffLineKind::Context => {
                        let content = line.content.trim();
                        if let Some(rest) = content.strip_prefix("diff --git ") {
                            let mut parts = rest.split_whitespace();
                            let _old = parts.next();
                            if let Some(new_path) = parts.next() {
                                if let Some(path) = Self::auto_drive_normalize_diff_path(new_path) {
                                    stats.entry(path.clone()).or_insert((0, 0));
                                    current_file = Some(path);
                                }
                            }
                        } else {
                            if let Some(rest) = content.strip_prefix("--- ") {
                                if let Some(path) = Self::auto_drive_normalize_diff_path(rest) {
                                    stats.entry(path.clone()).or_insert((0, 0));
                                    current_file = Some(path);
                                }
                            }
                            if let Some(rest) = content.strip_prefix("+++ ") {
                                if let Some(path) = Self::auto_drive_normalize_diff_path(rest) {
                                    stats.entry(path.clone()).or_insert((0, 0));
                                    current_file = Some(path);
                                }
                            }
                        }
                    }
                    DiffLineKind::Addition => {
                        if let Some(file) = current_file.as_ref() {
                            let entry = stats.entry(file.clone()).or_insert((0, 0));
                            entry.0 += 1;
                        }
                    }
                    DiffLineKind::Removal => {
                        if let Some(file) = current_file.as_ref() {
                            let entry = stats.entry(file.clone()).or_insert((0, 0));
                            entry.1 += 1;
                        }
                    }
                }
            }
        }

        if stats.is_empty() {
            return None;
        }

        let mut lines = Vec::with_capacity(stats.len() + 1);
        lines.push("Files changed".to_string());
        for (path, (added, removed)) in stats {
            lines.push(format!("- {} (+{} / -{})", path, added, removed));
        }
        Some(lines.join("\n"))
    }

    pub(crate) fn export_auto_drive_items(&self) -> Vec<code_protocol::models::ResponseItem> {
        let mut items = Vec::new();
        for cell in &self.history_cells {
            let Some(role) = Self::auto_drive_role_for_kind(cell.kind()) else {
                continue;
            };

            let text = match cell.kind() {
                HistoryCellType::Reasoning => Self::auto_drive_cell_text(cell.as_ref()).map(|text| (text, true)),
                HistoryCellType::PlanUpdate => {
                    if let Some(plan) = cell.as_any().downcast_ref::<PlanUpdateCell>() {
                        let state = plan.state();
                        let mut lines: Vec<String> = Vec::new();
                        if !state.name.trim().is_empty() {
                            lines.push(format!("Plan update: {}", state.name.trim()));
                        } else {
                            lines.push("Plan update".to_string());
                        }
                        if state.progress.total > 0 {
                            lines.push(format!(
                                "Progress: {}/{}",
                                state.progress.completed, state.progress.total
                            ));
                        }
                        if state.steps.is_empty() {
                            lines.push("(no steps recorded)".to_string());
                        } else {
                            for step in &state.steps {
                                let status_label = match step.status {
                                    StepStatus::Completed => "[completed]",
                                    StepStatus::InProgress => "[in_progress]",
                                    StepStatus::Pending => "[pending]",
                                };
                                lines.push(format!("{} {}", status_label, step.description));
                            }
                        }
                        let text = lines.join("\n");
                        Some((text, false))
                    } else {
                        Self::auto_drive_cell_text(cell.as_ref()).map(|text| (text, false))
                    }
                }
                HistoryCellType::Diff => {
                    if let Some(diff_cell) = cell.as_any().downcast_ref::<DiffCell>() {
                        Self::auto_drive_diff_summary(diff_cell.record()).map(|text| (text, false))
                    } else {
                        Self::auto_drive_cell_text(cell.as_ref()).map(|text| (text, false))
                    }
                }
                _ => Self::auto_drive_cell_text(cell.as_ref()).map(|text| (text, false)),
            };

            let Some((text, is_reasoning)) = text else {
                continue;
            };

            let item = if is_reasoning {
                code_protocol::models::ResponseItem::Message {
                    id: Some("auto-drive-reasoning".to_string()),
                    role: "user".to_string(),
                    content: vec![code_protocol::models::ContentItem::InputText { text }],
                }
            } else {
                match role {
                    AutoDriveRole::Assistant => match Self::auto_drive_make_assistant_message(text) {
                        Some(item) => item,
                        None => continue,
                    },
                    AutoDriveRole::User => match Self::auto_drive_make_user_message(text) {
                        Some(item) => item,
                        None => continue,
                    },
                }
            };

            items.push(item);
        }
        items
    }

    fn rebuild_auto_history(&mut self) -> Vec<code_protocol::models::ResponseItem> {
        let conversation = self.export_auto_drive_items();
        let tail = self
            .auto_history
            .replace_converted(conversation.clone());
        if !tail.is_empty() {
            self.auto_history.append_converted_tail(&tail);
        }
        self.auto_history.raw_snapshot()
    }

    fn current_auto_history(&mut self) -> Vec<code_protocol::models::ResponseItem> {
        if self.auto_history.converted_is_empty() {
            return self.rebuild_auto_history();
        }
        self.auto_history.raw_snapshot()
    }

    /// Export current user/assistant messages into ResponseItem list for forking.
    pub(crate) fn export_response_items(&self) -> Vec<code_protocol::models::ResponseItem> {
        use code_protocol::models::ContentItem;
        use code_protocol::models::ResponseItem;
        let mut items = Vec::new();
        for cell in &self.history_cells {
            match cell.kind() {
                crate::history_cell::HistoryCellType::User => {
                    let text = cell
                        .display_lines()
                        .iter()
                        .map(|l| {
                            l.spans
                                .iter()
                                .map(|s| s.content.to_string())
                                .collect::<String>()
                        })
                        .collect::<Vec<_>>()
                        .join("\n");
                    let prefixed = format!("Coordinator: {text}");
                    let content = ContentItem::InputText { text: prefixed };
                    items.push(ResponseItem::Message {
                        id: None,
                        role: "user".to_string(),
                        content: vec![content],
                    });
                }
                crate::history_cell::HistoryCellType::Assistant => {
                    let text = cell
                        .display_lines()
                        .iter()
                        .map(|l| {
                            l.spans
                                .iter()
                                .map(|s| s.content.to_string())
                                .collect::<String>()
                        })
                        .collect::<Vec<_>>()
                        .join("\n");
                    let prefixed = format!("CLI: {text}");
                    let content = ContentItem::OutputText { text: prefixed };
                    items.push(ResponseItem::Message {
                        id: None,
                        role: "assistant".to_string(),
                        content: vec![content],
                    });
                }
                crate::history_cell::HistoryCellType::PlanUpdate => {
                    if let Some(plan) = cell
                        .as_any()
                        .downcast_ref::<crate::history_cell::PlanUpdateCell>()
                    {
                        let state = plan.state();
                        let mut lines: Vec<String> = Vec::new();
                        if !state.name.trim().is_empty() {
                            lines.push(format!("Plan update: {}", state.name.trim()));
                        } else {
                            lines.push("Plan update".to_string());
                        }

                        if state.progress.total > 0 {
                            lines.push(format!(
                                "Progress: {}/{}",
                                state.progress.completed, state.progress.total
                            ));
                        }

                        if state.steps.is_empty() {
                            lines.push("(no steps recorded)".to_string());
                        } else {
                            for step in &state.steps {
                                let status_label = match step.status {
                                    StepStatus::Completed => "[completed]",
                                    StepStatus::InProgress => "[in_progress]",
                                    StepStatus::Pending => "[pending]",
                                };
                                lines.push(format!("- {} {}", status_label, step.description));
                            }
                        }

                        let text = lines.join("\n");
                        let content = ContentItem::OutputText { text };
                        items.push(ResponseItem::Message {
                            id: None,
                            role: "assistant".to_string(),
                            content: vec![content],
                        });
                    }
                }
                _ => {}
            }
        }
        items
    }

    pub(crate) fn config_ref(&self) -> &Config {
        &self.config
    }

    /// Check if there are any animations and trigger redraw if needed
    pub fn check_for_initial_animations(&mut self) {
        if self.history_cells.iter().any(|cell| cell.is_animating()) {
            tracing::info!("Initial animation detected, scheduling frame");
            // Schedule initial frame for animations to ensure they start properly.
            // Use ScheduleFrameIn to avoid debounce issues with immediate RequestRedraw.
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(std::time::Duration::from_millis(
                    50,
                )));
        }
    }

    /// Format model name with proper capitalization (e.g., "gpt-4" -> "GPT-4")
    fn format_model_name(&self, model_name: &str) -> String {
        if let Some(rest) = model_name.strip_prefix("gpt-") {
            let formatted_rest = rest
                .split('-')
                .map(|segment| {
                    if segment.eq_ignore_ascii_case("codex") {
                        "Codex".to_string()
                    } else {
                        segment.to_string()
                    }
                })
                .collect::<Vec<_>>()
                .join("-");
            format!("GPT-{}", formatted_rest)
        } else {
            model_name.to_string()
        }
    }

    /// Calculate the maximum scroll offset based on current content size
    #[allow(dead_code)]
    fn calculate_max_scroll_offset(&self, content_area_height: u16) -> u16 {
        let mut total_height = 0u16;

        // Calculate total content height (same logic as render method)
        for cell in &self.history_cells {
            let h = cell.desired_height(80); // Use reasonable width for height calculation
            total_height = total_height.saturating_add(h);
        }

        if let Some(ref cell) = self.active_exec_cell {
            let h = cell.desired_height(80);
            total_height = total_height.saturating_add(h);
        }

        // Max scroll is content height minus available height
        total_height.saturating_sub(content_area_height)
    }

    pub(crate) fn handle_key_event(&mut self, key_event: KeyEvent) {
        if settings_handlers::handle_settings_key(self, key_event) {
            return;
        }
        if self.settings.overlay.is_some() {
            return;
        }
        if terminal_handlers::handle_terminal_key(self, key_event) {
            return;
        }
        if self.terminal.overlay.is_some() {
            // Block background input while the terminal overlay is visible.
            return;
        }
        // Intercept keys for overlays when active (help first, then diff)
        if help_handlers::handle_help_key(self, key_event) {
            return;
        }
        if self.help.overlay.is_some() {
            return;
        }
        if diff_handlers::handle_diff_key(self, key_event) {
            return;
        }
        if self.diffs.overlay.is_some() {
            return;
        }
        if self.browser_overlay_visible {
            let is_ctrl_b = matches!(
                key_event,
                KeyEvent {
                    code: crossterm::event::KeyCode::Char('b'),
                    modifiers: crossterm::event::KeyModifiers::CONTROL,
                    kind: KeyEventKind::Press | KeyEventKind::Repeat,
                    ..
                }
            );
            if is_ctrl_b {
                self.toggle_browser_overlay();
                return;
            }
            if self.handle_browser_overlay_key(key_event) {
                return;
            }
        }
        if key_event.kind == KeyEventKind::Press {
            self.bottom_pane.clear_ctrl_c_quit_hint();
        }

        if self.auto_state.awaiting_coordinator_submit()
            && !self.auto_state.is_paused_manual()
            && matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat)
        {
            match key_event.code {
                crossterm::event::KeyCode::Enter
                | crossterm::event::KeyCode::Char(' ') if key_event.modifiers.is_empty() => {
                    if !self.auto_state.should_bypass_coordinator_next_submit() {
                        self.auto_submit_prompt();
                    }
                    return;
                }
                crossterm::event::KeyCode::Char('e') | crossterm::event::KeyCode::Char('E')
                    if key_event.modifiers.is_empty() =>
                {
                    self.auto_pause_for_manual_edit(false);
                    return;
                }
                _ => {}
            }
        }

        // Global overlays (avoid conflicting with common editor keys):
        // - Ctrl+B: toggle Browser overlay
        // - Ctrl+A: toggle Agents terminal mode
        if let KeyEvent {
            code: crossterm::event::KeyCode::Char('b'),
            modifiers: crossterm::event::KeyModifiers::CONTROL,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            self.toggle_browser_overlay();
            return;
        }
        if let KeyEvent {
            code: crossterm::event::KeyCode::Char('a'),
            modifiers: crossterm::event::KeyModifiers::CONTROL,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            self.toggle_agents_hud();
            return;
        }
        if self.agents_terminal.active {
            use crossterm::event::KeyCode;
            if !matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat) {
                return;
            }
            match key_event.code {
                KeyCode::Esc => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.agents_terminal.focus_sidebar();
                        self.request_redraw();
                    } else {
                        self.exit_agents_terminal_mode();
                    }
                    return;
                }
                KeyCode::Right | KeyCode::Enter => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Sidebar {
                        self.agents_terminal.focus_detail();
                        self.request_redraw();
                    }
                    return;
                }
                KeyCode::Left => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.agents_terminal.focus_sidebar();
                        self.request_redraw();
                    }
                    return;
                }
                KeyCode::Up => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        layout_scroll::line_up(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_selection(-1);
                    }
                    return;
                }
                KeyCode::Down => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        layout_scroll::line_down(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_selection(1);
                    }
                    return;
                }
                KeyCode::Tab => {
                    self.agents_terminal.focus_sidebar();
                    self.navigate_agents_terminal_selection(1);
                    return;
                }
                KeyCode::BackTab => {
                    self.agents_terminal.focus_sidebar();
                    self.navigate_agents_terminal_selection(-1);
                    return;
                }
                KeyCode::PageUp => {
                    layout_scroll::page_up(self);
                    self.record_current_agent_scroll();
                    return;
                }
                KeyCode::PageDown => {
                    layout_scroll::page_down(self);
                    self.record_current_agent_scroll();
                    return;
                }
                _ => {
                    return;
                }
            }
        }

        // Fast-path PageUp/PageDown to scroll the transcript by a viewport at a time.
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::PageUp,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            layout_scroll::page_up(self);
            return;
        }
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::PageDown,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            layout_scroll::page_down(self);
            return;
        }
        // Home/End: when the composer is empty, jump the history to start/end
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::Home,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            if self.composer_is_empty() {
                layout_scroll::to_top(self);
                return;
            }
        }
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::End,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            if self.composer_is_empty() {
                layout_scroll::to_bottom(self);
                return;
            }
        }

        let input_result = self.bottom_pane.handle_key_event(key_event);
        self.auto_sync_goal_escape_state_from_composer();

        match input_result {
            InputResult::Submitted(text) => {
                if self.auto_state.should_show_goal_entry() {
                    let trimmed = text.trim();
                    if trimmed.is_empty() {
                        self.bottom_pane.set_task_running(true);
                        self.bottom_pane
                            .update_status_text("Auto Drive Goal".to_string());
                        self.clear_composer();
                        self.request_redraw();
                        return;
                    }
                    self.clear_composer();
                    self.bottom_pane.update_status_text(String::new());
                    self.bottom_pane.set_task_running(false);
                    self.handle_auto_command(Some(trimmed.to_string()));
                    return;
                }
                if self.try_handle_terminal_shortcut(&text) {
                    return;
                }
                let user_message = self.parse_message_with_images(text);
                self.submit_user_message(user_message);
            }
            InputResult::Command(_cmd) => {
                // Command was dispatched at the App layer; request redraw.
                self.app_event_tx.send(AppEvent::RequestRedraw);
            }
            InputResult::ScrollUp => {
                let before = self.layout.scroll_offset;
                // Only allow Up to navigate command history when the top view
                // cannot be scrolled at all (no scrollback available).
                if self.layout.last_max_scroll.get() == 0 {
                    if self.bottom_pane.try_history_up() {
                        self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                        return;
                    }
                }
                // Scroll up in chat history (increase offset, towards older content)
                // Use last_max_scroll computed during the previous render to avoid overshoot
                let new_offset = self
                    .layout
                    .scroll_offset
                    .saturating_add(3)
                    .min(self.layout.last_max_scroll.get());
                self.layout.scroll_offset = new_offset;
                self.flash_scrollbar();
                // Enable compact mode so history can use the spacer line
                if self.layout.scroll_offset > 0 {
                    self.bottom_pane.set_compact_compose(true);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::ComposerModeChange);
                    // Mark that the very next Down should continue scrolling chat (sticky)
                    self.bottom_pane.mark_next_down_scrolls_history();
                }
                self.app_event_tx.send(AppEvent::RequestRedraw);
                self.height_manager
                    .borrow_mut()
                    .record_event(HeightEvent::UserScroll);
                self.maybe_show_history_nav_hint_on_first_scroll();
                self.perf_track_scroll_delta(before, self.layout.scroll_offset);
            }
            InputResult::ScrollDown => {
                let before = self.layout.scroll_offset;
                // Only allow Down to navigate command history when the top view
                // cannot be scrolled at all (no scrollback available).
                if self.layout.last_max_scroll.get() == 0 && self.bottom_pane.history_is_browsing()
                {
                    if self.bottom_pane.try_history_down() {
                        self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                        return;
                    }
                }
                // Scroll down in chat history (decrease offset, towards bottom)
                if self.layout.scroll_offset == 0 {
                    // Already at bottom: ensure spacer above input is enabled.
                    self.bottom_pane.set_compact_compose(false);
                    self.app_event_tx.send(AppEvent::RequestRedraw);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::UserScroll);
                    self.maybe_show_history_nav_hint_on_first_scroll();
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::ComposerModeChange);
                    self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                } else if self.layout.scroll_offset >= 3 {
                    // Move towards bottom but do NOT toggle spacer yet; wait until
                    // the user confirms by pressing Down again at bottom.
                    self.layout.scroll_offset = self.layout.scroll_offset.saturating_sub(3);
                    self.app_event_tx.send(AppEvent::RequestRedraw);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::UserScroll);
                    self.maybe_show_history_nav_hint_on_first_scroll();
                    self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                } else if self.layout.scroll_offset > 0 {
                    // Land exactly at bottom without toggling spacer yet; require
                    // a subsequent Down to re-enable the spacer so the input
                    // doesn't move when scrolling into the line above it.
                    self.layout.scroll_offset = 0;
                    self.app_event_tx.send(AppEvent::RequestRedraw);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::UserScroll);
                    self.maybe_show_history_nav_hint_on_first_scroll();
                    self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                }
                self.flash_scrollbar();
            }
            InputResult::None => {
                // Trigger redraw so input wrapping/height reflects immediately
                self.app_event_tx.send(AppEvent::RequestRedraw);
            }
        }
    }

    fn toggle_browser_overlay(&mut self) {
        let new_state = !self.browser_overlay_visible;
        self.browser_overlay_visible = new_state;
        if new_state {
            if self.agents_terminal.active {
                self.exit_agents_terminal_mode();
            }
            self.browser_overlay_state.reset();
            let session_key = self
                .tools_state
                .browser_last_key
                .clone()
                .or_else(|| self.tools_state.browser_sessions.keys().next().cloned());
            self.browser_overlay_state.set_session_key(session_key.clone());
            if let Some(key) = session_key {
                if let Some(tracker) = self.tools_state.browser_sessions.get(&key) {
                    let history_len = tracker.cell.screenshot_history().len();
                    if history_len > 0 {
                        self
                            .browser_overlay_state
                            .set_screenshot_index(history_len.saturating_sub(1));
                    }
                }
            }
        } else {
            self.browser_overlay_state.reset();
        }
        self.request_redraw();
    }

    fn handle_browser_overlay_key(&mut self, key_event: KeyEvent) -> bool {
        if !self.browser_overlay_visible {
            return false;
        }
        if !matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat) {
            return true;
        }

        let shift = key_event.modifiers.contains(KeyModifiers::SHIFT);
        let ctrl = key_event.modifiers.contains(KeyModifiers::CONTROL);

        match key_event.code {
            KeyCode::Esc => {
                self.browser_overlay_visible = false;
                self.browser_overlay_state.reset();
                self.request_redraw();
            }
            KeyCode::Up if shift => {
                self.adjust_browser_overlay_action_scroll(-1);
                self.request_redraw();
            }
            KeyCode::Down if shift => {
                self.adjust_browser_overlay_action_scroll(1);
                self.request_redraw();
            }
            KeyCode::Up => {
                if self.move_browser_overlay_screenshot(-1) {
                    self.request_redraw();
                }
            }
            KeyCode::Down => {
                if self.move_browser_overlay_screenshot(1) {
                    self.request_redraw();
                }
            }
            KeyCode::Left => {
                if self.move_browser_overlay_screenshot(-1) {
                    self.request_redraw();
                }
            }
            KeyCode::Right => {
                if self.move_browser_overlay_screenshot(1) {
                    self.request_redraw();
                }
            }
            KeyCode::PageUp => {
                let step = self.browser_overlay_state.last_action_view_height().max(1) as i16;
                self.adjust_browser_overlay_action_scroll(-step);
                self.request_redraw();
            }
            KeyCode::PageDown => {
                let step = self.browser_overlay_state.last_action_view_height().max(1) as i16;
                self.adjust_browser_overlay_action_scroll(step);
                self.request_redraw();
            }
            KeyCode::Home => {
                if self.set_browser_overlay_screenshot_index(0) {
                    self.request_redraw();
                }
            }
            KeyCode::End => {
                if let Some((_, tracker)) = self.browser_overlay_tracker() {
                    let len = tracker.cell.screenshot_history().len();
                    if len > 0 && self.set_browser_overlay_screenshot_index(len - 1) {
                        self.request_redraw();
                    }
                }
            }
            KeyCode::Char('j') if key_event.modifiers.is_empty() => {
                self.adjust_browser_overlay_action_scroll(1);
                self.request_redraw();
            }
            KeyCode::Char('k') if key_event.modifiers.is_empty() => {
                self.adjust_browser_overlay_action_scroll(-1);
                self.request_redraw();
            }
            KeyCode::Char('g') if ctrl => {
                if self.set_browser_overlay_screenshot_index(0) {
                    self.request_redraw();
                }
            }
            KeyCode::Char('G') if key_event.modifiers.is_empty() => {
                if let Some((_, tracker)) = self.browser_overlay_tracker() {
                    let len = tracker.cell.screenshot_history().len();
                    if len > 0 && self.set_browser_overlay_screenshot_index(len - 1) {
                        self.request_redraw();
                    }
                }
            }
            _ => {}
        }

        true
    }

    fn browser_overlay_session_key(&self) -> Option<String> {
        if let Some(key) = self.browser_overlay_state.session_key() {
            if self.tools_state.browser_sessions.contains_key(&key) {
                return Some(key);
            }
        }
        if let Some(last) = self.tools_state.browser_last_key.clone() {
            if self.tools_state.browser_sessions.contains_key(&last) {
                self.browser_overlay_state
                    .set_session_key(Some(last.clone()));
                return Some(last);
            }
        }
        if let Some((key, _)) = self.tools_state.browser_sessions.iter().next() {
            let owned = key.clone();
            self.browser_overlay_state
                .set_session_key(Some(owned.clone()));
            return Some(owned);
        }
        None
    }

    fn browser_overlay_tracker(
        &self,
    ) -> Option<(String, &browser_sessions::BrowserSessionTracker)> {
        let key = self.browser_overlay_session_key()?;
        self.tools_state
            .browser_sessions
            .get(&key)
            .map(|tracker| (key, tracker))
    }

    fn set_browser_overlay_screenshot_index(&self, index: usize) -> bool {
        let Some((_, tracker)) = self.browser_overlay_tracker() else {
            return false;
        };
        let history = tracker.cell.screenshot_history();
        if history.is_empty() {
            return false;
        }
        let clamped = index.min(history.len().saturating_sub(1));
        if self.browser_overlay_state.screenshot_index() != clamped {
            self.browser_overlay_state.set_screenshot_index(clamped);
            return true;
        }
        false
    }

    fn move_browser_overlay_screenshot(&self, delta: isize) -> bool {
        let Some((_, tracker)) = self.browser_overlay_tracker() else {
            return false;
        };
        let history = tracker.cell.screenshot_history();
        if history.is_empty() {
            return false;
        }
        let last_index = history.len() as isize - 1;
        let mut current = self.browser_overlay_state.screenshot_index() as isize;
        if current > last_index {
            current = last_index;
        }
        let mut new_index = current + delta;
        if new_index < 0 {
            new_index = 0;
        }
        if new_index > last_index {
            new_index = last_index;
        }
        if new_index != current {
            self.browser_overlay_state
                .set_screenshot_index(new_index as usize);
            return true;
        }
        false
    }

    fn adjust_browser_overlay_action_scroll(&self, delta: i16) {
        let current = self.browser_overlay_state.action_scroll() as i32;
        let max = self.browser_overlay_state.max_action_scroll() as i32;
        let mut updated = current + delta as i32;
        if updated < 0 {
            updated = 0;
        } else if updated > max {
            updated = max;
        }
        self.browser_overlay_state
            .set_action_scroll(updated as u16);
    }

    fn toggle_agents_hud(&mut self) {
        if self.agents_terminal.active {
            self.exit_agents_terminal_mode();
        } else {
            self.enter_agents_terminal_mode();
        }
    }

    fn set_limits_overlay_content(&mut self, content: LimitsOverlayContent) {
        let handled_by_settings = self.update_limits_settings_content(content.clone());
        if handled_by_settings {
            self.limits.cached_content = None;
        } else {
            self.limits.cached_content = Some(content);
        }
    }

    fn update_limits_settings_content(&mut self, content: LimitsOverlayContent) -> bool {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if let Some(view) = overlay.limits_content_mut() {
                view.set_content(content);
            } else {
                overlay.set_limits_content(LimitsSettingsContent::new(content));
            }
            self.request_redraw();
            true
        } else {
            false
        }
    }

    fn set_limits_overlay_tabs(&mut self, tabs: Vec<LimitsTab>) {
        let content = if tabs.is_empty() {
            LimitsOverlayContent::Placeholder
        } else {
            LimitsOverlayContent::Tabs(tabs)
        };
        self.set_limits_overlay_content(content);
    }

    fn build_limits_tabs(
        &self,
        current_snapshot: Option<RateLimitSnapshotEvent>,
        current_reset: RateLimitResetInfo,
    ) -> Vec<LimitsTab> {
        use std::collections::HashSet;

        let code_home = self.config.code_home.clone();
        let accounts = auth_accounts::list_accounts(&code_home).unwrap_or_default();
        let account_map: HashMap<String, StoredAccount> = accounts
            .into_iter()
            .map(|account| (account.id.clone(), account))
            .collect();

        let active_id = auth_accounts::get_active_account_id(&code_home)
            .ok()
            .flatten();

        let usage_records = account_usage::list_rate_limit_snapshots(&code_home).unwrap_or_default();
        let mut snapshot_map: HashMap<String, StoredRateLimitSnapshot> = usage_records
            .into_iter()
            .filter(|record| account_map.contains_key(&record.account_id))
            .map(|record| (record.account_id.clone(), record))
            .collect();

        let mut usage_summary_map: HashMap<String, StoredUsageSummary> = HashMap::new();
        for id in account_map.keys() {
            if let Ok(Some(summary)) = account_usage::load_account_usage(&code_home, id) {
                usage_summary_map.insert(id.clone(), summary);
            }
        }

        if let Some(active_id) = active_id.as_ref() {
            if !usage_summary_map.contains_key(active_id) {
                if let Ok(Some(summary)) = account_usage::load_account_usage(&code_home, active_id) {
                    usage_summary_map.insert(active_id.clone(), summary);
                }
            }
        }

        let mut tabs: Vec<LimitsTab> = Vec::new();
        let mut seen_ids: HashSet<String> = HashSet::new();

        if let Some(snapshot) = current_snapshot {
            let account_ref = active_id
                .as_ref()
                .and_then(|id| account_map.get(id));
            let snapshot_ref = active_id
                .as_ref()
                .and_then(|id| snapshot_map.get(id));
            let summary_ref = active_id
                .as_ref()
                .and_then(|id| usage_summary_map.get(id));

            let title = account_ref
                .map(account_display_label)
                .or_else(|| active_id.clone())
                .unwrap_or_else(|| "Current session".to_string());
            let header = Self::account_header_lines(account_ref, snapshot_ref, summary_ref);
            let extra = Self::usage_history_lines(summary_ref);
            let view = build_limits_view(&snapshot, current_reset, DEFAULT_GRID_CONFIG);
            tabs.push(LimitsTab::view(title, header, view, extra));

            if let Some(active_id) = active_id.as_ref() {
                if account_map.contains_key(active_id) {
                    seen_ids.insert(active_id.clone());
                    snapshot_map.remove(active_id);
                    usage_summary_map.remove(active_id);
                }
            }
        }

        let mut remaining_ids: Vec<String> = account_map
            .keys()
            .filter(|id| !seen_ids.contains(*id))
            .cloned()
            .collect();

        let account_sort_key = |id: &String| {
            if let Some(account) = account_map.get(id) {
                let label = account_display_label(account);
                (
                    account_mode_priority(account.mode),
                    label.to_ascii_lowercase(),
                    label,
                )
            } else {
                (u8::MAX, id.to_ascii_lowercase(), id.clone())
            }
        };

        remaining_ids.sort_by(|a, b| {
            let (a_priority, a_lower, a_label) = account_sort_key(a);
            let (b_priority, b_lower, b_label) = account_sort_key(b);
            a_priority
                .cmp(&b_priority)
                .then_with(|| a_lower.cmp(&b_lower))
                .then_with(|| a_label.cmp(&b_label))
                .then_with(|| a.cmp(b))
        });

        for id in remaining_ids {
            let account = account_map.get(&id);
            let record = snapshot_map.remove(&id);
            let usage_summary = usage_summary_map.remove(&id);
            let title = account
                .map(account_display_label)
                .unwrap_or_else(|| id.clone());
            match record {
                Some(record) => {
                    if let Some(snapshot) = record.snapshot.clone() {
                        let view_snapshot = snapshot.clone();
                        let view_reset = RateLimitResetInfo {
                            primary_next_reset: record.primary_next_reset_at,
                            secondary_next_reset: record.secondary_next_reset_at,
                            ..RateLimitResetInfo::default()
                        };
                        let view = build_limits_view(
                            &view_snapshot,
                            view_reset,
                            DEFAULT_GRID_CONFIG,
                        );
                        let header = Self::account_header_lines(
                            account,
                            Some(&record),
                            usage_summary.as_ref(),
                        );
                        let extra = Self::usage_history_lines(usage_summary.as_ref());
                        tabs.push(LimitsTab::view(title, header, view, extra));
                    } else {
                        let mut lines = Self::usage_history_lines(usage_summary.as_ref());
                        lines.push(Self::dim_line(
                            " Rate limit snapshot not yet available.",
                        ));
                        let header = Self::account_header_lines(
                            account,
                            Some(&record),
                            usage_summary.as_ref(),
                        );
                        tabs.push(LimitsTab::message(title, header, lines));
                    }
                }
                None => {
                    let mut lines = Self::usage_history_lines(usage_summary.as_ref());
                    lines.push(Self::dim_line(
                        " Rate limit snapshot not yet available.",
                    ));
                    let header = Self::account_header_lines(
                        account,
                        None,
                        usage_summary.as_ref(),
                    );
                    tabs.push(LimitsTab::message(title, header, lines));
                }
            }
        }

        if tabs.is_empty() {
            let mut lines = Self::usage_history_lines(None);
            lines.push(Self::dim_line(
                " Rate limit snapshot not yet available.",
            ));
            tabs.push(LimitsTab::message("Usage", Vec::new(), lines));
        }

        tabs
    }

    fn usage_cost_usd_from_totals(totals: &TokenTotals) -> f64 {
        let non_cached_input = totals
            .input_tokens
            .saturating_sub(totals.cached_input_tokens);
        let input_cost = (non_cached_input as f64 / TOKENS_PER_MILLION)
            * INPUT_COST_PER_MILLION_USD;
        let cached_cost = (totals.cached_input_tokens as f64 / TOKENS_PER_MILLION)
            * CACHED_INPUT_COST_PER_MILLION_USD;
        let output_cost = (totals.output_tokens as f64 / TOKENS_PER_MILLION)
            * OUTPUT_COST_PER_MILLION_USD;
        input_cost + cached_cost + output_cost
    }

    fn format_usd(amount: f64) -> String {
        let cents = (amount * 100.0).round().max(0.0);
        let cents_u128 = cents as u128;
        let dollars_u128 = cents_u128 / 100;
        let cents_part = (cents_u128 % 100) as u8;
        let dollars = (dollars_u128.min(u128::from(u64::MAX))) as u64;
        if cents_part == 0 {
            format!("${} USD", format_with_separators(dollars))
        } else {
            format!(
                "${}.{:02} USD",
                format_with_separators(dollars),
                cents_part
            )
        }
    }

    fn accumulate_token_totals(target: &mut TokenTotals, delta: &TokenTotals) {
        target.input_tokens = target
            .input_tokens
            .saturating_add(delta.input_tokens);
        target.cached_input_tokens = target
            .cached_input_tokens
            .saturating_add(delta.cached_input_tokens);
        target.output_tokens = target
            .output_tokens
            .saturating_add(delta.output_tokens);
        target.reasoning_output_tokens = target
            .reasoning_output_tokens
            .saturating_add(delta.reasoning_output_tokens);
        target.total_tokens = target
            .total_tokens
            .saturating_add(delta.total_tokens);
    }

    fn account_header_lines(
        account: Option<&StoredAccount>,
        record: Option<&StoredRateLimitSnapshot>,
        usage: Option<&StoredUsageSummary>,
    ) -> Vec<RtLine<'static>> {
        let mut lines: Vec<RtLine<'static>> = Vec::new();

        let account_type = account
            .map(|acc| match acc.mode {
                McpAuthMode::ChatGPT => "ChatGPT account",
                McpAuthMode::ApiKey => "API key",
            })
            .unwrap_or("Unknown account");

        let plan = record
            .and_then(|r| r.plan.as_deref())
            .or_else(|| usage.and_then(|u| u.plan.as_deref()))
            .unwrap_or("Unknown");

        let value_style = Style::default().fg(crate::colors::text_dim());
        let is_api_key = matches!(account.map(|acc| acc.mode), Some(McpAuthMode::ApiKey));
        let totals = usage
            .map(|u| u.totals.clone())
            .unwrap_or_default();
        let non_cached_input = totals
            .input_tokens
            .saturating_sub(totals.cached_input_tokens);
        let cached_input = totals.cached_input_tokens;
        let output_tokens = totals.output_tokens;
        let reasoning_tokens = totals.reasoning_output_tokens;
        let total_tokens = totals.total_tokens;

        let cost_usd = Self::usage_cost_usd_from_totals(&totals);
        let formatted_total = format_with_separators(total_tokens);
        let formatted_cost = Self::format_usd(cost_usd);
        let cost_suffix = if is_api_key {
            format!("({formatted_cost})")
        } else {
            format!("(API would cost {formatted_cost})")
        };

        lines.push(RtLine::from(String::new()));

        lines.push(RtLine::from(vec![
            RtSpan::raw(status_field_prefix("Type")),
            RtSpan::styled(account_type.to_string(), value_style),
        ]));
        lines.push(RtLine::from(vec![
            RtSpan::raw(status_field_prefix("Plan")),
            RtSpan::styled(plan.to_string(), value_style),
        ]));
        let tokens_summary = format!("{formatted_total} total {cost_suffix}");
        lines.push(RtLine::from(vec![
            RtSpan::raw(status_field_prefix("Tokens")),
            RtSpan::styled(tokens_summary, value_style),
        ]));

        let indent = status_tokens_prefix();
        let mut counts = vec![
            (format_with_separators(cached_input), "cached"),
            (format_with_separators(non_cached_input), "input"),
            (format_with_separators(output_tokens), "output"),
            (format_with_separators(reasoning_tokens), "reasoning"),
        ];
        let max_width = counts
            .iter()
            .map(|(count, _)| count.len())
            .max()
            .unwrap_or(0);
        for (count, label) in counts.drain(..) {
            let line_text = format!(
                "{indent}{count:>width$} {label}",
                indent = indent,
                count = count,
                label = label,
                width = max_width
            );
            lines.push(RtLine::from(vec![RtSpan::styled(line_text, value_style)]));
        }
        lines
    }

    fn hourly_usage_lines(summary: Option<&StoredUsageSummary>) -> Vec<RtLine<'static>> {
        const WIDTH: usize = 14;
        let now = Local::now();
        let anchor = now
            - ChronoDuration::minutes(now.minute() as i64)
            - ChronoDuration::seconds(now.second() as i64)
            - ChronoDuration::nanoseconds(now.nanosecond() as i64);

        let hourly_totals = Self::aggregate_hourly_totals(summary);
        let series: Vec<(DateTime<Local>, TokenTotals)> = (0..12)
            .map(|offset| anchor - ChronoDuration::hours(offset as i64))
            .map(|dt| {
                let utc_key = Self::truncate_utc_hour(dt.with_timezone(&Utc));
                let totals = hourly_totals
                    .get(&utc_key)
                    .cloned()
                    .unwrap_or_default();
                (dt, totals)
            })
            .collect();

        let max_total = series
            .iter()
            .map(|(_, totals)| totals.total_tokens)
            .max()
            .unwrap_or(0);

        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(RtLine::from(vec![RtSpan::styled(
            "12 Hour History",
            Style::default().add_modifier(Modifier::BOLD),
        )]));

        let prefix = status_content_prefix();
        let tokens_width = series
            .iter()
            .map(|(_, totals)| format_with_separators(totals.total_tokens).len())
            .max()
            .unwrap_or(0);
        for (dt, totals) in series.iter() {
            let label = Self::format_hour_label(*dt);
            let bar = Self::bar_segment(totals.total_tokens, max_total, WIDTH);
            let tokens = format_with_separators(totals.total_tokens);
            let padding = tokens_width.saturating_sub(tokens.len());
            let formatted_tokens = format!("{space}{tokens}", space = " ".repeat(padding), tokens = tokens);
            let cost_text = Self::format_usd(Self::usage_cost_usd_from_totals(totals));
            let cost_span = RtSpan::styled(
                format!(" ({cost_text})"),
                Style::default().fg(crate::colors::text_dim()),
            );
            lines.push(RtLine::from(vec![
                RtSpan::raw(prefix.clone()),
                RtSpan::styled(
                    format!("{label} "),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                RtSpan::styled("│ ", Style::default().fg(crate::colors::text_dim())),
                RtSpan::styled(bar, Style::default().fg(crate::colors::primary())),
                RtSpan::raw(format!(" {formatted_tokens} tokens")),
                cost_span,
            ]));
        }
        lines
    }

    fn daily_usage_lines(summary: Option<&StoredUsageSummary>) -> Vec<RtLine<'static>> {
        const WIDTH: usize = 14;
        let today = Local::now().date_naive();
        let day_totals = Self::aggregate_daily_totals(summary);
        let daily: Vec<(chrono::NaiveDate, TokenTotals)> = (0..7)
            .map(|offset| today - ChronoDuration::days(offset as i64))
            .map(|day| {
                let totals = day_totals.get(&day).cloned().unwrap_or_default();
                (day, totals)
            })
            .collect();

        let max_total = daily
            .iter()
            .map(|(_, totals)| totals.total_tokens)
            .max()
            .unwrap_or(0);
        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(Self::dim_line(String::new()));
        lines.push(RtLine::from(vec![RtSpan::styled(
            "7 Day History",
            Style::default().add_modifier(Modifier::BOLD),
        )]));
        let prefix = status_content_prefix();
        let tokens_width = daily
            .iter()
            .map(|(_, totals)| format_with_separators(totals.total_tokens).len())
            .max()
            .unwrap_or(0);
        for (day, totals) in daily.iter() {
            let label = Self::format_daily_label(*day);
            let bar = Self::bar_segment(totals.total_tokens, max_total, WIDTH);
            let tokens = format_with_separators(totals.total_tokens);
            let padding = tokens_width.saturating_sub(tokens.len());
            let formatted_tokens = format!("{space}{tokens}", space = " ".repeat(padding), tokens = tokens);
            let daily_cost = Self::usage_cost_usd_from_totals(totals);
            let cost_text = Self::format_usd(daily_cost);
            let cost_span = RtSpan::styled(
                format!(" ({cost_text})"),
                Style::default().fg(crate::colors::text_dim()),
            );
            lines.push(RtLine::from(vec![
                RtSpan::raw(prefix.clone()),
                RtSpan::styled(
                    format!("{label} "),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                RtSpan::styled("│ ", Style::default().fg(crate::colors::text_dim())),
                RtSpan::styled(bar, Style::default().fg(crate::colors::primary())),
                RtSpan::raw(format!(" {formatted_tokens} tokens")),
                cost_span,
            ]));
        }
        lines
    }

    fn day_suffix(day: u32) -> &'static str {
        if (11..=13).contains(&(day % 100)) {
            return "th";
        }
        match day % 10 {
            1 => "st",
            2 => "nd",
            3 => "rd",
            _ => "th",
        }
    }

    fn format_daily_label(date: chrono::NaiveDate) -> String {
        let suffix = Self::day_suffix(date.day());
        format!("{} {:>2}{}", date.format("%b"), date.day(), suffix)
    }

    fn format_hour_label(dt: DateTime<Local>) -> String {
        let (is_pm, hour) = dt.hour12();
        let meridiem = if is_pm { "pm" } else { "am" };
        format!("{} {:>2}{}", dt.format("%a"), hour, meridiem)
    }

    fn usage_history_lines(summary: Option<&StoredUsageSummary>) -> Vec<RtLine<'static>> {
        let mut lines = Self::hourly_usage_lines(summary);
        lines.extend(Self::daily_usage_lines(summary));
        lines.extend(Self::six_month_usage_lines(summary));
        lines
    }

    fn six_month_usage_lines(summary: Option<&StoredUsageSummary>) -> Vec<RtLine<'static>> {
        const WIDTH: usize = 14;
        const MONTHS: usize = 6;

        let today = Local::now().date_naive();
        let mut year = today.year();
        let mut month = today.month();

        let month_totals = Self::aggregate_monthly_totals(summary);
        let mut months: Vec<(chrono::NaiveDate, TokenTotals)> = Vec::with_capacity(MONTHS);
        for _ in 0..MONTHS {
            let start = chrono::NaiveDate::from_ymd_opt(year, month, 1)
                .expect("valid month start");
            let key = (start.year(), start.month());
            let totals = month_totals
                .get(&key)
                .cloned()
                .unwrap_or_default();
            months.push((start, totals));
            if month == 1 {
                month = 12;
                year -= 1;
            } else {
                month -= 1;
            }
        }

        let max_total = months
            .iter()
            .map(|(_, totals)| totals.total_tokens)
            .max()
            .unwrap_or(0);

        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(Self::dim_line(String::new()));
        lines.push(RtLine::from(vec![RtSpan::styled(
            "6 Month History",
            Style::default().add_modifier(Modifier::BOLD),
        )]));

        let prefix = status_content_prefix();
        let tokens_width = months
            .iter()
            .map(|(_, totals)| format_with_separators(totals.total_tokens).len())
            .max()
            .unwrap_or(0);
        for (start, totals) in months.iter() {
            let label = start.format("%b %Y").to_string();
            let bar = Self::bar_segment(totals.total_tokens, max_total, WIDTH);
            let tokens = format_with_separators(totals.total_tokens);
            let padding = tokens_width.saturating_sub(tokens.len());
            let formatted_tokens = format!("{space}{tokens}", space = " ".repeat(padding), tokens = tokens);
            let cost_text = Self::format_usd(Self::usage_cost_usd_from_totals(totals));
            let cost_span = RtSpan::styled(
                format!(" ({cost_text})"),
                Style::default().fg(crate::colors::text_dim()),
            );
            lines.push(RtLine::from(vec![
                RtSpan::raw(prefix.clone()),
                RtSpan::styled(
                    format!("{label} "),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                RtSpan::styled("│ ", Style::default().fg(crate::colors::text_dim())),
                RtSpan::styled(bar, Style::default().fg(crate::colors::primary())),
                RtSpan::raw(format!(" {formatted_tokens} tokens")),
                cost_span,
            ]));
        }
        lines
    }

    fn bar_segment(value: u64, max: u64, width: usize) -> String {
        const FILL: &str = "▇";
        if max == 0 {
            return format!("{}{}", FILL.repeat(1), " ".repeat(width.saturating_sub(1)));
        }
        if value == 0 {
            return format!("{}{}", FILL.repeat(1), " ".repeat(width.saturating_sub(1)));
        }
        let ratio = value as f64 / max as f64;
        let filled = (ratio * width as f64).ceil().clamp(1.0, width as f64) as usize;
        format!(
            "{}{}",
            FILL.repeat(filled),
            " ".repeat(width.saturating_sub(filled))
        )
    }

    fn dim_line(text: impl Into<String>) -> RtLine<'static> {
        RtLine::from(vec![RtSpan::styled(
            text.into(),
            Style::default().fg(crate::colors::text_dim()),
        )])
    }

    fn truncate_utc_hour(ts: DateTime<Utc>) -> DateTime<Utc> {
        let naive = ts.naive_utc();
        let trimmed = naive
            .with_minute(0)
            .and_then(|dt| dt.with_second(0))
            .and_then(|dt| dt.with_nanosecond(0))
            .expect("valid hour truncation");
        Utc.from_utc_datetime(&trimmed)
    }

    fn aggregate_hourly_totals(
        summary: Option<&StoredUsageSummary>,
    ) -> HashMap<DateTime<Utc>, TokenTotals> {
        let mut totals = HashMap::new();
        if let Some(summary) = summary {
            for entry in &summary.hourly_entries {
                let key = Self::truncate_utc_hour(entry.timestamp);
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &entry.tokens);
            }
            for bucket in &summary.hourly_buckets {
                let slot = totals
                    .entry(bucket.period_start)
                    .or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &bucket.tokens);
            }
        }
        totals
    }

    fn aggregate_daily_totals(
        summary: Option<&StoredUsageSummary>,
    ) -> HashMap<chrono::NaiveDate, TokenTotals> {
        let mut totals = HashMap::new();
        if let Some(summary) = summary {
            for bucket in &summary.daily_buckets {
                let key = bucket.period_start.date_naive();
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &bucket.tokens);
            }
            for bucket in &summary.hourly_buckets {
                let key = bucket.period_start.date_naive();
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &bucket.tokens);
            }
            for entry in &summary.hourly_entries {
                let key = entry.timestamp.date_naive();
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &entry.tokens);
            }
        }
        totals
    }

    fn aggregate_monthly_totals(
        summary: Option<&StoredUsageSummary>,
    ) -> HashMap<(i32, u32), TokenTotals> {
        let mut totals = HashMap::new();
        if let Some(summary) = summary {
            let mut accumulate = |dt: DateTime<Utc>, tokens: &TokenTotals| {
                let date = dt.date_naive();
                let key = (date.year(), date.month());
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, tokens);
            };

            for bucket in &summary.monthly_buckets {
                accumulate(bucket.period_start, &bucket.tokens);
            }
            for bucket in &summary.daily_buckets {
                accumulate(bucket.period_start, &bucket.tokens);
            }
            for bucket in &summary.hourly_buckets {
                accumulate(bucket.period_start, &bucket.tokens);
            }
            for entry in &summary.hourly_entries {
                accumulate(entry.timestamp, &entry.tokens);
            }
        }
        totals
    }

    // dispatch_command() removed — command routing is handled at the App layer via AppEvent::DispatchCommand

    pub(crate) fn handle_paste(&mut self, text: String) {
        // Check if the pasted text is a file path to an image
        let trimmed = text.trim();

        tracing::info!("Paste received: {:?}", trimmed);

        const IMAGE_EXTENSIONS: &[&str] = &[
            ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".svg", ".ico", ".tiff", ".tif",
        ];

        // Check if it looks like a file path
        let is_likely_path = trimmed.starts_with("file://")
            || trimmed.starts_with("/")
            || trimmed.starts_with("~/")
            || trimmed.starts_with("./");

        if is_likely_path {
            // Remove escape backslashes that terminals add for special characters
            let unescaped = trimmed
                .replace("\\ ", " ")
                .replace("\\(", "(")
                .replace("\\)", ")");

            // Handle file:// URLs (common when dragging from Finder)
            let path_str = if unescaped.starts_with("file://") {
                // URL decode to handle spaces and special characters
                // Simple decoding for common cases (spaces as %20, etc.)
                unescaped
                    .strip_prefix("file://")
                    .map(|s| {
                        s.replace("%20", " ")
                            .replace("%28", "(")
                            .replace("%29", ")")
                            .replace("%5B", "[")
                            .replace("%5D", "]")
                            .replace("%2C", ",")
                            .replace("%27", "'")
                            .replace("%26", "&")
                            .replace("%23", "#")
                            .replace("%40", "@")
                            .replace("%2B", "+")
                            .replace("%3D", "=")
                            .replace("%24", "$")
                            .replace("%21", "!")
                            .replace("%2D", "-")
                            .replace("%2E", ".")
                    })
                    .unwrap_or_else(|| unescaped.clone())
            } else {
                unescaped
            };

            tracing::info!("Decoded path: {:?}", path_str);

            // Check if it has an image extension
            let is_image = IMAGE_EXTENSIONS
                .iter()
                .any(|ext| path_str.to_lowercase().ends_with(ext));

            if is_image {
                let path = PathBuf::from(&path_str);
                tracing::info!("Checking if path exists: {:?}", path);
                if path.exists() {
                    tracing::info!("Image file dropped/pasted: {:?}", path);
                    // Get just the filename for display
                    let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("image");

                    // Add a placeholder to the compose field instead of submitting
                    let placeholder = format!("[image: {}]", filename);

                    // Store the image path for later submission
                    self.pending_images.insert(placeholder.clone(), path);

                    // Add the placeholder text to the compose field
                    self.bottom_pane.handle_paste(placeholder);
                    self.auto_sync_goal_escape_state_from_composer();
                    // Force immediate redraw to reflect input growth/wrap
                    self.request_redraw();
                    return;
                } else {
                    tracing::warn!("Image path does not exist: {:?}", path);
                }
            } else {
                // For non-image files, paste the decoded path as plain text.
                let path = PathBuf::from(&path_str);
                if path.exists() && path.is_file() {
                    self.bottom_pane.handle_paste(path_str);
                    self.auto_sync_goal_escape_state_from_composer();
                    self.request_redraw();
                    return;
                }
            }
        }

        // Otherwise handle as regular text paste
        self.bottom_pane.handle_paste(text);
        self.auto_sync_goal_escape_state_from_composer();
        // Force immediate redraw so compose height matches new content
        self.request_redraw();
    }

    /// Briefly show the vertical scrollbar and schedule a redraw to hide it.
    fn flash_scrollbar(&self) {
        layout_scroll::flash_scrollbar(self);
    }

    fn history_insert_with_key_global(
        &mut self,
        cell: Box<dyn HistoryCell>,
        key: OrderKey,
    ) -> usize {
        self.history_insert_with_key_global_tagged(cell, key, "untagged", None)
    }

    // Internal: same as above but with a short tag for debug overlays.
    fn history_insert_with_key_global_tagged(
        &mut self,
        cell: Box<dyn HistoryCell>,
        key: OrderKey,
        tag: &'static str,
        record: Option<HistoryDomainRecord>,
    ) -> usize {
        #[cfg(debug_assertions)]
        {
            let cell_kind = cell.kind();
            if cell_kind == HistoryCellType::BackgroundEvent {
                debug_assert!(
                    tag == "background",
                    "Background events must use the background helper (tag={})",
                    tag
                );
            }
        }
        // Any ordered insert of a non-reasoning cell means reasoning is no longer the
        // bottom-most active block; drop the in-progress ellipsis on collapsed titles.
        let is_reasoning_cell = cell
            .as_any()
            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            .is_some();
        if !is_reasoning_cell {
            self.clear_reasoning_in_progress();
        }
        let is_background_cell = matches!(cell.kind(), HistoryCellType::BackgroundEvent);
        let mut key = key;
        let mut key_bumped = false;
        if !is_background_cell {
            if let Some(last) = self.last_assigned_order {
                if key <= last {
                    key = Self::order_key_successor(last);
                    key_bumped = true;
                }
            }
        }

        // Determine insertion position across the entire history
        let mut pos = self.history_cells.len();
        for i in 0..self.history_cells.len() {
            if let Some(existing) = self.cell_order_seq.get(i) {
                if *existing > key {
                    pos = i;
                    break;
                }
            }
        }

        // Keep auxiliary order vector in lockstep with history before inserting
        if self.cell_order_seq.len() < self.history_cells.len() {
            let missing = self.history_cells.len() - self.cell_order_seq.len();
            for _ in 0..missing {
                self.cell_order_seq.push(OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                });
            }
        }

        tracing::info!(
            "[order] insert: {} pos={} len_before={} order_len_before={} tag={}",
            Self::debug_fmt_order_key(key),
            pos,
            self.history_cells.len(),
            self.cell_order_seq.len(),
            tag
        );
        // If order overlay is enabled, compute a short, inline debug summary for
        // reasoning titles so we can spot mid‑word character drops quickly.
        // We intentionally do this before inserting so we can attach the
        // composed string alongside the standard order debug info.
        let reasoning_title_dbg: Option<String> = if self.show_order_overlay {
            // CollapsibleReasoningCell shows a collapsed "title" line; extract
            // the first visible line and summarize its raw text/lengths.
            if let Some(rc) = cell
                .as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            {
                let lines = rc.display_lines_trimmed();
                let first = lines.first();
                if let Some(line) = first {
                    // Collect visible text and basic metrics
                    let text: String = line.spans.iter().map(|s| s.content.as_ref()).collect();
                    let bytes = text.len();
                    let chars = text.chars().count();
                    let width = unicode_width::UnicodeWidthStr::width(text.as_str());
                    let spans = line.spans.len();
                    // Per‑span byte lengths to catch odd splits inside words
                    let span_lens: Vec<usize> =
                        line.spans.iter().map(|s| s.content.len()).collect();
                    // Truncate preview to avoid overflow in narrow panes
                    let mut preview = text.clone();
                    // Truncate preview by display width, not bytes, to avoid splitting
                    // a multi-byte character at an invalid boundary.
                    {
                        use unicode_width::UnicodeWidthStr as _;
                        let maxw = 120usize;
                        if preview.width() > maxw {
                            preview = format!(
                                "{}…",
                                crate::live_wrap::take_prefix_by_width(
                                    &preview,
                                    maxw.saturating_sub(1)
                                )
                                .0
                            );
                        }
                    }
                    Some(format!(
                        "title='{}' bytes={} chars={} width={} spans={} span_bytes={:?}",
                        preview, bytes, chars, width, spans, span_lens
                    ))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        let mut cell = cell;

        let record_index = self.record_index_for_position(pos);
        let mutation = if let Some(domain_record) = record {
            let event = match domain_record {
                HistoryDomainRecord::Exec(ref exec_record) => {
                    HistoryDomainEvent::StartExec {
                        index: record_index,
                        call_id: exec_record.call_id.clone(),
                        command: exec_record.command.clone(),
                        parsed: exec_record.parsed.clone(),
                        action: exec_record.action,
                        started_at: exec_record.started_at,
                        working_dir: exec_record.working_dir.clone(),
                        env: exec_record.env.clone(),
                        tags: exec_record.tags.clone(),
                    }
                }
                other => HistoryDomainEvent::Insert {
                    index: record_index,
                    record: other,
                },
            };
            Some(self.history_state.apply_domain_event(event))
        } else if let Some(record) = history_cell::record_from_cell(cell.as_ref()) {
            let event = match HistoryDomainRecord::from(record) {
                HistoryDomainRecord::Exec(exec_record) => HistoryDomainEvent::StartExec {
                    index: record_index,
                    call_id: exec_record.call_id.clone(),
                    command: exec_record.command.clone(),
                    parsed: exec_record.parsed.clone(),
                    action: exec_record.action,
                    started_at: exec_record.started_at,
                    working_dir: exec_record.working_dir.clone(),
                    env: exec_record.env.clone(),
                    tags: exec_record.tags.clone(),
                },
                other => HistoryDomainEvent::Insert {
                    index: record_index,
                    record: other,
                },
            };
            Some(self.history_state.apply_domain_event(event))
        } else {
            None
        };

        let mut maybe_id = None;
        if let Some(mutation) = mutation {
            if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
                maybe_id = Some(id);
            }
        }

        self.history_cells.insert(pos, cell);
        self.history_cell_ids.insert(pos, maybe_id);
        // In terminal mode, App mirrors history lines into the native buffer.
        // Ensure order vector is also long enough for position after cell insert
        if self.cell_order_seq.len() < pos {
            self.cell_order_seq.resize(
                pos,
                OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                },
            );
        }
        self.cell_order_seq.insert(pos, key);
        if key_bumped {
            if let Some(stream) = self.history_cells[pos]
                .as_any()
                .downcast_ref::<crate::history_cell::StreamingContentCell>()
            {
                self.stream_order_seq
                    .insert((StreamKind::Answer, stream.state().stream_id.clone()), key);
            }
        }
        self.last_assigned_order = Some(match self.last_assigned_order {
            Some(prev) => prev.max(key),
            None => key,
        });
        // Insert debug info aligned with cell insert
        let ordered = "ordered";
        let req_dbg = format!("{}", key.req);
        let dbg = if let Some(tdbg) = reasoning_title_dbg {
            format!(
                "insert: {} req={} key={} {} pos={} tag={} | {}",
                ordered,
                req_dbg,
                0,
                Self::debug_fmt_order_key(key),
                pos,
                tag,
                tdbg
            )
        } else {
            format!(
                "insert: {} req={} {} pos={} tag={}",
                ordered,
                req_dbg,
                Self::debug_fmt_order_key(key),
                pos,
                tag
            )
        };
        if self.cell_order_dbg.len() < pos {
            self.cell_order_dbg.resize(pos, None);
        }
        self.cell_order_dbg.insert(pos, Some(dbg));
        self.invalidate_height_cache();
        self.autoscroll_if_near_bottom();
        self.bottom_pane.set_has_chat_history(true);
        self.process_animation_cleanup();
        // Maintain input focus when new history arrives unless a modal overlay owns it
        if !self.agents_terminal.active {
            self.bottom_pane.ensure_input_focus();
        }
        self.app_event_tx.send(AppEvent::RequestRedraw);
        self.refresh_explore_trailing_flags();
        self.refresh_reasoning_collapsed_visibility();
        self.mark_history_dirty();
        pos
    }

    fn history_insert_existing_record(
        &mut self,
        mut cell: Box<dyn HistoryCell>,
        mut key: OrderKey,
        tag: &'static str,
        id: HistoryId,
    ) -> usize {
        #[cfg(debug_assertions)]
        {
            let cell_kind = cell.kind();
            if cell_kind == HistoryCellType::BackgroundEvent {
                debug_assert!(
                    tag == "background",
                    "Background events must use the background helper (tag={})",
                    tag
                );
            }
        }

        let is_reasoning_cell = cell
            .as_any()
            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            .is_some();
        if !is_reasoning_cell {
                self.clear_reasoning_in_progress();
        }

        let is_background_cell = matches!(cell.kind(), HistoryCellType::BackgroundEvent);
        let mut key_bumped = false;
        if !is_background_cell {
            if let Some(last) = self.last_assigned_order {
                if key <= last {
                    key = Self::order_key_successor(last);
                    key_bumped = true;
                }
            }
        }

        let mut pos = self.history_cells.len();
        for i in 0..self.history_cells.len() {
            if let Some(existing) = self.cell_order_seq.get(i) {
                if *existing > key {
                    pos = i;
                    break;
                }
            }
        }

        if self.cell_order_seq.len() < self.history_cells.len() {
            let missing = self.history_cells.len() - self.cell_order_seq.len();
            for _ in 0..missing {
                self.cell_order_seq.push(OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                });
            }
        }

        tracing::info!(
            "[order] insert(existing): {} pos={} len_before={} order_len_before={} tag={}",
            Self::debug_fmt_order_key(key),
            pos,
            self.history_cells.len(),
            self.cell_order_seq.len(),
            tag
        );

        let reasoning_title_dbg: Option<String> = if self.show_order_overlay {
            if let Some(rc) = cell
                .as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            {
                let lines = rc.display_lines_trimmed();
                if let Some(line) = lines.first() {
                    let text: String = line.spans.iter().map(|s| s.content.as_ref()).collect();
                    let bytes = text.len();
                    let chars = text.chars().count();
                    let width = unicode_width::UnicodeWidthStr::width(text.as_str());
                    let spans = line.spans.len();
                    let span_lens: Vec<usize> =
                        line.spans.iter().map(|s| s.content.len()).collect();
                    let mut preview = text.clone();
                    {
                        use unicode_width::UnicodeWidthStr as _;
                        let maxw = 120usize;
                        if preview.width() > maxw {
                            preview = format!(
                                "{}…",
                                crate::live_wrap::take_prefix_by_width(
                                    &preview,
                                    maxw.saturating_sub(1)
                                )
                                .0
                            );
                        }
                    }
                    Some(format!(
                        "title='{}' bytes={} chars={} width={} spans={} span_bytes={:?}",
                        preview, bytes, chars, width, spans, span_lens
                    ))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        Self::assign_history_id_inner(&mut cell, id);

        self.history_cells.insert(pos, cell);
        self.history_cell_ids.insert(pos, Some(id));
        if self.cell_order_seq.len() < pos {
            self.cell_order_seq.resize(
                pos,
                OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                },
            );
        }
        self.cell_order_seq.insert(pos, key);
        if key_bumped {
            if let Some(stream) = self.history_cells[pos]
                .as_any()
                .downcast_ref::<crate::history_cell::StreamingContentCell>()
            {
                self.stream_order_seq
                    .insert((StreamKind::Answer, stream.state().stream_id.clone()), key);
            }
        }
        self.last_assigned_order = Some(match self.last_assigned_order {
            Some(prev) => prev.max(key),
            None => key,
        });

        let ordered = "existing";
        let req_dbg = format!("{}", key.req);
        let dbg = if let Some(tdbg) = reasoning_title_dbg {
            format!(
                "insert: {} req={} {} pos={} tag={} | {}",
                ordered,
                req_dbg,
                Self::debug_fmt_order_key(key),
                pos,
                tag,
                tdbg
            )
        } else {
            format!(
                "insert: {} req={} {} pos={} tag={}",
                ordered,
                req_dbg,
                Self::debug_fmt_order_key(key),
                pos,
                tag
            )
        };
        if self.cell_order_dbg.len() < pos {
            self.cell_order_dbg.resize(pos, None);
        }
        self.cell_order_dbg.insert(pos, Some(dbg));
        self.invalidate_height_cache();
        self.autoscroll_if_near_bottom();
        self.bottom_pane.set_has_chat_history(true);
        self.process_animation_cleanup();
        if !self.agents_terminal.active {
            self.bottom_pane.ensure_input_focus();
        }
        self.app_event_tx.send(AppEvent::RequestRedraw);
        self.refresh_explore_trailing_flags();
        self.refresh_reasoning_collapsed_visibility();
        self.history_render.invalidate_history_id(id);
        self.mark_history_dirty();
        pos
    }

    fn append_wait_pairs(target: &mut Vec<(String, bool)>, additions: &[(String, bool)]) {
        for (text, is_error) in additions {
            let trimmed = text.trim();
            if trimmed.is_empty() {
                continue;
            }
            if target
                .last()
                .map(|(existing, existing_err)| existing == trimmed && *existing_err == *is_error)
                .unwrap_or(false)
            {
                continue;
            }
            target.push((trimmed.to_string(), *is_error));
        }
    }

    fn wait_pairs_from_exec_notes(notes: &[ExecWaitNote]) -> Vec<(String, bool)> {
        notes
            .iter()
            .map(|note| {
                (
                    note.message.clone(),
                    matches!(note.tone, TextTone::Error),
                )
            })
            .collect()
    }

    fn update_exec_wait_state_with_pairs(
        &mut self,
        history_id: HistoryId,
        total_wait: Option<Duration>,
        wait_active: bool,
        notes: &[(String, bool)],
    ) -> bool {
        let Some(record_idx) = self.history_state.index_of(history_id) else {
            return false;
        };
        let note_records: Vec<ExecWaitNote> = notes
            .iter()
            .filter_map(|(text, is_error)| {
                let trimmed = text.trim();
                if trimmed.is_empty() {
                    None
                } else {
                    Some(ExecWaitNote {
                        message: trimmed.to_string(),
                        tone: if *is_error {
                            TextTone::Error
                        } else {
                            TextTone::Info
                        },
                        timestamp: SystemTime::now(),
                    })
                }
            })
            .collect();
        let mutation = self.history_state.apply_domain_event(HistoryDomainEvent::UpdateExecWait {
            index: record_idx,
            total_wait,
            wait_active,
            notes: note_records,
        });
        match mutation {
            HistoryMutation::Replaced {
                id,
                record: HistoryRecord::Exec(exec_record),
                ..
            }
            | HistoryMutation::Inserted {
                id,
                record: HistoryRecord::Exec(exec_record),
                ..
            } => {
                self.update_cell_from_record(id, HistoryRecord::Exec(exec_record));
                self.mark_history_dirty();
                true
            }
            _ => false,
        }
    }

    fn hydrate_cell_from_record(
        &self,
        cell: &mut Box<dyn HistoryCell>,
        record: &HistoryRecord,
    ) -> bool {
        Self::hydrate_cell_from_record_inner(cell, record, &self.config)
    }

    fn hydrate_cell_from_record_inner(
        cell: &mut Box<dyn HistoryCell>,
        record: &HistoryRecord,
        config: &Config,
    ) -> bool {
        match record {
            HistoryRecord::PlainMessage(state) => {
                if let Some(plain) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::PlainHistoryCell>()
                {
                    *plain.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::WaitStatus(state) => {
                if let Some(wait) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::WaitStatusCell>()
                {
                    *wait.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Loading(state) => {
                if let Some(loading) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::LoadingCell>()
                {
                    *loading.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::BackgroundEvent(state) => {
                if let Some(background) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::BackgroundEventCell>()
                {
                    *background.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Exec(state) => {
                if let Some(exec) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::ExecCell>()
                {
                    exec.sync_from_record(state);
                    return true;
                }
            }
            HistoryRecord::AssistantStream(state) => {
                if let Some(stream) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::StreamingContentCell>()
                {
                    stream.set_state(state.clone());
                    stream.update_context(config.file_opener, &config.cwd);
                    return true;
                }
            }
            HistoryRecord::RateLimits(state) => {
                if let Some(rate_limits) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::RateLimitsCell>()
                {
                    *rate_limits.record_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Patch(state) => {
                if let Some(patch) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::PatchSummaryCell>()
                {
                    *patch.record_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Image(state) => {
                if let Some(image) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::ImageOutputCell>()
                {
                    *image.record_mut() = state.clone();
                    return true;
                }
            }
            _ => {}
        }
        false
    }

    fn build_cell_from_record(&self, record: &HistoryRecord) -> Option<Box<dyn HistoryCell>> {
        use crate::history_cell;

        match record {
            HistoryRecord::PlainMessage(state) => Some(Box::new(
                history_cell::PlainHistoryCell::from_state(state.clone()),
            )),
            HistoryRecord::WaitStatus(state) => {
                Some(Box::new(history_cell::WaitStatusCell::from_state(state.clone())))
            }
            HistoryRecord::Loading(state) => {
                Some(Box::new(history_cell::LoadingCell::from_state(state.clone())))
            }
            HistoryRecord::RunningTool(state) => Some(Box::new(
                history_cell::RunningToolCallCell::from_state(state.clone()),
            )),
            HistoryRecord::ToolCall(state) => Some(Box::new(
                history_cell::ToolCallCell::from_state(state.clone()),
            )),
            HistoryRecord::PlanUpdate(state) => Some(Box::new(
                history_cell::PlanUpdateCell::from_state(state.clone()),
            )),
            HistoryRecord::UpgradeNotice(state) => Some(Box::new(
                history_cell::UpgradeNoticeCell::from_state(state.clone()),
            )),
            HistoryRecord::Reasoning(state) => Some(Box::new(
                history_cell::CollapsibleReasoningCell::from_state(state.clone()),
            )),
            HistoryRecord::Exec(state) => {
                Some(Box::new(history_cell::ExecCell::from_record(state.clone())))
            }
            HistoryRecord::MergedExec(state) => Some(Box::new(
                history_cell::MergedExecCell::from_state(state.clone()),
            )),
            HistoryRecord::AssistantStream(state) => Some(Box::new(
                history_cell::StreamingContentCell::from_state(
                    state.clone(),
                    self.config.file_opener,
                    self.config.cwd.clone(),
                ),
            )),
            HistoryRecord::AssistantMessage(state) => Some(Box::new(
                history_cell::AssistantMarkdownCell::from_state(state.clone(), &self.config),
            )),
            HistoryRecord::Diff(state) => {
                Some(Box::new(history_cell::DiffCell::from_record(state.clone())))
            }
            HistoryRecord::Patch(state) => {
                Some(Box::new(history_cell::PatchSummaryCell::from_record(state.clone())))
            }
            HistoryRecord::Explore(state) => {
                Some(Box::new(history_cell::ExploreAggregationCell::from_record(state.clone())))
            }
            HistoryRecord::RateLimits(state) => Some(Box::new(
                history_cell::RateLimitsCell::from_record(state.clone()),
            )),
            HistoryRecord::BackgroundEvent(state) => {
                Some(Box::new(history_cell::BackgroundEventCell::new(state.clone())))
            }
            HistoryRecord::Image(state) => Some(Box::new(
                history_cell::ImageOutputCell::from_record(state.clone()),
            )),
            HistoryRecord::Notice(state) => Some(Box::new(
                history_cell::PlainHistoryCell::from_notice_record(state.clone()),
            )),
        }
    }

    fn apply_mutation_to_cell(
        &self,
        cell: &mut Box<dyn HistoryCell>,
        mutation: HistoryMutation,
    ) -> Option<HistoryId> {
        match mutation {
            HistoryMutation::Inserted { id, record, .. }
            | HistoryMutation::Replaced { id, record, .. } => {
                if let Some(mut new_cell) = self.build_cell_from_record(&record) {
                    self.assign_history_id(&mut new_cell, id);
                    *cell = new_cell;
                } else if !self.hydrate_cell_from_record(cell, &record) {
                    self.assign_history_id(cell, id);
                }
                Some(id)
            }
            _ => None,
        }
    }

    fn apply_mutation_to_cell_index(
        &mut self,
        idx: usize,
        mutation: HistoryMutation,
    ) -> Option<HistoryId> {
        if idx >= self.history_cells.len() {
            return None;
        }
        match mutation {
            HistoryMutation::Inserted { id, record, .. }
            | HistoryMutation::Replaced { id, record, .. } => {
                self.update_cell_from_record(id, record);
                Some(id)
            }
            _ => None,
        }
    }

    fn cell_index_for_history_id(&self, id: HistoryId) -> Option<usize> {
        if let Some(idx) = self
            .history_cell_ids
            .iter()
            .position(|maybe| maybe.map(|stored| stored == id).unwrap_or(false))
        {
            return Some(idx);
        }

        self.history_cells.iter().enumerate().find_map(|(idx, cell)| {
        history_cell::record_from_cell(cell.as_ref())
                .map(|record| record.id() == id)
                .filter(|matched| *matched)
                .map(|_| idx)
        })
    }

    fn update_cell_from_record(&mut self, id: HistoryId, record: HistoryRecord) {
        if id == HistoryId::ZERO {
            tracing::debug!("skip update_cell_from_record: zero id");
            return;
        }

        self.history_render.invalidate_history_id(id);

        if let Some(idx) = self.cell_index_for_history_id(id) {
            if let Some(mut rebuilt) = self.build_cell_from_record(&record) {
                Self::assign_history_id_inner(&mut rebuilt, id);
                self.history_cells[idx] = rebuilt;
            } else if let Some(cell_slot) = self.history_cells.get_mut(idx) {
                if !Self::hydrate_cell_from_record_inner(cell_slot, &record, &self.config) {
                    Self::assign_history_id_inner(cell_slot, id);
                }
            }

            if idx < self.history_cell_ids.len() {
                self.history_cell_ids[idx] = Some(id);
            }
            self.invalidate_height_cache();
            self.request_redraw();
        } else {
            tracing::warn!(
                "history-state mismatch: unable to locate cell for id {:?}",
                id
            );
        }
    }

    fn assign_history_id(&self, cell: &mut Box<dyn HistoryCell>, id: HistoryId) {
        Self::assign_history_id_inner(cell, id);
    }

    fn assign_history_id_inner(cell: &mut Box<dyn HistoryCell>, id: HistoryId) {
        if let Some(tool_call) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ToolCallCell>()
        {
            tool_call.state_mut().id = id;
        } else if let Some(running_tool) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::RunningToolCallCell>()
        {
            running_tool.state_mut().id = id;
        } else if let Some(plan) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::PlanUpdateCell>()
        {
            plan.state_mut().id = id;
        } else if let Some(upgrade) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::UpgradeNoticeCell>()
        {
            upgrade.state_mut().id = id;
        } else if let Some(reasoning) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::CollapsibleReasoningCell>()
        {
            reasoning.set_history_id(id);
        } else if let Some(exec) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ExecCell>()
        {
            exec.record.id = id;
        } else if let Some(merged) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::MergedExecCell>()
        {
            merged.set_history_id(id);
        } else if let Some(stream) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::StreamingContentCell>()
        {
            stream.state_mut().id = id;
        } else if let Some(assistant) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::AssistantMarkdownCell>()
        {
            assistant.state_mut().id = id;
        } else if let Some(diff) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::DiffCell>()
        {
            diff.record_mut().id = id;
        } else if let Some(image) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ImageOutputCell>()
        {
            image.record_mut().id = id;
        } else if let Some(patch) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::PatchSummaryCell>()
        {
            patch.record_mut().id = id;
        } else if let Some(explore) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ExploreAggregationCell>()
        {
            explore.record_mut().id = id;
        } else if let Some(rate_limits) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::RateLimitsCell>()
        {
            rate_limits.record_mut().id = id;
        } else if let Some(plain) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::PlainHistoryCell>()
        {
            plain.state_mut().id = id;
        } else if let Some(wait) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::WaitStatusCell>()
        {
            wait.state_mut().id = id;
        } else if let Some(loading) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::LoadingCell>()
        {
            loading.state_mut().id = id;
        } else if let Some(background) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::BackgroundEventCell>()
        {
            background.state_mut().id = id;
        }
    }

    /// Push a cell using a synthetic global order key at the bottom of the current request.
    pub(crate) fn history_push(&mut self, cell: impl HistoryCell + 'static) {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                cell.kind() != HistoryCellType::BackgroundEvent,
                "Background events must use push_background_* helpers"
            );
        }
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global_tagged(Box::new(cell), key, "epilogue", None);
    }

    fn history_insert_plain_state_with_key(
        &mut self,
        state: PlainMessageState,
        key: OrderKey,
        tag: &'static str,
    ) -> usize {
        let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
        self.history_insert_with_key_global_tagged(
            Box::new(cell),
            key,
            tag,
            Some(HistoryDomainRecord::Plain(state)),
        )
    }

    pub(crate) fn history_push_plain_state(&mut self, state: PlainMessageState) {
        let key = self.next_internal_key();
        let _ = self.history_insert_plain_state_with_key(state, key, "epilogue");
    }

    fn history_push_plain_paragraphs<I, S>(
        &mut self,
        kind: PlainMessageKind,
        lines: I,
    ) where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        let role = history_cell::plain_role_for_kind(kind);
        let state = history_cell::plain_message_state_from_paragraphs(kind, role, lines);
        self.history_push_plain_state(state);
    }

    fn history_push_diff(&mut self, title: Option<String>, diff_output: String) {
        let record = history_cell::diff_record_from_string(
            title.unwrap_or_default(),
            &diff_output,
        );
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global_tagged(
            Box::new(history_cell::DiffCell::from_record(record.clone())),
            key,
            "diff",
            Some(HistoryDomainRecord::Diff(record)),
        );
    }
    /// Insert a background event near the top of the current request so it appears
    /// before imminent provider output (e.g. Exec begin).
    pub(crate) fn insert_background_event_early(&mut self, message: String) {
        let ticket = self.make_background_before_next_output_ticket();
        self.insert_background_event_with_placement(
            message,
            BackgroundPlacement::BeforeNextOutput,
            Some(ticket.next_order()),
        );
    }
    /// Insert a background event using the specified placement semantics.
    pub(crate) fn insert_background_event_with_placement(
        &mut self,
        message: String,
        placement: BackgroundPlacement,
        order: Option<code_core::protocol::OrderMeta>,
    ) {
        let order = order;
        if order.is_none() {
            if matches!(placement, BackgroundPlacement::Tail) {
                tracing::error!(
                    target: "code_order",
                    "missing order metadata for tail background event; dropping message"
                );
                return;
            } else {
                tracing::warn!(
                    target: "code_order",
                    "background event without order metadata placement={:?}",
                    placement
                );
            }
        }
        let system_placement = match placement {
            BackgroundPlacement::Tail => SystemPlacement::EndOfCurrent,
            BackgroundPlacement::BeforeNextOutput => {
                if self.pending_user_prompts_for_next_turn > 0 {
                    SystemPlacement::EarlyInCurrent
                } else {
                    SystemPlacement::PrePromptInCurrent
                }
            }
        };
        let cell = history_cell::new_background_event(message);
        let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
        self.push_system_cell(
            Box::new(cell),
            system_placement,
            None,
            order.as_ref(),
            "background",
            Some(record),
        );
    }

    pub(crate) fn push_background_tail(&mut self, message: impl Into<String>) {
        let ticket = self.make_background_tail_ticket();
        self.insert_background_event_with_placement(
            message.into(),
            BackgroundPlacement::Tail,
            Some(ticket.next_order()),
        );
    }

    pub(crate) fn push_background_before_next_output(&mut self, message: impl Into<String>) {
        let ticket = self.make_background_before_next_output_ticket();
        self.insert_background_event_with_placement(
            message.into(),
            BackgroundPlacement::BeforeNextOutput,
            Some(ticket.next_order()),
        );
    }

    pub(super) fn history_debug(&self, message: impl Into<String>) {
        if !history_cell_logging_enabled() {
            return;
        }
        let message = message.into();
        tracing::trace!(target: "code_history", "{message}");
        if let Some(buffer) = &self.history_debug_events {
            buffer.borrow_mut().push(message);
        }
    }

    fn rehydrate_system_order_cache(&mut self, preserved: &[(String, HistoryId)]) {
        let prev = self.system_cell_by_id.len();
        self.system_cell_by_id.clear();

        for (key, hid) in preserved {
            if let Some(idx) = self
                .history_cell_ids
                .iter()
                .position(|maybe| maybe.map(|stored| stored == *hid).unwrap_or(false))
            {
                self.system_cell_by_id.insert(key.clone(), idx);
            }
        }

        self.history_debug(format!(
            "system_order_cache.rehydrate prev={} restored={} entries={}",
            prev,
            preserved.len(),
            self.system_cell_by_id.len()
        ));
    }

    /// Push a cell using a synthetic key at the TOP of the NEXT request.
    fn history_push_top_next_req(&mut self, cell: impl HistoryCell + 'static) {
        let key = self.next_req_key_top();
        let _ = self.history_insert_with_key_global_tagged(Box::new(cell), key, "prelude", None);
    }
    fn history_replace_with_record(
        &mut self,
        idx: usize,
        mut cell: Box<dyn HistoryCell>,
        record: HistoryDomainRecord,
    ) {
        if idx >= self.history_cells.len() {
            return;
        }

        let record_idx = self
            .record_index_for_cell(idx)
            .unwrap_or_else(|| self.record_index_for_position(idx));

        let mutation = self.history_state.apply_domain_event(HistoryDomainEvent::Replace {
            index: record_idx,
            record,
        });

        if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
            if idx < self.history_cell_ids.len() {
                self.history_cell_ids[idx] = Some(id);
            }
        }

        self.history_cells[idx] = cell;
        self.invalidate_height_cache();
        self.request_redraw();
        self.refresh_explore_trailing_flags();
        self.mark_history_dirty();
    }

    fn history_replace_at(&mut self, idx: usize, mut cell: Box<dyn HistoryCell>) {
        if idx >= self.history_cells.len() {
            return;
        }

        let record = history_cell::record_from_cell(cell.as_ref());
        let mut maybe_id = None;

        match (record.map(HistoryDomainRecord::from), self.record_index_for_cell(idx)) {
            (Some(record), Some(record_idx)) => {
                let mutation = self
                    .history_state
                    .apply_domain_event(HistoryDomainEvent::Replace {
                        index: record_idx,
                        record,
                    });
                if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
                    maybe_id = Some(id);
                }
            }
            (Some(record), None) => {
                let record_idx = self.record_index_for_position(idx);
                let mutation = self
                    .history_state
                    .apply_domain_event(HistoryDomainEvent::Insert {
                        index: record_idx,
                        record,
                    });
                if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
                    maybe_id = Some(id);
                }
            }
            (None, Some(record_idx)) => {
                let _ = self
                    .history_state
                    .apply_domain_event(HistoryDomainEvent::Remove { index: record_idx });
            }
            (None, None) => {}
        }

        self.history_cells[idx] = cell;
        if idx < self.history_cell_ids.len() {
            self.history_cell_ids[idx] = maybe_id;
        }
        self.invalidate_height_cache();
        self.request_redraw();
        self.refresh_explore_trailing_flags();
        // Keep debug info for this cell index as-is.
        self.mark_history_dirty();
    }

    fn history_remove_at(&mut self, idx: usize) {
        if idx >= self.history_cells.len() {
            return;
        }

        if let Some(record_idx) = self.record_index_for_cell(idx) {
            let _ = self
                .history_state
                .apply_domain_event(HistoryDomainEvent::Remove { index: record_idx });
        }

        self.history_cells.remove(idx);
        if idx < self.history_cell_ids.len() {
            self.history_cell_ids.remove(idx);
        }
        if idx < self.cell_order_seq.len() {
            self.cell_order_seq.remove(idx);
        }
        if idx < self.cell_order_dbg.len() {
            self.cell_order_dbg.remove(idx);
        }
        self.invalidate_height_cache();
        self.request_redraw();
        self.refresh_explore_trailing_flags();
        self.mark_history_dirty();
    }

    fn history_replace_and_maybe_merge(&mut self, idx: usize, cell: Box<dyn HistoryCell>) {
        // Replace at index, then attempt standard exec merge with previous cell.
        self.history_replace_at(idx, cell);
        // Merge only if the new cell is an Exec with output (completed) or a MergedExec.
        crate::chatwidget::exec_tools::try_merge_completed_exec_at(self, idx);
    }

    // Merge adjacent tool cells with the same header (e.g., successive Web Search blocks)
    #[allow(dead_code)]
    fn history_maybe_merge_tool_with_previous(&mut self, idx: usize) {
        if idx == 0 || idx >= self.history_cells.len() {
            return;
        }
        let new_lines = self.history_cells[idx].display_lines();
        let new_header = new_lines
            .first()
            .and_then(|l| l.spans.get(0))
            .map(|s| s.content.clone().to_string())
            .unwrap_or_default();
        if new_header.is_empty() {
            return;
        }
        let prev_lines = self.history_cells[idx - 1].display_lines();
        let prev_header = prev_lines
            .first()
            .and_then(|l| l.spans.get(0))
            .map(|s| s.content.clone().to_string())
            .unwrap_or_default();
        if new_header != prev_header {
            return;
        }
        let mut combined = prev_lines.clone();
        while combined
            .last()
            .map(|l| crate::render::line_utils::is_blank_line_trim(l))
            .unwrap_or(false)
        {
            combined.pop();
        }
        let mut body: Vec<ratatui::text::Line<'static>> = new_lines.into_iter().skip(1).collect();
        while body
            .first()
            .map(|l| crate::render::line_utils::is_blank_line_trim(l))
            .unwrap_or(false)
        {
            body.remove(0);
        }
        while body
            .last()
            .map(|l| crate::render::line_utils::is_blank_line_trim(l))
            .unwrap_or(false)
        {
            body.pop();
        }
        if let Some(first_line) = body.first_mut() {
            if let Some(first_span) = first_line.spans.get_mut(0) {
                if first_span.content == "  └ " || first_span.content == "└ " {
                    first_span.content = "  ".into();
                }
            }
        }
        combined.extend(body);
        let state = history_cell::plain_message_state_from_lines(
            combined,
            crate::history_cell::HistoryCellType::Plain,
        );
        self.history_replace_with_record(
            idx - 1,
            Box::new(crate::history_cell::PlainHistoryCell::from_state(state.clone())),
            HistoryDomainRecord::Plain(state),
        );
        self.history_remove_at(idx);
    }

    fn record_index_for_position(&self, ui_index: usize) -> usize {
        if let Some(Some(id)) = self.history_cell_ids.get(ui_index) {
            if let Some(idx) = self.history_state.index_of(*id) {
                return idx;
            }
        }
        self.history_cell_ids
            .iter()
            .take(ui_index)
            .filter(|entry| entry.is_some())
            .count()
    }

    fn record_index_for_cell(&self, idx: usize) -> Option<usize> {
        self.history_cell_ids
            .get(idx)
            .and_then(|entry| entry.map(|_| self.record_index_for_position(idx)))
    }

    /// Clean up faded-out animation cells
    fn process_animation_cleanup(&mut self) {
        // With trait-based cells, we can't easily detect and clean up specific cell types
        // Animation cleanup is now handled differently
    }

    /// Replace the initial Popular Commands notice that includes
    /// the transient "Connecting MCP servers…" line with a version
    /// that omits it.
    fn remove_connecting_mcp_notice(&mut self) {
        let needle = "Connecting MCP servers…";
        if let Some((idx, cell)) = self.history_cells.iter().enumerate().find(|(_, cell)| {
            cell.display_lines().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.as_ref() == needle)
            })
        }) {
            match cell.kind() {
                crate::history_cell::HistoryCellType::Notice => {
                    // Older layout: status was inside the notice cell — replace it
                    let state = history_cell::new_popular_commands_notice(
                        false,
                        self.latest_upgrade_version.as_deref(),
                    );
                    let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
                    self.history_replace_with_record(
                        idx,
                        Box::new(cell),
                        HistoryDomainRecord::Plain(state),
                    );
                }
                _ => {
                    // New layout: status is a separate BackgroundEvent cell — remove it
                    self.history_remove_at(idx);
                }
            }
        }
    }

    fn refresh_explore_trailing_flags(&mut self) -> bool {
        let mut updated = false;
        for idx in 0..self.history_cells.len() {
            let is_explore = self.history_cells[idx]
                .as_any()
                .downcast_ref::<history_cell::ExploreAggregationCell>()
                .is_some();
            if !is_explore {
                continue;
            }

            let hold_title = self.rendered_explore_should_hold(idx);

            if let Some(explore_cell) = self.history_cells[idx]
                .as_any_mut()
                .downcast_mut::<history_cell::ExploreAggregationCell>()
            {
                if explore_cell.set_force_exploring_header(hold_title) {
                    updated = true;
                    if let Some(Some(id)) = self.history_cell_ids.get(idx) {
                        self.history_render.invalidate_history_id(*id);
                    }
                }
            }
        }

        if updated {
            self.invalidate_height_cache();
            self.request_redraw();
        }

        updated
    }

    fn rendered_explore_should_hold(&self, idx: usize) -> bool {
        if idx >= self.history_cells.len() {
            return true;
        }

        let mut next = idx + 1;
        while next < self.history_cells.len() {
            let cell = &self.history_cells[next];

            if cell.should_remove() {
                next += 1;
                continue;
            }

            match cell.kind() {
                history_cell::HistoryCellType::Reasoning
                | history_cell::HistoryCellType::Loading
                | history_cell::HistoryCellType::PlanUpdate => {
                    next += 1;
                    continue;
                }
                _ => {}
            }

            if cell
                .as_any()
                .downcast_ref::<history_cell::WaitStatusCell>()
                .is_some()
            {
                next += 1;
                continue;
            }

            if cell.display_lines_trimmed().is_empty() {
                next += 1;
                continue;
            }

            return false;
        }

        true
    }

    fn try_coordinator_route(
        &mut self,
        original_text: &str,
    ) -> Option<CoordinatorRouterResponse> {
        let trimmed = original_text.trim();
        if trimmed.is_empty() {
            return None;
        }
        if !self.auto_state.is_active() {
            return None;
        }
        if self.auto_state.is_paused_manual()
            && self.auto_state.should_bypass_coordinator_next_submit()
        {
            return None;
        }
        if !self.config.auto_drive.coordinator_routing {
            return None;
        }
        if trimmed.starts_with('/') {
            return None;
        }

        let mut updates = Vec::new();
        if let Some(summary) = self.auto_state.last_decision_summary.clone() {
            if !summary.trim().is_empty() {
                updates.push(summary);
            }
        }
        if let Some(current) = self.auto_state.current_summary.clone() {
            if !current.trim().is_empty() && updates.iter().all(|existing| existing != &current) {
                updates.push(current);
            }
        }

        let context = CoordinatorContext::new(self.auto_state.pending_agent_actions.len(), updates);
        let response = route_user_message(trimmed, &context);
        if response.user_response.is_some() || response.cli_command.is_some() {
            Some(response)
        } else {
            None
        }
    }

    fn submit_user_message(&mut self, user_message: UserMessage) {
        if self.layout.scroll_offset > 0 {
            layout_scroll::to_bottom(self);
        }
        // Surface a local diagnostic note and anchor it to the NEXT turn,
        // placing it directly after the user prompt so ordering is stable.
        // (debug message removed)
        // Fade the welcome cell only when a user actually posts a message.
        for cell in &self.history_cells {
            cell.trigger_fade();
        }
        let mut message = user_message;
        // If our configured cwd no longer exists (e.g., a worktree folder was
        // deleted outside the app), try to automatically recover to the repo
        // root for worktrees and re-submit the same message there.
        if !self.config.cwd.exists() {
            let missing = self.config.cwd.clone();
            let missing_s = missing.display().to_string();
            if missing_s.contains("/.code/branches/") {
                // Recover by walking up to '<repo>/.code/branches/<branch>' -> repo root
                let mut anc = missing.as_path();
                // Walk up 3 parents if available
                for _ in 0..3 {
                    if let Some(p) = anc.parent() {
                        anc = p;
                    }
                }
                let fallback_root = anc.to_path_buf();
                if fallback_root.exists() {
                    let msg = format!(
                        "⚠️ Worktree directory is missing: {}\nSwitching to repo root: {}",
                        missing.display(),
                        fallback_root.display()
                    );
                    self.send_background_tail_ordered(msg);
                    // Re-submit this exact message after switching cwd
                    self.app_event_tx.send(AppEvent::SwitchCwd(
                        fallback_root,
                        Some(message.display_text.clone()),
                    ));
                    return;
                }
            }
            // If we can't recover, surface an error and drop the message to prevent loops
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "Working directory is missing: {}",
                self.config.cwd.display()
            )));
            return;
        }
        let original_text = message.display_text.clone();

        let mut submitted_cli = false;
        let manual_edit_pending = self.auto_state.is_paused_manual()
            && self.auto_state.resume_after_submit();
        let manual_override_active = self.auto_state.is_paused_manual();

        let should_route_through_coordinator = !message.suppress_persistence
            && !original_text.trim().starts_with('/')
            && self.auto_state.is_active()
            && self.config.auto_drive.coordinator_routing
            && (!self.auto_state.should_bypass_coordinator_next_submit()
                || manual_edit_pending
                || manual_override_active);

        if should_route_through_coordinator
        {
            let mut conversation = self.current_auto_history();
            if let Some(user_item) = Self::auto_drive_make_user_message(original_text.clone()) {
                conversation.push(user_item.clone());
                if self.auto_send_user_prompt_to_coordinator(original_text.clone(), conversation) {
                    self.finalize_sent_user_message(message);
                    self.consume_pending_prompt_for_ui_only_turn();
                    self.auto_history.append_raw(std::slice::from_ref(&user_item));
                    return;
                }
            }
        }

        if !message.suppress_persistence
            && (!self.auto_state.should_bypass_coordinator_next_submit()
                || manual_edit_pending
                || manual_override_active)
        {
            if let Some(mut routed) = self.try_coordinator_route(&original_text) {
                self.finalize_sent_user_message(message);
                self.consume_pending_prompt_for_ui_only_turn();
                let _ = self.rebuild_auto_history();

                if let Some(notice_text) = routed.user_response.take() {
                    let mut lines = Vec::with_capacity(2);
                    lines.push("AUTO DRIVE RESPONSE".to_string());
                    lines.push(notice_text);
                    self.history_push_plain_paragraphs(PlainMessageKind::Notice, lines);
                }

                if let Some(cli_command) = routed.cli_command {
                    let mut synthetic: UserMessage = cli_command.into();
                    synthetic.suppress_persistence = true;
                    self.submit_user_message(synthetic);
                    submitted_cli = true;
                }

                if !submitted_cli {
                    self.auto_send_conversation_force();
                }

                return;
            }
        }

        let only_text_items = message
            .ordered_items
            .iter()
            .all(|item| matches!(item, InputItem::Text { .. }));
        if only_text_items {
            if let Some((command_line, rest_text)) =
                Self::split_leading_slash_command(&original_text)
            {
                let preview = crate::slash_command::process_slash_command_message(
                    command_line.as_str(),
                );
                match preview {
                    ProcessedCommand::RegularCommand(SlashCommand::Auto, canonical_text) => {
                        let goal = rest_text.trim();
                        let command_text = if goal.is_empty() {
                            canonical_text
                        } else {
                            format!("{canonical_text} {goal}")
                        };
                        self.app_event_tx
                            .send(AppEvent::DispatchCommand(SlashCommand::Auto, command_text));
                        return;
                    }
                    ProcessedCommand::NotCommand(_) => {}
                    _ => {
                        self.submit_user_message(command_line.into());
                        let trimmed_rest = rest_text.trim();
                        if !trimmed_rest.is_empty() {
                            self.submit_user_message(rest_text.into());
                        }
                        return;
                    }
                }
            }
        }
        // Build a combined string view of the text-only parts to process slash commands
        let mut text_only = String::new();
        for it in &message.ordered_items {
            if let InputItem::Text { text } = it {
                if !text_only.is_empty() {
                    text_only.push('\n');
                }
                text_only.push_str(text);
            }
        }

        // Save the prompt if it's a multi-agent command
        let original_trimmed = original_text.trim();
        if original_trimmed.starts_with("/plan ")
            || original_trimmed.starts_with("/solve ")
            || original_trimmed.starts_with("/code ")
        {
            self.last_agent_prompt = Some(original_text.clone());
        }

        // Process slash commands and expand them if needed
        // First, allow custom subagent commands: if the message starts with a slash and the
        // command name matches a saved subagent in config, synthesize a unified prompt using
        // format_subagent_command and replace the message with that prompt.
        if let Some(first) = original_text.trim().strip_prefix('/') {
            let mut parts = first.splitn(2, ' ');
            let cmd_name = parts.next().unwrap_or("").trim();
            let args = parts.next().unwrap_or("").trim().to_string();
            if !cmd_name.is_empty() {
                let has_custom = self
                    .config
                    .subagent_commands
                    .iter()
                    .any(|c| c.name.eq_ignore_ascii_case(cmd_name));
                // Treat built-ins via the standard path below to preserve existing ack flow,
                // but allow any other saved subagent command to be executed here.
                let is_builtin = matches!(
                    cmd_name.to_ascii_lowercase().as_str(),
                    "plan" | "solve" | "code"
                );
                if has_custom && !is_builtin {
                    let res = code_core::slash_commands::format_subagent_command(
                        cmd_name,
                        &args,
                        Some(&self.config.agents),
                        Some(&self.config.subagent_commands),
                    );
                    // Acknowledge configuration
                    let mode = if res.read_only { "read-only" } else { "write" };
                    let agents = if res.models.is_empty() {
                        "<none>".to_string()
                    } else {
                        res.models.join(", ")
                    };
                    let lines = vec![
                        format!("/{} configured", res.name),
                        format!("mode: {}", mode),
                        format!("agents: {}", agents),
                        format!("command: {}", original_text.trim()),
                    ];
                    self.history_push_plain_paragraphs(PlainMessageKind::Notice, lines);

                    message
                        .ordered_items
                        .clear();
                    message
                        .ordered_items
                        .push(InputItem::Text { text: res.prompt });
                    // Continue with normal submission after this match block
                }
            }
        }

        let processed = crate::slash_command::process_slash_command_message(&text_only);
        match processed {
            crate::slash_command::ProcessedCommand::ExpandedPrompt(_expanded) => {
                // If a built-in multi-agent slash command was used, resolve
                // configured subagent settings and feed the synthesized prompt
                // without echoing an additional acknowledgement cell.
                let trimmed = original_trimmed;
                let (cmd_name, args_opt) = if let Some(rest) = trimmed.strip_prefix("/plan ") {
                    ("plan", Some(rest.trim().to_string()))
                } else if let Some(rest) = trimmed.strip_prefix("/solve ") {
                    ("solve", Some(rest.trim().to_string()))
                } else if let Some(rest) = trimmed.strip_prefix("/code ") {
                    ("code", Some(rest.trim().to_string()))
                } else {
                    ("", None)
                };

                if let Some(task) = args_opt {
                    let res = code_core::slash_commands::format_subagent_command(
                        cmd_name,
                        &task,
                        Some(&self.config.agents),
                        Some(&self.config.subagent_commands),
                    );

                    // Replace the message with the resolved prompt and suppress the
                    // agent launch hint that would otherwise echo back immediately.
                    self.suppress_next_agent_hint = true;
                    message
                        .ordered_items
                        .clear();
                    message
                        .ordered_items
                        .push(InputItem::Text { text: res.prompt });
                } else {
                    // Fallback to default expansion behavior
                    let expanded = _expanded;
                    message
                        .ordered_items
                        .clear();
                    message
                        .ordered_items
                        .push(InputItem::Text { text: expanded });
                }
            }
            crate::slash_command::ProcessedCommand::RegularCommand(cmd, command_text) => {
                if cmd == SlashCommand::Undo {
                    self.handle_undo_command();
                    return;
                }
                // This is a regular slash command, dispatch it normally
                self.app_event_tx
                    .send(AppEvent::DispatchCommand(cmd, command_text));
                return;
            }
            crate::slash_command::ProcessedCommand::Error(error_msg) => {
                // Show error in history
                self.history_push_plain_state(history_cell::new_error_event(error_msg));
                return;
            }
            crate::slash_command::ProcessedCommand::NotCommand(_) => {
                // Not a slash command, process normally
            }
        }

        let mut items: Vec<InputItem> = Vec::new();

        // Check if browser mode is enabled and capture screenshot
        // IMPORTANT: Always use global browser manager for consistency
        // The global browser manager ensures both TUI and agent tools use the same instance

        // We need to check if browser is enabled first
        // Use a channel to check browser status from async context
        let (status_tx, status_rx) = std::sync::mpsc::channel();
        tokio::spawn(async move {
            let browser_manager = ChatWidget::get_browser_manager().await;
            let enabled = browser_manager.is_enabled().await;
            let _ = status_tx.send(enabled);
        });

        let browser_enabled = status_rx.recv().unwrap_or(false);

        // Start async screenshot capture in background (non-blocking)
        if browser_enabled {
            tracing::info!("Browser is enabled, starting async screenshot capture...");

            // Clone necessary data for the async task
            let latest_browser_screenshot_clone = Arc::clone(&self.latest_browser_screenshot);

            tokio::spawn(async move {
                tracing::info!("Starting background screenshot capture...");

                // Rate-limit: skip if a capture ran very recently (< 4000ms)
                let now_ms = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis() as u64;
                let last = BG_SHOT_LAST_START_MS.load(Ordering::Relaxed);
                if now_ms.saturating_sub(last) < 4000 {
                    tracing::info!("Skipping background screenshot: rate-limited");
                    return;
                }

                // Single-flight: skip if another capture is in progress
                if BG_SHOT_IN_FLIGHT.swap(true, Ordering::AcqRel) {
                    tracing::info!("Skipping background screenshot: already in-flight");
                    return;
                }
                BG_SHOT_LAST_START_MS.store(now_ms, Ordering::Relaxed);
                // Ensure we always clear the flag
                struct ShotGuard;
                impl Drop for ShotGuard {
                    fn drop(&mut self) {
                        BG_SHOT_IN_FLIGHT.store(false, Ordering::Release);
                    }
                }
                let _guard = ShotGuard;

                // Short settle to allow page to reach a stable state; keep it small
                tokio::time::sleep(tokio::time::Duration::from_millis(800)).await;

                let browser_manager = ChatWidget::get_browser_manager().await;

                // Retry screenshot capture with exponential backoff
                // Keep background capture lightweight: single attempt with a modest timeout
                let mut attempts = 0;
                let max_attempts = 1;

                loop {
                    attempts += 1;
                    tracing::info!(
                        "Screenshot capture attempt {} of {}",
                        attempts,
                        max_attempts
                    );

                    // Add timeout to screenshot capture
                    let capture_result = tokio::time::timeout(
                        tokio::time::Duration::from_secs(5),
                        browser_manager.capture_screenshot_with_url(),
                    )
                    .await;

                    match capture_result {
                        Ok(Ok((screenshot_paths, url))) => {
                            tracing::info!(
                                "Background screenshot capture succeeded with {} images on attempt {}",
                                screenshot_paths.len(),
                                attempts
                            );

                            // Save the first screenshot path and URL for display in the TUI
                            if let Some(first_path) = screenshot_paths.first() {
                                if let Ok(mut latest) = latest_browser_screenshot_clone.lock() {
                                    let url_string =
                                        url.clone().unwrap_or_else(|| "Browser".to_string());
                                    *latest = Some((first_path.clone(), url_string));
                                }
                            }

                            // Create screenshot items
                            let mut screenshot_items = Vec::new();
                            for path in screenshot_paths {
                                if path.exists() {
                                    tracing::info!("Adding browser screenshot: {}", path.display());
                                    let timestamp = std::time::SystemTime::now()
                                        .duration_since(std::time::UNIX_EPOCH)
                                        .unwrap_or_default()
                                        .as_secs();
                                    let metadata = format!(
                                        "screenshot:{}:{}",
                                        timestamp,
                                        url.as_deref().unwrap_or("unknown")
                                    );
                                    screenshot_items.push(InputItem::EphemeralImage {
                                        path,
                                        metadata: Some(metadata),
                                    });
                                }
                            }

                            // Do not enqueue screenshots as messages.
                            // They are now injected per-turn by the core session.
                            break; // Success - exit retry loop
                        }
                        Ok(Err(e)) => {
                            tracing::warn!(
                                "Background screenshot capture failed (attempt {}): {}",
                                attempts,
                                e
                            );
                            break;
                        }
                        Err(_timeout_err) => {
                            tracing::warn!(
                                "Background screenshot capture timed out (attempt {})",
                                attempts
                            );
                            break;
                        }
                    }
                }
            });
        } else {
            tracing::info!("Browser is not enabled, skipping screenshot capture");
        }

        // Use the ordered items (text + images interleaved with markers)
        items.extend(message.ordered_items.clone());
        message.ordered_items = items;

        if message.ordered_items.is_empty() {
            return;
        }

        let turn_active = self.is_task_running()
            || !self.active_task_ids.is_empty()
            || self.stream.is_write_cycle_active()
            || !self.queued_user_messages.is_empty();

        if turn_active {
            tracing::info!(
                "Queuing user input while turn is active (queued: {})",
                self.queued_user_messages.len() + 1
            );
            let queued_clone = message.clone();
            self.queued_user_messages.push_back(queued_clone);
            self.refresh_queued_user_messages();

            let prompt_summary = if message.display_text.trim().is_empty() {
                None
            } else {
                Some(message.display_text.clone())
            };

            match self.capture_ghost_snapshot(prompt_summary) {
                GhostSnapshotJobHandle::Scheduled(job_id) => {
                    self.pending_snapshot_dispatches
                        .push_back(PendingSnapshotDispatch::Queued { job_id, message });
                }
                GhostSnapshotJobHandle::Skipped => {
                    self.dispatch_queued_user_message_now(message);
                }
            }
            return;
        }

        let queued_clone = message.clone();
        self.queued_user_messages.push_back(queued_clone);
        self.refresh_queued_user_messages();

        let batch: Vec<UserMessage> = self.queued_user_messages.iter().cloned().collect();
        let summary = batch
            .last()
            .and_then(|msg| {
                let trimmed = msg.display_text.trim();
                if trimmed.is_empty() {
                    None
                } else {
                    Some(msg.display_text.clone())
                }
            });

        let _ = self.capture_ghost_snapshot(summary);

        self.dispatch_queued_batch(batch);

        // (debug watchdog removed)
    }

    fn split_leading_slash_command(text: &str) -> Option<(String, String)> {
        if !text.starts_with('/') {
            return None;
        }
        let mut parts = text.splitn(2, '\n');
        let first_line = parts.next().unwrap_or_default();
        let rest = parts.next().unwrap_or("");
        if rest.is_empty() {
            return None;
        }
        let command = first_line.trim_end_matches('\r');
        if command.is_empty() {
            return None;
        }
        if rest.trim().is_empty() {
            return None;
        }
        Some((command.to_string(), rest.to_string()))
    }

    fn capture_ghost_snapshot(&mut self, summary: Option<String>) -> GhostSnapshotJobHandle {
        if self.ghost_snapshots_disabled {
            return GhostSnapshotJobHandle::Skipped;
        }

        let request = GhostSnapshotRequest::new(
            summary,
            self.current_conversation_snapshot(),
            self.history_snapshot_for_persistence(),
        );
        self.enqueue_ghost_snapshot(request)
    }

    fn capture_ghost_snapshot_blocking(&mut self, summary: Option<String>) -> Option<GhostSnapshot> {
        if self.ghost_snapshots_disabled {
            return None;
        }

        let request = GhostSnapshotRequest::new(
            summary,
            self.current_conversation_snapshot(),
            self.history_snapshot_for_persistence(),
        );
        let repo_path = self.config.cwd.clone();
        let started_at = request.started_at;
        let result = create_ghost_commit(&CreateGhostCommitOptions::new(repo_path.as_path()));
        let elapsed = started_at.elapsed();
        let snapshot = self.finalize_ghost_snapshot(request, result, elapsed);
        snapshot
    }

    fn dispatch_pending_snapshot(&mut self, job_id: u64) {
        let Some(position) = self
            .pending_snapshot_dispatches
            .iter()
            .position(|pending| pending.job_id() == job_id)
        else {
            return;
        };

        let Some(pending) = self.pending_snapshot_dispatches.remove(position) else {
            return;
        };
        self.process_snapshot_dispatch(pending);
    }

    fn flush_pending_snapshot_dispatches(&mut self) {
        while let Some(pending) = self.pending_snapshot_dispatches.pop_front() {
            self.process_snapshot_dispatch(pending);
        }
    }

    fn process_snapshot_dispatch(&mut self, pending: PendingSnapshotDispatch) {
        match pending {
            PendingSnapshotDispatch::Queued { message, .. } => {
                self.dispatch_queued_user_message_now(message);
            }
        }
    }

    fn dispatch_queued_batch(&mut self, batch: Vec<UserMessage>) {
        if batch.is_empty() {
            return;
        }

        let mut messages: Vec<UserMessage> = Vec::with_capacity(batch.len());

        for message in batch {
            let Some(message) = self.take_queued_user_message(&message) else {
                tracing::info!("Skipping queued user input removed before dispatch");
                continue;
            };
            messages.push(message);
        }

        if messages.is_empty() {
            return;
        }

        let mut combined_items: Vec<InputItem> = Vec::new();

        for (idx, message) in messages.iter().enumerate() {
            if idx > 0 && !combined_items.is_empty() && !message.ordered_items.is_empty() {
                combined_items.push(InputItem::Text {
                    text: "\n\n".to_string(),
                });
            }
            combined_items.extend(message.ordered_items.clone());
        }

        let total_items = combined_items.len();
        let ephemeral_count = combined_items
            .iter()
            .filter(|item| matches!(item, InputItem::EphemeralImage { .. }))
            .count();
        if ephemeral_count > 0 {
            tracing::info!(
                "Sending {} items to model (including {} ephemeral images)",
                total_items,
                ephemeral_count
            );
        }

        if !combined_items.is_empty() {
            self.flush_pending_agent_notes();
            if let Err(e) = self
                .code_op_tx
                .send(Op::UserInput {
                    items: combined_items,
                })
            {
                tracing::error!("failed to send Op::UserInput: {e}");
            }
        }

        for message in messages {
            self.finalize_sent_user_message(message);
        }
    }

    fn dispatch_queued_user_message_now(&mut self, message: UserMessage) {
        let message = self.take_queued_user_message(&message).unwrap_or(message);
        let items = message.ordered_items.clone();
        match self.code_op_tx.send(Op::QueueUserInput { items }) {
            Ok(()) => {
                self.finalize_sent_user_message(message);
            }
            Err(err) => {
                tracing::error!("failed to send QueueUserInput op: {err}");
                self.queued_user_messages.push_front(message);
                self.refresh_queued_user_messages();
            }
        }
    }

    fn take_queued_user_message(&mut self, target: &UserMessage) -> Option<UserMessage> {
        let position = self
            .queued_user_messages
            .iter()
            .position(|message| message == target)?;
        let removed = self.queued_user_messages.remove(position)?;
        self.refresh_queued_user_messages();
        Some(removed)
    }

    fn enqueue_ghost_snapshot(&mut self, request: GhostSnapshotRequest) -> GhostSnapshotJobHandle {
        let job_id = self.next_ghost_snapshot_id;
        self.next_ghost_snapshot_id = self.next_ghost_snapshot_id.wrapping_add(1);
        self.ghost_snapshot_queue.push_back((job_id, request));
        self.spawn_next_ghost_snapshot();
        GhostSnapshotJobHandle::Scheduled(job_id)
    }

    fn spawn_next_ghost_snapshot(&mut self) {
        if self.ghost_snapshots_disabled {
            self.ghost_snapshot_queue.clear();
            return;
        }
        if self.active_ghost_snapshot.is_some() {
            return;
        }
        let Some((job_id, request)) = self.ghost_snapshot_queue.pop_front() else {
            return;
        };

        let repo_path = self.config.cwd.clone();
        let app_event_tx = self.app_event_tx.clone();
        let notice_ticket = self.make_background_tail_ticket();
        let started_at = request.started_at;
        self.active_ghost_snapshot = Some((job_id, request));

        tokio::spawn(async move {
            let handle = tokio::task::spawn_blocking(move || {
                let options = CreateGhostCommitOptions::new(repo_path.as_path());
                create_ghost_commit(&options)
            });
            tokio::pin!(handle);

            let mut notice_sent = false;
            let notice_sleep = tokio::time::sleep(GHOST_SNAPSHOT_NOTICE_THRESHOLD);
            tokio::pin!(notice_sleep);
            let timeout_sleep = tokio::time::sleep(GHOST_SNAPSHOT_TIMEOUT);
            tokio::pin!(timeout_sleep);

            let join_result = loop {
                tokio::select! {
                    res = &mut handle => break res,
                    _ = &mut timeout_sleep => {
                        handle.as_mut().abort();
                        let elapsed = started_at.elapsed();
                        let err = GitToolingError::Io(io::Error::new(
                            io::ErrorKind::TimedOut,
                            format!(
                                "ghost snapshot exceeded {}",
                                format_duration(GHOST_SNAPSHOT_TIMEOUT)
                            ),
                        ));
                        let event = AppEvent::GhostSnapshotFinished {
                            job_id,
                            result: Err(err),
                            elapsed,
                        };
                        app_event_tx.send(event);
                        return;
                    }
                    _ = &mut notice_sleep, if !notice_sent => {
                        notice_sent = true;
                        let elapsed = started_at.elapsed();
                        let message = format!(
                            "Git snapshot still running… {} elapsed.",
                            format_duration(elapsed)
                        );
                        app_event_tx.send_background_event_with_ticket(&notice_ticket, message);
                    }
                }
            };

            let elapsed = started_at.elapsed();
            let event = match join_result {
                Ok(Ok(commit)) => AppEvent::GhostSnapshotFinished {
                    job_id,
                    result: Ok(commit),
                    elapsed,
                },
                Ok(Err(err)) => AppEvent::GhostSnapshotFinished {
                    job_id,
                    result: Err(err),
                    elapsed,
                },
                Err(join_err) => {
                    let err = GitToolingError::Io(io::Error::new(
                        io::ErrorKind::Other,
                        format!("ghost snapshot task failed: {join_err}"),
                    ));
                    AppEvent::GhostSnapshotFinished {
                        job_id,
                        result: Err(err),
                        elapsed,
                    }
                }
            };

            app_event_tx.send(event);
        });
    }

    fn finalize_ghost_snapshot(
        &mut self,
        request: GhostSnapshotRequest,
        result: Result<GhostCommit, GitToolingError>,
        elapsed: Duration,
    ) -> Option<GhostSnapshot> {
        match result {
            Ok(commit) => {
                self.ghost_snapshots_disabled = false;
                self.ghost_snapshots_disabled_reason = None;
                let snapshot = GhostSnapshot::new(
                    commit,
                    request.summary,
                    request.conversation,
                    request.history,
                );
                self.ghost_snapshots.push(snapshot.clone());
                session_log::log_history_snapshot(
                    snapshot.commit().id(),
                    snapshot.summary.as_deref(),
                    &snapshot.history,
                );
                if self.ghost_snapshots.len() > MAX_TRACKED_GHOST_COMMITS {
                    self.ghost_snapshots.remove(0);
                }
                if elapsed >= GHOST_SNAPSHOT_NOTICE_THRESHOLD {
                    self.push_background_tail(format!(
                        "Git snapshot captured in {}.",
                        format_duration(elapsed)
                    ));
                }
                Some(snapshot)
            }
            Err(err) => {
                if let GitToolingError::Io(io_err) = &err {
                    if io_err.kind() == io::ErrorKind::TimedOut {
                        self.push_background_tail(format!(
                            "Git snapshot timed out after {}. Try again once the repository is less busy.",
                            format_duration(elapsed)
                        ));
                        tracing::warn!(
                            elapsed = %format_duration(elapsed),
                            "ghost snapshot timed out"
                        );
                        return None;
                    }
                }
                self.ghost_snapshots_disabled = true;
                let (message, hint) = match &err {
                    GitToolingError::NotAGitRepository { .. } => (
                        "Snapshots disabled: this workspace is not inside a Git repository.".to_string(),
                        None,
                    ),
                    _ => (
                        format!("Snapshots disabled after Git error: {err}"),
                        Some(
                            "Restart Code after resolving the issue to re-enable snapshots.".to_string(),
                        ),
                    ),
                };
                self.ghost_snapshots_disabled_reason = Some(GhostSnapshotsDisabledReason {
                    message: message.clone(),
                    hint: hint.clone(),
                });
                self.push_background_tail(message);
                if let Some(hint) = hint {
                    self.push_background_tail(hint);
                }
                tracing::warn!("failed to create ghost snapshot: {err}");
                self.ghost_snapshot_queue.clear();
                None
            }
        }
    }

    pub(crate) fn handle_ghost_snapshot_finished(
        &mut self,
        job_id: u64,
        result: Result<GhostCommit, GitToolingError>,
        elapsed: Duration,
    ) {
        let Some((active_id, request)) = self.active_ghost_snapshot.take() else {
            tracing::warn!("ghost snapshot finished without active job (id={job_id})");
            return;
        };

        if active_id != job_id {
            tracing::warn!(
                "ghost snapshot job id mismatch: expected {active_id}, got {job_id}"
            );
            self.active_ghost_snapshot = Some((active_id, request));
            return;
        }

        let snapshot = self.finalize_ghost_snapshot(request, result, elapsed);
        self.request_redraw();
        self.dispatch_pending_snapshot(job_id);
        if snapshot.is_none() {
            self.flush_pending_snapshot_dispatches();
        }
        self.spawn_next_ghost_snapshot();
    }

    fn current_conversation_snapshot(&self) -> ConversationSnapshot {
        use crate::history_cell::HistoryCellType;
        let mut user_turns = 0usize;
        let mut assistant_turns = 0usize;
        for cell in &self.history_cells {
            match cell.kind() {
                HistoryCellType::User => user_turns = user_turns.saturating_add(1),
                HistoryCellType::Assistant => {
                    assistant_turns = assistant_turns.saturating_add(1)
                }
                _ => {}
            }
        }
        let mut snapshot = ConversationSnapshot::new(user_turns, assistant_turns);
        snapshot.history_len = self.history_cells.len();
        snapshot.order_len = self.cell_order_seq.len();
        snapshot.order_dbg_len = self.cell_order_dbg.len();
        snapshot
    }

    fn conversation_delta_since(
        &self,
        snapshot: &ConversationSnapshot,
    ) -> (usize, usize) {
        let current = self.current_conversation_snapshot();
        let user_delta = current
            .user_turns
            .saturating_sub(snapshot.user_turns);
        let assistant_delta = current
            .assistant_turns
            .saturating_sub(snapshot.assistant_turns);
        (user_delta, assistant_delta)
    }

    fn history_snapshot_for_persistence(&self) -> HistorySnapshot {
        let order: Vec<OrderKeySnapshot> = self
            .cell_order_seq
            .iter()
            .map(|key| (*key).into())
            .collect();
        let order_debug = self.cell_order_dbg.clone();
        self.history_state
            .snapshot()
            .with_order(order, order_debug)
    }

    fn mark_history_dirty(&mut self) {
        self.history_snapshot_dirty = true;
        self.flush_history_snapshot_if_needed(true);
    }

    fn flush_history_snapshot_if_needed(&mut self, force: bool) {
        if !self.history_snapshot_dirty {
            return;
        }
        if !force {
            if let Some(last) = self.history_snapshot_last_flush {
                if last.elapsed() < Duration::from_millis(400) {
                    return;
                }
            }
        }
        let snapshot = self.history_snapshot_for_persistence();
        match serde_json::to_value(&snapshot) {
            Ok(snapshot_value) => {
                let send_result = self
                    .code_op_tx
                    .send(Op::PersistHistorySnapshot { snapshot: snapshot_value });
                if send_result.is_err() {
                    tracing::warn!("failed to send history snapshot to core");
                } else {
                    self.history_snapshot_dirty = false;
                }
                self.history_snapshot_last_flush = Some(Instant::now());
            }
            Err(err) => {
                tracing::warn!("failed to serialize history snapshot: {err}");
            }
        }
    }

    pub(crate) fn snapshot_ghost_state(&self) -> GhostState {
        GhostState {
            snapshots: self.ghost_snapshots.clone(),
            disabled: self.ghost_snapshots_disabled,
            disabled_reason: self.ghost_snapshots_disabled_reason.clone(),
            queue: self.ghost_snapshot_queue.clone(),
            active: self.active_ghost_snapshot.clone(),
            next_id: self.next_ghost_snapshot_id,
            pending_dispatches: self.pending_snapshot_dispatches.clone(),
            queued_user_messages: self.queued_user_messages.clone(),
        }
    }

    pub(crate) fn adopt_ghost_state(&mut self, state: GhostState) {
        self.ghost_snapshots = state.snapshots;
        if self.ghost_snapshots.len() > MAX_TRACKED_GHOST_COMMITS {
            self.ghost_snapshots
                .truncate(MAX_TRACKED_GHOST_COMMITS);
        }
        self.ghost_snapshots_disabled = state.disabled;
        self.ghost_snapshots_disabled_reason = state.disabled_reason;
        self.ghost_snapshot_queue = state.queue;
        self.active_ghost_snapshot = state.active;
        self.next_ghost_snapshot_id = state.next_id;
        self.pending_snapshot_dispatches = state.pending_dispatches;
        self.queued_user_messages = state.queued_user_messages;
        self.refresh_queued_user_messages();
        self.spawn_next_ghost_snapshot();
    }

    pub(crate) fn handle_undo_command(&mut self) {
        if self.ghost_snapshots_disabled {
            let reason = self
                .ghost_snapshots_disabled_reason
                .as_ref()
                .map(|reason| reason.message.clone())
                .unwrap_or_else(|| "Snapshots are currently disabled.".to_string());
            self.push_background_tail(format!("/undo unavailable: {reason}"));
            self.show_undo_snapshots_disabled();
            return;
        }

        if self.ghost_snapshots.is_empty() {
            self.push_background_tail(
                "/undo unavailable: no snapshots captured yet. Run a file-modifying command to create one.".to_string(),
            );
            self.show_undo_empty_state();
            return;
        }

        self.show_undo_snapshot_picker();
    }

    fn show_undo_snapshots_disabled(&mut self) {
        let mut lines: Vec<String> = Vec::new();
        if let Some(reason) = &self.ghost_snapshots_disabled_reason {
            lines.push(reason.message.clone());
            if let Some(hint) = &reason.hint {
                lines.push(hint.clone());
            }
        } else {
            lines.push(
                "Snapshots are currently disabled. Resolve the Git issue and restart Code to re-enable them.".to_string(),
            );
        }

        self.show_undo_status_popup(
            "Snapshots unavailable",
            Some(
                "Restores workspace files only. Conversation history remains unchanged.".to_string(),
            ),
            Some("Automatic snapshotting failed, so /undo cannot restore the workspace.".to_string()),
            lines,
        );
    }

    fn show_undo_empty_state(&mut self) {
        self.show_undo_status_popup(
            "No snapshots yet",
            Some(
                "Restores workspace files only. Conversation history remains unchanged.".to_string(),
            ),
            Some("Snapshots appear once Code captures a Git checkpoint.".to_string()),
            vec![
                "No snapshot is available to restore.".to_string(),
                "Run a command that modifies files to create the first snapshot.".to_string(),
            ],
        );
    }

    fn show_undo_status_popup(
        &mut self,
        title: &str,
        scope_hint: Option<String>,
        subtitle: Option<String>,
        mut lines: Vec<String>,
    ) {
        if lines.is_empty() {
            lines.push("No snapshot information available.".to_string());
        }

        let headline = lines.remove(0);
        let description = if lines.is_empty() {
            None
        } else {
            Some(lines.join("\n"))
        };

        let mut composed_subtitle = Vec::new();
        if let Some(hint) = scope_hint {
            composed_subtitle.push(hint);
        }
        if let Some(extra) = subtitle {
            composed_subtitle.push(extra);
        }
        let subtitle_for_view = if composed_subtitle.is_empty() {
            None
        } else {
            Some(composed_subtitle.join("\n"))
        };

        let items = vec![SelectionItem {
            name: headline,
            description,
            is_current: true,
            actions: Vec::new(),
        }];

        let view = ListSelectionView::new(
            format!(" {title} "),
            subtitle_for_view,
            Some("Esc close".to_string()),
            items,
            self.app_event_tx.clone(),
            1,
        );

        self.bottom_pane.show_list_selection(
            title.to_string(),
            None,
            Some("Esc close".to_string()),
            view,
        );
    }

    fn show_undo_snapshot_picker(&mut self) {
        let entries = self.build_undo_timeline_entries();
        if entries.len() <= 1 {
            self.push_background_tail(
                "/undo unavailable: no snapshots captured yet. Run a file-modifying command to create one.".to_string(),
            );
            self.show_undo_empty_state();
            return;
        }

        let current_index = entries.len().saturating_sub(1);
        let view = UndoTimelineView::new(entries, current_index, self.app_event_tx.clone());
        self.bottom_pane.show_undo_timeline_view(view);
    }

    fn build_undo_timeline_entries(&self) -> Vec<UndoTimelineEntry> {
        let mut entries: Vec<UndoTimelineEntry> = Vec::with_capacity(self.ghost_snapshots.len().saturating_add(1));
        for snapshot in self.ghost_snapshots.iter() {
            entries.push(self.timeline_entry_for_snapshot(snapshot));
        }
        entries.push(self.timeline_entry_for_current());
        entries
    }

    fn timeline_entry_for_snapshot(&self, snapshot: &GhostSnapshot) -> UndoTimelineEntry {
        let short_id = snapshot.short_id();
        let label = format!("Snapshot {short_id}");
        let summary = snapshot.summary.clone();
        let timestamp_line = Some(snapshot.captured_at.format("%Y-%m-%d %H:%M:%S").to_string());
        let relative_time = snapshot
            .age_from(Local::now())
            .map(|age| format!("captured {} ago", format_duration(age)));
        let (user_delta, assistant_delta) = self.conversation_delta_since(&snapshot.conversation);
        let stats_line = if user_delta == 0 && assistant_delta == 0 {
            Some("conversation already matches current state".to_string())
        } else if assistant_delta == 0 {
            Some(format!(
                "rewind {} user turn{}",
                user_delta,
                if user_delta == 1 { "" } else { "s" }
            ))
        } else {
            Some(format!(
                "rewind {} user turn{} and {} assistant repl{}",
                user_delta,
                if user_delta == 1 { "" } else { "s" },
                assistant_delta,
                if assistant_delta == 1 { "y" } else { "ies" }
            ))
        };

        let conversation_lines = Self::conversation_preview_lines_from_snapshot(&snapshot.history);
        let file_lines = self.timeline_file_lines_for_commit(snapshot.commit().id());

        UndoTimelineEntry {
            label,
            summary,
            timestamp_line,
            relative_time,
            stats_line,
            commit_line: Some(format!("commit {short_id}")),
            conversation_lines,
            file_lines,
            conversation_available: user_delta > 0,
            files_available: true,
            kind: UndoTimelineEntryKind::Snapshot {
                commit: snapshot.commit().id().to_string(),
            },
        }
    }

    fn timeline_entry_for_current(&self) -> UndoTimelineEntry {
        let history_snapshot = self.history_snapshot_for_persistence();
        let conversation_lines = Self::conversation_preview_lines_from_snapshot(&history_snapshot);
        let file_lines = self.timeline_file_lines_for_current();
        UndoTimelineEntry {
            label: "Current workspace".to_string(),
            summary: None,
            timestamp_line: Some(Local::now().format("%Y-%m-%d %H:%M:%S").to_string()),
            relative_time: Some("current point".to_string()),
            stats_line: Some("Already at this point in time".to_string()),
            commit_line: None,
            conversation_lines,
            file_lines,
            conversation_available: false,
            files_available: false,
            kind: UndoTimelineEntryKind::Current,
        }
    }

    fn conversation_preview_lines_from_snapshot(snapshot: &HistorySnapshot) -> Vec<Line<'static>> {
        let mut state = HistoryState::new();
        state.restore(snapshot);
        let mut messages: Vec<(UndoPreviewRole, String)> = Vec::new();
        for record in &state.records {
            match record {
                HistoryRecord::PlainMessage(msg) => match msg.kind {
                    PlainMessageKind::User => {
                        let text = Self::message_lines_to_plain_preview(&msg.lines);
                        if !text.is_empty() {
                            messages.push((UndoPreviewRole::User, text));
                        }
                    }
                    PlainMessageKind::Assistant => {
                        let text = Self::message_lines_to_plain_preview(&msg.lines);
                        if !text.is_empty() {
                            messages.push((UndoPreviewRole::Assistant, text));
                        }
                    }
                    _ => {}
                },
                HistoryRecord::AssistantMessage(msg) => {
                    let text = Self::markdown_to_plain_preview(&msg.markdown);
                    if !text.is_empty() {
                        messages.push((UndoPreviewRole::Assistant, text));
                    }
                }
                _ => {}
            }
        }

        if messages.is_empty() {
            return vec![Line::from(Span::styled(
                "No conversation captured in this snapshot.",
                Style::default().fg(crate::colors::text_dim()),
            ))];
        }

        let len = messages.len();
        let start = len.saturating_sub(Self::MAX_UNDO_CONVERSATION_MESSAGES);
        messages[start..]
            .iter()
            .map(|(role, text)| Self::conversation_line(*role, text.as_str()))
            .collect()
    }

    fn conversation_line(role: UndoPreviewRole, text: &str) -> Line<'static> {
        let (label, color) = match role {
            UndoPreviewRole::User => ("You", crate::colors::text_bright()),
            UndoPreviewRole::Assistant => ("Code", crate::colors::primary()),
        };
        let label_span = Span::styled(
            format!("{label}: "),
            Style::default().fg(color).add_modifier(Modifier::BOLD),
        );
        let content_span = Span::styled(text.to_string(), Style::default().fg(crate::colors::text()));
        Line::from(vec![label_span, content_span])
    }

    fn message_lines_to_plain_preview(lines: &[MessageLine]) -> String {
        let mut segments: Vec<String> = Vec::new();
        for line in lines {
            match line.kind {
                MessageLineKind::Blank => continue,
                MessageLineKind::Metadata => continue,
                _ => {
                    let mut text = String::new();
                    for span in &line.spans {
                        text.push_str(&span.text);
                    }
                    let trimmed = text.trim();
                    if !trimmed.is_empty() {
                        segments.push(trimmed.to_string());
                    }
                }
            }
            if segments.len() >= Self::MAX_UNDO_CONVERSATION_MESSAGES {
                break;
            }
        }
        let joined = segments.join(" ");
        Self::truncate_preview_text(joined, Self::MAX_UNDO_PREVIEW_CHARS)
    }

    fn markdown_to_plain_preview(markdown: &str) -> String {
        let mut segments: Vec<String> = Vec::new();
        for line in markdown.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }
            if trimmed.starts_with('#') {
                segments.push(trimmed.trim_start_matches('#').trim().to_string());
            } else {
                segments.push(trimmed.to_string());
            }
            if segments.len() >= Self::MAX_UNDO_CONVERSATION_MESSAGES {
                break;
            }
        }
        if segments.is_empty() {
            return String::new();
        }
        let joined = segments.join(" ");
        Self::truncate_preview_text(joined, Self::MAX_UNDO_PREVIEW_CHARS)
    }

    fn truncate_preview_text(text: String, limit: usize) -> String {
        if text.chars().count() <= limit {
            return text;
        }
        let truncated: String = text.chars().take(limit.saturating_sub(1)).collect();
        format!("{truncated}…")
    }

    fn timeline_file_lines_for_commit(&self, commit_id: &str) -> Vec<Line<'static>> {
        match self.git_numstat(["show", "--numstat", "--format=", commit_id]) {
            Ok(entries) => Self::file_change_lines(entries),
            Err(err) => vec![Line::from(Span::styled(
                err,
                Style::default().fg(crate::colors::error()),
            ))],
        }
    }

    fn timeline_file_lines_for_current(&self) -> Vec<Line<'static>> {
        match self.git_numstat(["diff", "--numstat", "HEAD"]) {
            Ok(entries) => {
                if entries.is_empty() {
                    vec![Line::from(Span::styled(
                        "Working tree clean",
                        Style::default().fg(crate::colors::text_dim()),
                    ))]
                } else {
                    Self::file_change_lines(entries)
                }
            }
            Err(err) => vec![Line::from(Span::styled(
                err,
                Style::default().fg(crate::colors::error()),
            ))],
        }
    }

    fn git_numstat<I, S>(
        &self,
        args: I,
    ) -> Result<Vec<(Option<u32>, Option<u32>, String)>, String>
    where
        I: IntoIterator<Item = S>,
        S: AsRef<str>,
    {
        self.run_git_command(args, |stdout| {
            let mut out = Vec::new();
            for line in stdout.lines() {
                let trimmed = line.trim();
                if trimmed.is_empty() {
                    continue;
                }
                let mut parts = trimmed.splitn(3, '\t');
                let added = parts.next();
                let removed = parts.next();
                let path = parts.next();
                if let (Some(added), Some(removed), Some(path)) = (added, removed, path) {
                    out.push((
                        Self::parse_numstat_count(added),
                        Self::parse_numstat_count(removed),
                        path.to_string(),
                    ));
                }
            }
            Ok(out)
        })
    }

    fn run_git_command<I, S, F, T>(&self, args: I, parser: F) -> Result<T, String>
    where
        I: IntoIterator<Item = S>,
        S: AsRef<str>,
        F: FnOnce(String) -> Result<T, String>,
    {
        let args_vec: Vec<String> = args.into_iter().map(|s| s.as_ref().to_string()).collect();
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(&args_vec)
            .output()
            .map_err(|err| format!("git {} failed: {err}", args_vec.join(" ")))?;
        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            let msg = stderr.trim();
            if msg.is_empty() {
                Err(format!(
                    "git {} exited with status {}",
                    args_vec.join(" "),
                    output.status
                ))
            } else {
                Err(msg.to_string())
            }
        } else {
            parser(String::from_utf8_lossy(&output.stdout).to_string())
        }
    }

    fn parse_numstat_count(raw: &str) -> Option<u32> {
        if raw == "-" {
            None
        } else {
            raw.parse::<u32>().ok()
        }
    }

    fn file_change_lines(entries: Vec<(Option<u32>, Option<u32>, String)>) -> Vec<Line<'static>> {
        if entries.is_empty() {
            return vec![Line::from(Span::styled(
                "No file changes recorded for this snapshot.",
                Style::default().fg(crate::colors::text_dim()),
            ))];
        }

        let max_entries = (Self::MAX_UNDO_FILE_LINES / 2).max(1);
        let mut lines: Vec<Line<'static>> = Vec::new();
        for (idx, (added, removed, path)) in entries.iter().enumerate() {
            if idx >= max_entries {
                break;
            }
            lines.push(Line::from(Span::styled(
                path.clone(),
                Style::default().fg(crate::colors::text()),
            )));

            let added_text = added.map_or("-".to_string(), |v| v.to_string());
            let removed_text = removed.map_or("-".to_string(), |v| v.to_string());
            lines.push(Line::from(vec![
                Span::raw("    "),
                Span::styled(
                    format!("+{added_text}"),
                    Style::default().fg(crate::colors::success()),
                ),
                Span::raw("  "),
                Span::styled(
                    format!("-{removed_text}"),
                    Style::default().fg(crate::colors::error()),
                ),
            ]));
        }

        if entries.len() > max_entries {
            let remaining = entries.len() - max_entries;
            lines.push(Line::from(Span::styled(
                format!("… and {remaining} more file{}", if remaining == 1 { "" } else { "s" }),
                Style::default().fg(crate::colors::text_dim()),
            )));
        }

        lines
    }

    fn reset_resume_order_anchor(&mut self) {
        if self.history_cells.is_empty() {
            self.resume_expected_next_request = None;
        } else {
            let max_req = self
                .cell_order_seq
                .iter()
                .map(|key| key.req)
                .max()
                .unwrap_or(0);
            self.resume_expected_next_request = Some(max_req.saturating_add(1));
        }
        self.order_request_bias = 0;
        self.resume_provider_baseline = None;
    }

    pub(crate) fn restore_history_snapshot(&mut self, snapshot: &HistorySnapshot) {
        let perf_timer = self.perf_state.enabled.then(Instant::now);
        let preserved_system_entries: Vec<(String, HistoryId)> = self
            .system_cell_by_id
            .iter()
            .filter_map(|(key, &idx)| {
                self.history_cell_ids
                    .get(idx)
                    .and_then(|maybe| maybe.map(|hid| (key.clone(), hid)))
            })
            .collect();
        self.history_debug(format!(
            "restore_history_snapshot.start records={} cells_before={} order_before={}",
            snapshot.records.len(),
            self.history_cells.len(),
            self.cell_order_seq.len()
        ));
        self.history_state.restore(snapshot);

        self.history_render.invalidate_all();

        self.history_cells.clear();
        self.history_cell_ids.clear();
        self.cell_order_seq.clear();
        self.cell_order_dbg.clear();

        for record in &self.history_state.records {
            if let Some(mut cell) = self.build_cell_from_record(record) {
                let id = record.id();
                Self::assign_history_id_inner(&mut cell, id);
                self.history_cells.push(cell);
                self.history_cell_ids.push(Some(id));
            } else {
                tracing::warn!("unable to rebuild history cell for record id {:?}", record.id());
                let fallback = history_cell::new_background_event(format!(
                    "Restored snapshot missing renderer for record {:?}",
                    record.id()
                ));
                self.history_cells.push(Box::new(fallback));
                self.history_cell_ids.push(None);
            }
        }

        if !snapshot.order.is_empty() {
            self.cell_order_seq = snapshot
                .order
                .iter()
                .copied()
                .map(OrderKey::from)
                .collect();
        } else {
            self.cell_order_seq = self
                .history_cells
                .iter()
                .enumerate()
                .map(|(idx, _)| OrderKey {
                    req: (idx as u64).saturating_add(1),
                    out: i32::MAX,
                    seq: (idx as u64).saturating_add(1),
                })
                .collect();
        }

        if self.cell_order_seq.len() < self.history_cells.len() {
            let mut next_req = self
                .cell_order_seq
                .iter()
                .map(|key| key.req)
                .max()
                .unwrap_or(0);
            let mut next_seq = self
                .cell_order_seq
                .iter()
                .map(|key| key.seq)
                .max()
                .unwrap_or(0)
                .saturating_add(1);
            while self.cell_order_seq.len() < self.history_cells.len() {
                next_req = next_req.saturating_add(1);
                self.cell_order_seq.push(OrderKey {
                    req: next_req,
                    out: i32::MAX,
                    seq: next_seq,
                });
                next_seq = next_seq.saturating_add(1);
            }
        }

        if !snapshot.order_debug.is_empty() {
            self.cell_order_dbg = snapshot.order_debug.clone();
        }
        if self.cell_order_dbg.len() < self.history_cells.len() {
            self.cell_order_dbg
                .resize(self.history_cells.len(), None);
        }

        let max_req = self.cell_order_seq.iter().map(|key| key.req).max().unwrap_or(0);
        let max_seq = self.cell_order_seq.iter().map(|key| key.seq).max().unwrap_or(0);

        self.last_seen_request_index = max_req;
        self.current_request_index = max_req;
        self.internal_seq = max_seq;
        self.last_assigned_order = self.cell_order_seq.iter().copied().max();
        self.reset_resume_order_anchor();

        self.rebuild_ui_background_seq_counters();

        running_tools::rehydrate(self);
        self.rehydrate_system_order_cache(&preserved_system_entries);

        self.bottom_pane
            .set_has_chat_history(!self.history_cells.is_empty());
        self.refresh_reasoning_collapsed_visibility();
        self.refresh_explore_trailing_flags();
        self.invalidate_height_cache();
        self.request_redraw();

        if let (true, Some(started)) = (self.perf_state.enabled, perf_timer) {
            let elapsed = started.elapsed().as_nanos();
            self.perf_state
                .stats
                .borrow_mut()
                .record_undo_restore(elapsed);
        }
        self.history_snapshot_dirty = true;
        self.history_snapshot_last_flush = None;

        self.history_debug(format!(
            "restore_history_snapshot.done cells={} order={} system_cells={}",
            self.history_cells.len(),
            self.cell_order_seq.len(),
            self.system_cell_by_id.len()
        ));
    }

    pub(crate) fn perform_undo_restore(
        &mut self,
        commit: Option<&str>,
        restore_files: bool,
        restore_conversation: bool,
    ) {
        let Some(commit_id) = commit else {
            self.push_background_tail("No snapshot selected.".to_string());
            return;
        };

        let Some((index, snapshot)) = self
            .ghost_snapshots
            .iter()
            .enumerate()
            .find(|(_, snap)| snap.commit().id() == commit_id)
            .map(|(idx, snap)| (idx, snap.clone()))
        else {
            self.push_background_tail(
                "Selected snapshot is no longer available.".to_string(),
            );
            return;
        };

        if !restore_files && !restore_conversation {
            self.push_background_tail("No restore options selected.".to_string());
            return;
        }

        let mut files_restored = false;
        let mut conversation_rewind_requested = false;
        let mut errors: Vec<String> = Vec::new();
        let mut pre_restore_snapshot: Option<GhostSnapshot> = None;

        if restore_files {
            let previous_len = self.ghost_snapshots.len();
            let pre_summary = Some("Pre-undo checkpoint".to_string());
            let captured_snapshot = self.capture_ghost_snapshot_blocking(pre_summary);
            let added_snapshot = self.ghost_snapshots.len() > previous_len;
            if let Some(snapshot) = captured_snapshot {
                pre_restore_snapshot = Some(snapshot);
            }

            match restore_ghost_commit(&self.config.cwd, snapshot.commit()) {
                Ok(()) => {
                    files_restored = true;
                    self.ghost_snapshots.truncate(index);
                    if let Some(pre) = pre_restore_snapshot {
                        self.ghost_snapshots.push(pre);
                        if self.ghost_snapshots.len() > MAX_TRACKED_GHOST_COMMITS {
                            self.ghost_snapshots.remove(0);
                        }
                    }
                }
                Err(err) => {
                    if added_snapshot && !self.ghost_snapshots.is_empty() {
                        self.ghost_snapshots.pop();
                    }
                    errors.push(format!("Failed to restore workspace files: {err}"));
                }
            }
        }

        if restore_conversation {
            let (user_delta, assistant_delta) =
                self.conversation_delta_since(&snapshot.conversation);
            if user_delta == 0 {
                self.push_background_tail(
                    "Conversation already matches selected snapshot; nothing to rewind.".to_string(),
                );
            } else {
                self.app_event_tx.send(AppEvent::JumpBack {
                    nth: user_delta,
                    prefill: String::new(),
                    history_snapshot: Some(snapshot.history.clone()),
                });
                if assistant_delta > 0 {
                    self.push_background_tail(format!(
                        "Rewinding conversation by {} user turn{} and {} assistant repl{}",
                        user_delta,
                        if user_delta == 1 { "" } else { "s" },
                        assistant_delta,
                        if assistant_delta == 1 { "y" } else { "ies" }
                    ));
                } else {
                    self.push_background_tail(format!(
                        "Rewinding conversation by {} user turn{}",
                        user_delta,
                        if user_delta == 1 { "" } else { "s" }
                    ));
                }
                conversation_rewind_requested = true;
            }
        }

        for err in errors {
            self.history_push_plain_state(history_cell::new_error_event(err));
        }

        if files_restored {
            let mut message = format!("Restored workspace files to snapshot {}", snapshot.short_id());
            if let Some(snippet) = snapshot.summary_snippet(60) {
                message.push_str(&format!(" • {}", snippet));
            }
            if let Some(age) = snapshot.age_from(Local::now()) {
                message.push_str(&format!(" • captured {} ago", format_duration(age)));
            }
            if !restore_conversation {
                message.push_str(" • chat history unchanged");
            }
            self.push_background_tail(message);
        }

        if conversation_rewind_requested {
            // Conversation rewind will reload the chat widget via AppEvent::JumpBack.
            self.reset_after_conversation_restore();
        }

        self.request_redraw();
    }

    fn reset_after_conversation_restore(&mut self) {
        self.pending_dispatched_user_messages.clear();
        self.pending_user_prompts_for_next_turn = 0;
        self.queued_user_messages.clear();
        self.refresh_queued_user_messages();
        self.bottom_pane.clear_composer();
        self.bottom_pane.clear_ctrl_c_quit_hint();
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_task_running(false);
        self.active_task_ids.clear();
        if !self.agents_terminal.active {
            self.bottom_pane.ensure_input_focus();
        }
    }

    fn flush_pending_agent_notes(&mut self) {
        for note in self.pending_agent_notes.drain(..) {
            if let Err(e) = self.code_op_tx.send(Op::AddToHistory { text: note }) {
                tracing::error!("failed to send AddToHistory op: {e}");
            }
        }
    }

    fn finalize_sent_user_message(&mut self, message: UserMessage) {
        let UserMessage {
            display_text,
            ordered_items,
            suppress_persistence,
        } = message;

        let combined_message_text = {
            let mut buffer = String::new();
            for item in &ordered_items {
                if let InputItem::Text { text } = item {
                    if !buffer.is_empty() {
                        buffer.push('\n');
                    }
                    buffer.push_str(text);
                }
            }
            let trimmed = buffer.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_string())
            }
        };

        if !display_text.is_empty() {
            let key = self.next_req_key_prompt();
            let state = history_cell::new_user_prompt(display_text.clone());
            let _ = self.history_insert_plain_state_with_key(state, key, "prompt");
            self.pending_user_prompts_for_next_turn =
                self.pending_user_prompts_for_next_turn.saturating_add(1);
        }

        self.flush_pending_agent_notes();

        if let Some(model_echo) = combined_message_text {
            self.pending_dispatched_user_messages.push_back(model_echo);
        }

        let suppress_history = suppress_persistence;

        if !display_text.is_empty() && !suppress_history {
            if let Err(e) = self
                .code_op_tx
                .send(Op::AddToHistory { text: display_text })
            {
                tracing::error!("failed to send AddHistory op: {e}");
            }
        }

        if self.auto_state.is_active() && self.auto_state.resume_after_submit() {
            self.auto_state.on_prompt_submitted();
            self.auto_state.seconds_remaining = 0;
            self.auto_rebuild_live_ring();
            self.bottom_pane.update_status_text(String::new());
            self.bottom_pane.set_task_running(false);
        }

        self.request_redraw();
    }

    fn refresh_queued_user_messages(&mut self) {
        self.request_redraw();
    }

    #[allow(dead_code)]
    pub(crate) fn set_mouse_status_message(&mut self, message: &str) {
        self.bottom_pane.update_status_text(message.to_string());
    }

    pub(crate) fn handle_mouse_event(&mut self, mouse_event: crossterm::event::MouseEvent) {
        use crossterm::event::KeyModifiers;
        use crossterm::event::MouseEventKind;

        // Check if Shift is held - if so, let the terminal handle selection
        if mouse_event.modifiers.contains(KeyModifiers::SHIFT) {
            // Don't handle any mouse events when Shift is held
            // This allows the terminal's native text selection to work
            return;
        }

        match mouse_event.kind {
            MouseEventKind::ScrollUp => layout_scroll::mouse_scroll(self, true),
            MouseEventKind::ScrollDown => layout_scroll::mouse_scroll(self, false),
            _ => {
                // Ignore other mouse events for now
            }
        }
    }

    pub(crate) fn handle_code_event(&mut self, event: Event) {
        tracing::debug!(
            "handle_code_event({})",
            serde_json::to_string_pretty(&event).unwrap_or_default()
        );
        // Strict ordering: all LLM/tool events must carry OrderMeta; internal events use synthetic keys.
        // Track provider order to anchor internal inserts at the bottom of the active request.
        self.note_order(event.order.as_ref());

        let Event { id, msg, .. } = event.clone();
        match msg {
            EventMsg::SessionConfigured(event) => {
                // Remove stale "Connecting MCP servers…" status from the startup notice
                // now that MCP initialization has completed in core.
                self.remove_connecting_mcp_notice();
                // Record session id for potential future fork/backtrack features
                self.session_id = Some(event.session_id);
                self.bottom_pane
                    .set_history_metadata(event.history_log_id, event.history_entry_count);
                // Record session information at the top of the conversation.
                // If we already showed the startup prelude (Popular commands),
                // avoid inserting a duplicate. Still surface a notice if the
                // model actually changed from the requested one.
                let is_first = !self.welcome_shown;
                if is_first || self.config.model != event.model {
                    if is_first {
                        self.welcome_shown = true;
                    }
                    let session_state = history_cell::new_session_info(
                        &self.config,
                        event.clone(),
                        is_first,
                        self.latest_upgrade_version.as_deref(),
                    );
                    let key = self.next_req_key_top();
                    let _ = self
                        .history_insert_plain_state_with_key(session_state, key, "prelude");
                }

                if let Some(user_message) = self.initial_user_message.take() {
                    // If the user provided an initial message, add it to the
                    // conversation history.
                    self.submit_user_message(user_message);
                }

                if self.resume_placeholder_visible && event.history_entry_count == 0 {
                    self.replace_resume_placeholder_with_notice(RESUME_NO_HISTORY_NOTICE);
                }

                self.request_redraw();
                self.flush_history_snapshot_if_needed(true);
            }
            EventMsg::WebSearchBegin(ev) => {
                // Enforce order presence (tool events should carry it)
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on WebSearchBegin; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tracing::info!(
                    "[order] WebSearchBegin call_id={} seq={}",
                    ev.call_id,
                    event.event_seq
                );
                tools::web_search_begin(self, ev.call_id, ev.query, event.order.as_ref(), ok)
            }
            EventMsg::AgentMessage(AgentMessageEvent { message }) => {
                // If the user requested an interrupt, ignore late final answers.
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring AgentMessage after interrupt");
                    return;
                }
                self.stream_state.seq_answer_final = Some(event.event_seq);
                // Strict order for the stream id
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on AgentMessage; using synthetic key");
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Answer, &id, ok);

                tracing::debug!(
                    "AgentMessage final id={} bytes={} preview={:?}",
                    id,
                    message.len(),
                    message.chars().take(80).collect::<String>()
                );

                // Close out any running tool/exec indicators before inserting final answer.
                self.finalize_all_running_due_to_answer();

                // Route final message through streaming controller so AppEvent::InsertFinalAnswer
                // is the single source of truth for assistant content.
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                streaming::begin(self, StreamKind::Answer, Some(id.clone()));
                let _ = self.stream.apply_final_answer(&message, &sink);

                // Track last message for potential dedup heuristics.
                self.last_assistant_message = Some(message);
                // Mark this Answer stream id as closed for the rest of the turn so any late
                // AgentMessageDelta for the same id is ignored. In the full App runtime,
                // the InsertFinalAnswer path also marks closed; setting it here makes
                // unit tests (which do not route AppEvents back) behave identically.
                self.stream_state
                    .closed_answer_ids
                    .insert(StreamId(id.clone()));
                // Receiving a final answer means this task has finished even if we have not yet
                // observed the corresponding TaskComplete event. Clear the active marker now so
                // the status spinner can hide promptly when nothing else is running.
                self.active_task_ids.remove(&id);
                self.finalize_agent_activity();
                self.maybe_hide_spinner();
                // Important: do not advance Auto Drive here. The StreamController will emit
                // AppEvent::InsertFinalAnswer, and the App thread will finalize the assistant
                // cell slightly later. Advancing at this point can start the next Auto Drive
                // step before the final answer is actually inserted, which appears as a
                // mid-turn re-trigger. We instead advance immediately after insertion inside
                // insert_final_answer_with_id().
            }
            EventMsg::ReplayHistory(ev) => {
                self.clear_resume_placeholder();
                let code_core::protocol::ReplayHistoryEvent { items, history_snapshot } = ev;
                self.replay_history_depth = self.replay_history_depth.saturating_add(1);
                let max_req = self.last_seen_request_index;
                let mut processed_snapshot = false;
                if let Some(snapshot_value) = history_snapshot {
                    match serde_json::from_value::<HistorySnapshot>(snapshot_value) {
                        Ok(snapshot) => {
                            self.restore_history_snapshot(&snapshot);
                            self.flush_history_snapshot_if_needed(true);
                            processed_snapshot = true;
                        }
                        Err(err) => {
                            tracing::warn!("failed to deserialize replay snapshot: {err}");
                        }
                    }
                }
                if !processed_snapshot {
                    for item in &items {
                        self.render_replay_item(item.clone());
                    }
                    if !items.is_empty() {
                        self.last_seen_request_index =
                            self.last_seen_request_index.max(self.current_request_index);
                    }
                }
                if max_req > 0 {
                    self.last_seen_request_index = self.last_seen_request_index.max(max_req);
                    self.current_request_index = self.last_seen_request_index;
                }
                if processed_snapshot || !items.is_empty() {
                    self.reset_resume_order_anchor();
                }
                self.request_redraw();
                self.replay_history_depth = self.replay_history_depth.saturating_sub(1);
            }
            EventMsg::WebSearchComplete(ev) => {
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on WebSearchComplete; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tools::web_search_complete(self, ev.call_id, ev.query, event.order.as_ref(), ok)
            }
            EventMsg::AgentMessageDelta(AgentMessageDeltaEvent { delta }) => {
                tracing::debug!("AgentMessageDelta: {:?}", delta);
                // If the user requested an interrupt, ignore late deltas.
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring Answer delta after interrupt");
                    return;
                }
                // Ignore late deltas for ids that have already finalized in this turn
                if self
                    .stream_state
                    .closed_answer_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::debug!("Ignoring Answer delta for closed id={}", id);
                    return;
                }
                // Seed/refresh order key for this Answer stream id (must have OrderMeta)
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on AgentMessageDelta; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Answer, &id, ok);
                // Stream answer delta through StreamController
                streaming::delta_text(
                    self,
                    StreamKind::Answer,
                    id.clone(),
                    delta,
                    event.order.as_ref().and_then(|o| o.sequence_number),
                );
                // Show responding state while assistant streams
                self.bottom_pane
                    .update_status_text("responding".to_string());
            }
            EventMsg::AgentReasoning(AgentReasoningEvent { text }) => {
                // Ignore late reasoning if we've dropped streaming due to interrupt.
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring AgentReasoning after interrupt");
                    return;
                }
                tracing::debug!(
                    "AgentReasoning event with text: {:?}...",
                    text.chars().take(100).collect::<String>()
                );
                // Guard duplicates for this id within the task
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::warn!("Ignoring duplicate AgentReasoning for closed id={}", id);
                    return;
                }
                // Seed strict order key for this Reasoning stream
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on AgentReasoning; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tracing::info!("[order] EventMsg::AgentReasoning id={} key={:?}", id, ok);
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);
                // Fallback: if any tools/execs are still marked running, complete them now.
                self.finalize_all_running_due_to_answer();
                // Use StreamController for final reasoning
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                streaming::begin(self, StreamKind::Reasoning, Some(id.clone()));

                // The StreamController now properly handles duplicate detection and prevents
                // re-injecting content when we're already finishing a stream
                let _finished = self.stream.apply_final_reasoning(&text, &sink);
                // Stream finishing is handled by StreamController
                // Mark this id closed for further reasoning deltas in this turn
                self.stream_state
                    .closed_reasoning_ids
                    .insert(StreamId(id.clone()));
                // Clear in-progress flags on the most recent reasoning cell(s)
                if let Some(last) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                        .is_some()
                }) {
                    if let Some(reason) = self.history_cells[last]
                        .as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    {
                        reason.set_in_progress(false);
                    }
                }
                self.mark_needs_redraw();
            }
            EventMsg::AgentReasoningDelta(AgentReasoningDeltaEvent { delta }) => {
                tracing::debug!("AgentReasoningDelta: {:?}", delta);
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring Reasoning delta after interrupt");
                    return;
                }
                // Ignore late deltas for ids that have already finalized in this turn
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::debug!("Ignoring Reasoning delta for closed id={}", id);
                    return;
                }
                // Seed strict order key for this Reasoning stream
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on AgentReasoningDelta; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                tracing::info!(
                    "[order] EventMsg::AgentReasoningDelta id={} key={:?}",
                    id,
                    ok
                );
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);
                streaming::delta_text(
                    self,
                    StreamKind::Reasoning,
                    id.clone(),
                    delta,
                    event.order.as_ref().and_then(|o| o.sequence_number),
                );
                // Show thinking state while reasoning streams
                self.bottom_pane.update_status_text("thinking".to_string());
            }
            EventMsg::AgentReasoningSectionBreak(AgentReasoningSectionBreakEvent {}) => {
                // Insert section break in reasoning stream
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                self.stream.insert_reasoning_section_break(&sink);
            }
            EventMsg::TaskStarted => {
                // This begins the new turn; clear the pending prompt anchor count
                // so subsequent background events use standard placement.
                self.pending_user_prompts_for_next_turn = 0;
                // Reset stream headers for new turn
                self.stream.reset_headers_for_new_turn();
                self.stream_state.current_kind = None;
                // New turn: clear closed id guards
                self.stream_state.closed_answer_ids.clear();
                self.stream_state.closed_reasoning_ids.clear();
                self.ended_call_ids.clear();
                self.bottom_pane.clear_ctrl_c_quit_hint();
                // Accept streaming again for this turn
                self.stream_state.drop_streaming = false;
                // Mark this task id as active and ensure the status stays visible
                self.active_task_ids.insert(id.clone());
                // Reset per-turn UI indicators; ordering is now global-only
                self.reasoning_index.clear();
                self.bottom_pane.set_task_running(true);
                self.bottom_pane
                    .update_status_text("waiting for model".to_string());
                tracing::info!("[order] EventMsg::TaskStarted id={}", id);

                // Don't add loading cell - we have progress in the input area
                // self.add_to_history(history_cell::new_loading_cell("waiting for model".to_string()));

                self.mark_needs_redraw();
            }
            EventMsg::TaskComplete(TaskCompleteEvent { last_agent_message }) => {
                // Finalize any active streams
                if self.stream.is_write_cycle_active() {
                    // Finalize both streams via streaming facade
                    streaming::finalize(self, StreamKind::Reasoning, true);
                    streaming::finalize(self, StreamKind::Answer, true);
                }
                // Remove this id from the active set (it may be a sub‑agent)
                self.active_task_ids.remove(&id);
                if self.auto_resolve_enabled() {
                    self.auto_resolve_on_task_complete(last_agent_message.clone());
                }
                // Defensive: mark any lingering agent state as complete so the spinner can quiesce
                self.finalize_agent_activity();
                // Convert any lingering running exec/tool cells to completed so the UI doesn't hang
                self.finalize_all_running_due_to_answer();
                // Mark any running web searches as completed
                web_search_sessions::finalize_all_failed(
                    self,
                    "Search cancelled before completion",
                );
                // Now that streaming is complete, flush any queued interrupts
        self.flush_interrupt_queue();

        // Only drop the working status if nothing is actually running.
        let any_tools_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty();
                let any_streaming = self.stream.is_write_cycle_active();
                let any_agents_active = self.agents_are_actively_running();
                let any_tasks_active = !self.active_task_ids.is_empty();

                if !(any_tools_running || any_streaming || any_agents_active || any_tasks_active) {
                    self.bottom_pane.set_task_running(false);
                    // Ensure any transient footer text like "responding" is cleared when truly idle
                    self.bottom_pane.update_status_text(String::new());
                }
                self.stream_state.current_kind = None;
                // Final re-check for idle state
                self.maybe_hide_spinner();
                self.emit_turn_complete_notification(last_agent_message);
                self.suppress_next_agent_hint = false;
                self.mark_needs_redraw();
                self.flush_history_snapshot_if_needed(true);

                if self.should_schedule_auto_commit_review() {
                    self.spawn_auto_commit_review();
                }

            }
            EventMsg::AgentReasoningRawContentDelta(AgentReasoningRawContentDeltaEvent {
                delta,
            }) => {
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring RawContent delta after interrupt");
                    return;
                }
                // Treat raw reasoning content the same as summarized reasoning
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::debug!("Ignoring RawContent delta for closed id={}", id);
                    return;
                }
                // Seed strict order key for this reasoning stream id
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on Tools::PlanUpdate; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);

                streaming::delta_text(
                    self,
                    StreamKind::Reasoning,
                    id.clone(),
                    delta,
                    event.order.as_ref().and_then(|o| o.sequence_number),
                );
            }
            EventMsg::AgentReasoningRawContent(AgentReasoningRawContentEvent { text }) => {
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring AgentReasoningRawContent after interrupt");
                    return;
                }
                tracing::debug!(
                    "AgentReasoningRawContent event with text: {:?}...",
                    text.chars().take(100).collect::<String>()
                );
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::warn!(
                        "Ignoring duplicate AgentReasoningRawContent for closed id={}",
                        id
                    );
                    return;
                }
                // Seed strict order key now so upcoming insert uses the correct key.
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on Tools::ReasoningBegin; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);
                // Use StreamController for final raw reasoning
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                streaming::begin(self, StreamKind::Reasoning, Some(id.clone()));
                let _finished = self.stream.apply_final_reasoning(&text, &sink);
                // Stream finishing is handled by StreamController
                self.stream_state
                    .closed_reasoning_ids
                    .insert(StreamId(id.clone()));
                if let Some(last) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                        .is_some()
                }) {
                    if let Some(reason) = self.history_cells[last]
                        .as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    {
                        reason.set_in_progress(false);
                    }
                }
                self.mark_needs_redraw();
            }
            EventMsg::TokenCount(event) => {
                if let Some(info) = &event.info {
                    self.total_token_usage = info.total_token_usage.clone();
                    self.last_token_usage = info.last_token_usage.clone();
                }
                if let Some(snapshot) = event.rate_limits {
                    self.update_rate_limit_resets(&snapshot);
                    let warnings = self
                        .rate_limit_warnings
                        .take_warnings(snapshot.secondary_used_percent, snapshot.primary_used_percent);
                    let mut legend_entries: Vec<RateLimitLegendEntry> = Vec::new();
                    for warning in warnings {
                        if self.log_and_should_display_warning(&warning) {
                            let label = match warning.scope {
                                RateLimitWarningScope::Primary => {
                                    format!("Hourly usage ≥ {:.0}%", warning.threshold)
                                }
                                RateLimitWarningScope::Secondary => {
                                    format!("Weekly usage ≥ {:.0}%", warning.threshold)
                                }
                            };
                            legend_entries.push(RateLimitLegendEntry {
                                label,
                                description: warning.message.clone(),
                                tone: TextTone::Warning,
                            });
                        }
                    }
                    if !legend_entries.is_empty() {
                        let record = RateLimitsRecord {
                            id: HistoryId::ZERO,
                            snapshot: snapshot.clone(),
                            legend: legend_entries,
                        };
                        let cell = history_cell::RateLimitsCell::from_record(record.clone());
                        let key = self.next_internal_key();
                        let _ = self.history_insert_with_key_global_tagged(
                            Box::new(cell),
                            key,
                            "rate-limits",
                            Some(HistoryDomainRecord::RateLimits(record)),
                        );
                        self.request_redraw();
                    }

                    self.rate_limit_snapshot = Some(snapshot);
                    self.rate_limit_last_fetch_at = Some(Utc::now());
                    self.rate_limit_fetch_inflight = false;
                    self.refresh_settings_overview_rows();
                    let refresh_limits_settings = self
                        .settings
                        .overlay
                        .as_ref()
                        .map(|overlay| {
                            overlay.active_section() == SettingsSection::Limits
                                && !overlay.is_menu_active()
                        })
                        .unwrap_or(false);
                    if refresh_limits_settings {
                        self.show_limits_settings_ui();
                    }
                }
                self.bottom_pane.set_token_usage(
                    self.total_token_usage.clone(),
                    self.last_token_usage.clone(),
                    self.config.model_context_window,
                );
                self.update_stream_token_usage_metadata();
            }
            EventMsg::Error(ErrorEvent { message }) => {
                self.on_error(message);
            }
            EventMsg::PlanUpdate(update) => {
                let (plan_title, plan_active) = {
                    let title = update
                        .name
                        .as_ref()
                        .map(|s| s.trim())
                        .filter(|s| !s.is_empty())
                        .map(|s| s.to_string());
                    let total = update.plan.len();
                    let completed = update
                        .plan
                        .iter()
                        .filter(|p| matches!(p.status, StepStatus::Completed))
                        .count();
                    let active = total > 0 && completed < total;
                    (title, active)
                };
                // Insert plan updates at the time they occur. If the provider
                // supplied OrderMeta, honor it. Otherwise, derive a key within
                // the current (last-seen) request — do NOT advance to the next
                // request when a prompt is already queued, since these belong
                // to the in-flight turn.
                let key = self.near_time_key_current_req(event.order.as_ref());
                let _ = self.history_insert_with_key_global(
                    Box::new(history_cell::new_plan_update(update)),
                    key,
                );
                // If we inserted during streaming, keep the reasoning ellipsis visible.
                self.restore_reasoning_in_progress_if_streaming();
                let desired_title = if plan_active {
                    Some(plan_title.unwrap_or_else(|| "Plan".to_string()))
                } else {
                    None
                };
                self.apply_plan_terminal_title(desired_title);
            }
            EventMsg::ExecApprovalRequest(ev) => {
                let id2 = id.clone();
                let ev2 = ev.clone();
                let seq = event.event_seq;
                self.defer_or_handle(
                    move |interrupts| interrupts.push_exec_approval(seq, id, ev),
                    |this| {
                        this.finalize_active_stream();
                        this.flush_interrupt_queue();
                        this.handle_exec_approval_now(id2, ev2);
                        this.request_redraw();
                    },
                );
            }
            EventMsg::ApplyPatchApprovalRequest(ev) => {
                let id2 = id.clone();
                let ev2 = ev.clone();
                self.defer_or_handle(
                    move |interrupts| interrupts.push_apply_patch_approval(event.event_seq, id, ev),
                    |this| {
                        this.finalize_active_stream();
                        this.flush_interrupt_queue();
                        // Push approval UI state to bottom pane and surface the patch summary there.
                        // (Avoid inserting a duplicate summary here; handle_apply_patch_approval_now
                        // is responsible for rendering the proposed patch once.)
                        this.handle_apply_patch_approval_now(id2, ev2);
                        this.request_redraw();
                    },
                );
            }
            EventMsg::ExecCommandBegin(ev) => {
                let ev2 = ev.clone();
                let seq = event.event_seq;
                let om_begin = event
                    .order
                    .clone()
                    .expect("missing OrderMeta for ExecCommandBegin");
                let om_begin_for_handler = om_begin.clone();
                self.defer_or_handle(
                    move |interrupts| interrupts.push_exec_begin(seq, ev, Some(om_begin)),
                    move |this| {
                        // Finalize any active streaming sections, then establish
                        // the running Exec cell before flushing queued interrupts.
                        // This prevents an out‑of‑order ExecCommandEnd from being
                        // applied first (which would fall back to showing call_id).
                        this.finalize_active_stream();
                        tracing::info!(
                            "[order] ExecCommandBegin call_id={} seq={}",
                            ev2.call_id,
                            seq
                        );
                        this.handle_exec_begin_now(ev2.clone(), &om_begin_for_handler);
                        // If an ExecEnd for this call_id arrived earlier and is waiting,
                        // apply it immediately now that we have a matching Begin.
                        if let Some((pending_end, order2, _ts)) = this
                            .exec
                            .pending_exec_ends
                            .remove(&ExecCallId(ev2.call_id.clone()))
                        {
                            // Use the same order for the pending end
                            this.handle_exec_end_now(pending_end, &order2);
                        }
                        this.flush_interrupt_queue();
                    },
                );
            }
            EventMsg::ExecCommandOutputDelta(ev) => {
                let call_id = ExecCallId(ev.call_id.clone());
                if let Some(running) = self.exec.running_commands.get_mut(&call_id) {
                    let chunk = String::from_utf8_lossy(&ev.chunk).to_string();
                    let (stdout_chunk, stderr_chunk) = match ev.stream {
                        ExecOutputStream::Stdout => {
                            let offset = running.stdout.len();
                            running.stdout.push_str(&chunk);
                            (
                                Some(crate::history::state::ExecStreamChunk {
                                    offset,
                                    content: chunk.clone(),
                                }),
                                None,
                            )
                        }
                        ExecOutputStream::Stderr => {
                            let offset = running.stderr.len();
                            running.stderr.push_str(&chunk);
                            (
                                None,
                                Some(crate::history::state::ExecStreamChunk {
                                    offset,
                                    content: chunk.clone(),
                                }),
                            )
                        }
                    };
                    let history_id = running.history_id.or_else(|| {
                        let mapped = self
                            .history_state
                            .history_id_for_exec_call(call_id.as_ref())
                            .or_else(|| {
                                running.history_index.and_then(|idx| {
                                    self.history_cell_ids
                                        .get(idx)
                                        .and_then(|slot| *slot)
                                })
                            });
                        running.history_id = mapped;
                        mapped
                    });
                    if let Some(history_id) = history_id {
                        if let Some(record_idx) = self.history_state.index_of(history_id) {
                            let mutation = self.history_state.apply_domain_event(
                                HistoryDomainEvent::UpdateExecStream {
                                    index: record_idx,
                                    stdout_chunk,
                                    stderr_chunk,
                                },
                            );
                            if let HistoryMutation::Replaced {
                                id,
                                record: HistoryRecord::Exec(exec_record),
                                ..
                            } = mutation
                            {
                                self.update_cell_from_record(id, HistoryRecord::Exec(exec_record));
                            }
                        }
                    }
                    self.invalidate_height_cache();
                    self.autoscroll_if_near_bottom();
                    self.request_redraw();
                }
            }
            EventMsg::PatchApplyBegin(PatchApplyBeginEvent {
                call_id,
                auto_approved,
                changes,
            }) => {
                let exec_call_id = ExecCallId(call_id.clone());
                self.exec.suppress_exec_end(exec_call_id);
                // Store for session diff popup (clone before moving into history)
                self.diffs.session_patch_sets.push(changes.clone());
                // Capture/adjust baselines, including rename moves
                if let Some(last) = self.diffs.session_patch_sets.last() {
                    for (src_path, chg) in last.iter() {
                        match chg {
                            code_core::protocol::FileChange::Update {
                                move_path: Some(dest_path),
                                ..
                            } => {
                                // Prefer to carry forward existing baseline from src to dest.
                                if let Some(baseline) =
                                    self.diffs.baseline_file_contents.remove(src_path)
                                {
                                    self.diffs
                                        .baseline_file_contents
                                        .insert(dest_path.clone(), baseline);
                                } else if !self.diffs.baseline_file_contents.contains_key(dest_path)
                                {
                                    // Fallback: snapshot current contents of src (pre-apply) under dest key.
                                    let baseline =
                                        std::fs::read_to_string(src_path).unwrap_or_default();
                                    self.diffs
                                        .baseline_file_contents
                                        .insert(dest_path.clone(), baseline);
                                }
                            }
                            _ => {
                                if !self.diffs.baseline_file_contents.contains_key(src_path) {
                                    let baseline =
                                        std::fs::read_to_string(src_path).unwrap_or_default();
                                    self.diffs
                                        .baseline_file_contents
                                        .insert(src_path.clone(), baseline);
                                }
                            }
                        }
                    }
                }
                // Enable Ctrl+D footer hint now that we have diffs to show
                self.bottom_pane.set_diffs_hint(true);
                // Strict order
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on ExecEnd flush; using synthetic key");
                        self.next_internal_key()
                    }
                };
                let cell = history_cell::new_patch_event(
                    PatchEventType::ApplyBegin { auto_approved },
                    changes,
                );
                let _ = self.history_insert_with_key_global(Box::new(cell), ok);
            }
            EventMsg::PatchApplyEnd(ev) => {
                let ev2 = ev.clone();
                self.defer_or_handle(
                    move |interrupts| interrupts.push_patch_end(event.event_seq, ev),
                    |this| this.handle_patch_apply_end_now(ev2),
                );
            }
            EventMsg::ExecCommandEnd(ev) => {
                let ev2 = ev.clone();
                let seq = event.event_seq;
                let order_meta_end = event
                    .order
                    .clone()
                    .expect("missing OrderMeta for ExecCommandEnd");
                let om_for_send = order_meta_end.clone();
                let om_for_insert = order_meta_end.clone();
                self.defer_or_handle(
                    move |interrupts| interrupts.push_exec_end(seq, ev, Some(om_for_send)),
                    move |this| {
                        tracing::info!(
                            "[order] ExecCommandEnd call_id={} seq={}",
                            ev2.call_id,
                            seq
                        );
                        // If we already have a running command for this call_id, finish it now.
                        let has_running = this
                            .exec
                            .running_commands
                            .contains_key(&ExecCallId(ev2.call_id.clone()));
                        if has_running {
                            this.handle_exec_end_now(ev2, &order_meta_end);
                        } else {
                            // Otherwise, stash it briefly and schedule a flush in case the
                            // matching Begin arrives shortly. This avoids rendering a fallback
                            // "call_<id>" cell when events are slightly out of order.
                            this.exec.pending_exec_ends.insert(
                                ExecCallId(ev2.call_id.clone()),
                                (ev2, om_for_insert, std::time::Instant::now()),
                            );
                            let tx = this.app_event_tx.clone();
                            let fallback_tx = tx.clone();
                            if thread_spawner::spawn_lightweight("exec-flush", move || {
                                std::thread::sleep(std::time::Duration::from_millis(120));
                                tx.send(crate::app_event::AppEvent::FlushPendingExecEnds);
                            })
                            .is_none()
                            {
                                let _ = fallback_tx
                                    .send(crate::app_event::AppEvent::FlushPendingExecEnds);
                            }
                        }
                    },
                );
            }
            EventMsg::McpToolCallBegin(ev) => {
                let ev2 = ev.clone();
                let seq = event.event_seq;
                let order_ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on McpBegin; using synthetic key");
                        self.next_internal_key()
                    }
                };
                self.defer_or_handle(
                    move |interrupts| interrupts.push_mcp_begin(seq, ev, event.order.clone()),
                    |this| {
                        this.finalize_active_stream();
                        this.flush_interrupt_queue();
                        tracing::info!(
                            "[order] McpToolCallBegin call_id={} seq={}",
                            ev2.call_id,
                            seq
                        );
                        tools::mcp_begin(this, ev2, order_ok);
                    },
                );
            }
            EventMsg::McpToolCallEnd(ev) => {
                let ev2 = ev.clone();
                let seq = event.event_seq;
                let order_ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on McpEnd; using synthetic key");
                        self.next_internal_key()
                    }
                };
                self.defer_or_handle(
                    move |interrupts| interrupts.push_mcp_end(seq, ev, event.order.clone()),
                    |this| {
                        tracing::info!(
                            "[order] McpToolCallEnd call_id={} seq={}",
                            ev2.call_id,
                            seq
                        );
                        tools::mcp_end(this, ev2, order_ok)
                    },
                );
            }
            EventMsg::CustomToolCallBegin(CustomToolCallBeginEvent {
                call_id,
                tool_name,
                parameters,
            }) => {
                // Any custom tool invocation should fade out the welcome animation
                for cell in &self.history_cells {
                    cell.trigger_fade();
                }
                self.finalize_active_stream();
                // Flush any queued interrupts when streaming ends
                self.flush_interrupt_queue();
                // Show an active entry immediately for all custom tools so the user sees progress
                let params_json = parameters.clone();
                let params_string = params_json.clone().map(|p| p.to_string());
                if agent_runs::is_agent_tool(&tool_name) {
                    if agent_runs::handle_custom_tool_begin(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                    ) {
                        self.bottom_pane
                            .update_status_text("agents coordinating".to_string());
                        return;
                    }
                }
                if tool_name.starts_with("browser_") {
                    if browser_sessions::handle_custom_tool_begin(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                    ) {
                        self.bottom_pane
                            .update_status_text("using browser".to_string());
                        return;
                    }
                }
                if tool_name == "wait" {
                    if let Some(exec_call_id) =
                        wait_exec_call_id_from_params(params_string.as_ref())
                    {
                        self.tools_state
                            .running_wait_tools
                            .insert(ToolCallId(call_id.clone()), exec_call_id.clone());

                        let mut wait_update: Option<(
                            HistoryId,
                            Option<Duration>,
                            Vec<(String, bool)>,
                        )> = None;
                        if let Some(running) = self.exec.running_commands.get_mut(&exec_call_id) {
                            running.wait_active = true;
                            running.wait_notes.clear();
                            let history_id = running.history_id.or_else(|| {
                                running.history_index.and_then(|idx| {
                                    self.history_cell_ids
                                        .get(idx)
                                        .and_then(|slot| *slot)
                                })
                            });
                            running.history_id = history_id;
                            if let Some(id) = history_id {
                                wait_update = Some((id, running.wait_total, running.wait_notes.clone()));
                            }
                        }
                        if let Some((history_id, total, notes)) = wait_update {
                            let _ = self.update_exec_wait_state_with_pairs(history_id, total, true, &notes);
                        }
                        self.bottom_pane
                            .update_status_text("waiting for command".to_string());
                        self.invalidate_height_cache();
                        self.request_redraw();
                        return;
                    }
                }
                if tool_name == "kill" {
                    if let Some(exec_call_id) =
                        wait_exec_call_id_from_params(params_string.as_ref())
                    {
                        self.tools_state
                            .running_kill_tools
                            .insert(ToolCallId(call_id.clone()), exec_call_id);
                        self.bottom_pane
                            .update_status_text("cancelling command".to_string());
                        self.invalidate_height_cache();
                        self.request_redraw();
                        return;
                    }
                }
                // Animated running cell with live timer and formatted args
                let mut cell = if tool_name.starts_with("browser_") {
                    history_cell::new_running_browser_tool_call(
                        tool_name.clone(),
                        params_string.clone(),
                    )
                } else if tool_name.starts_with("agent_") {
                    history_cell::new_running_custom_tool_call(
                        tool_name.clone(),
                        params_string.clone(),
                    )
                } else {
                    history_cell::new_running_custom_tool_call(
                        tool_name.clone(),
                        params_string.clone(),
                    )
                };
                cell.state_mut().call_id = Some(call_id.clone());
                // Enforce ordering for custom tool begin
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on CustomToolCallBegin; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                let idx = self.history_insert_with_key_global(Box::new(cell), ok);
                let history_id = self
                    .history_state
                    .history_id_for_tool_call(&call_id)
                    .or_else(|| self.history_cell_ids.get(idx).and_then(|slot| *slot));
                // Track index so we can replace it on completion
                if idx < self.history_cells.len() {
                    self.tools_state
                        .running_custom_tools
                        .insert(
                            ToolCallId(call_id.clone()),
                            RunningToolEntry::new(ok, idx).with_history_id(history_id),
                        );
                }

                // Update border status based on tool
                if tool_name.starts_with("browser_") {
                    self.bottom_pane
                        .update_status_text("using browser".to_string());
                } else if agent_runs::is_agent_tool(&tool_name) {
                    self.bottom_pane
                        .update_status_text("agents coordinating".to_string());
                } else {
                    self.bottom_pane
                        .update_status_text(format!("using tool: {}", tool_name));
                }
            }
            EventMsg::CustomToolCallEnd(CustomToolCallEndEvent {
                call_id,
                tool_name,
                parameters,
                duration,
                result,
            }) => {
                let params_json = parameters.clone();
                if agent_runs::is_agent_tool(&tool_name) {
                    if agent_runs::handle_custom_tool_end(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                        duration,
                        &result,
                    ) {
                        self.bottom_pane
                            .update_status_text("responding".to_string());
                        return;
                    }
                }
                if tool_name.starts_with("browser_") {
                    if browser_sessions::handle_custom_tool_end(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                        duration,
                        &result,
                    ) {
                        if tool_name == "browser_close" {
                            self.bottom_pane
                                .update_status_text("responding".to_string());
                        } else {
                            self.bottom_pane
                                .update_status_text("using browser".to_string());
                        }
                        return;
                    }
                }
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on CustomToolCallEnd; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                tracing::info!(
                    "[order] CustomToolCallEnd call_id={} tool={} seq={}",
                    call_id,
                    tool_name,
                    event.event_seq
                );
                // Convert parameters to String if present
                let params_string = params_json.map(|p| p.to_string());
                // Determine success and content from Result
                let (success, content) = match result {
                    Ok(content) => (true, content),
                    Err(error) => (false, error),
                };
                if tool_name == "wait" {
                    if let Some(exec_call_id) = self
                        .tools_state
                        .running_wait_tools
                        .remove(&ToolCallId(call_id.clone()))
                    {
                        let trimmed = content.trim();
                        let wait_still_pending = !success && trimmed != "Cancelled by user.";
                        let mut note_lines: Vec<(String, bool)> = Vec::new();
                        let suppress_json_notes = serde_json::from_str::<serde_json::Value>(
                            trimmed,
                        )
                        .ok()
                        .and_then(|value| {
                            value.as_object().map(|obj| {
                                obj.contains_key("output") || obj.contains_key("metadata")
                            })
                        })
                        .unwrap_or(false);
                        if !suppress_json_notes {
                            for line in content.lines() {
                                let note_text = line.trim();
                                if note_text.is_empty() {
                                    continue;
                                }
                                let is_error_note = note_text == "Cancelled by user.";
                                note_lines.push((note_text.to_string(), is_error_note));
                            }
                        }
                        let mut history_id: Option<HistoryId> = None;
                        let mut wait_total: Option<Duration> = None;
                        let mut wait_notes_snapshot: Vec<(String, bool)> = Vec::new();
                        if let Some(running) = self.exec.running_commands.get_mut(&exec_call_id) {
                            let base = running.wait_total.unwrap_or_default();
                            let total = base.saturating_add(duration);
                            running.wait_total = Some(total);
                            running.wait_active = wait_still_pending;
                            Self::append_wait_pairs(&mut running.wait_notes, &note_lines);
                            wait_notes_snapshot = running.wait_notes.clone();
                            wait_total = running.wait_total;
                            history_id = running.history_id.or_else(|| {
                                running.history_index.and_then(|idx| {
                                    self.history_cell_ids
                                        .get(idx)
                                        .and_then(|slot| *slot)
                                })
                            });
                            running.history_id = history_id;
                        } else {
                            Self::append_wait_pairs(&mut wait_notes_snapshot, &note_lines);
                        }

                        if history_id.is_none() {
                            if let Some((idx, _)) = self.history_cells.iter().enumerate().rev().find(|(_, cell)| {
                                cell.as_any()
                                    .downcast_ref::<history_cell::ExecCell>()
                                    .is_some()
                            }) {
                                if let Some(id) = self.history_cell_ids.get(idx).and_then(|slot| *slot) {
                                    history_id = Some(id);
                                    if let Some(running) =
                                        self.exec.running_commands.get_mut(&exec_call_id)
                                    {
                                        running.history_index = Some(idx);
                                        running.history_id = Some(id);
                                    }
                                }
                            }
                        }

                        if let Some(id) = history_id {
                            let exec_record = self
                                .history_state
                                .index_of(id)
                                .and_then(|idx| self.history_state.get(idx).cloned());
                            if let Some(HistoryRecord::Exec(record)) = exec_record {
                                if wait_total.is_none() {
                                    let base = record.wait_total.unwrap_or_default();
                                    wait_total = Some(base.saturating_add(duration));
                                }
                                if wait_notes_snapshot.is_empty() {
                                    wait_notes_snapshot =
                                        Self::wait_pairs_from_exec_notes(&record.wait_notes);
                                    Self::append_wait_pairs(&mut wait_notes_snapshot, &note_lines);
                                }
                            } else {
                                if wait_total.is_none() {
                                    wait_total = Some(duration);
                                }
                                if wait_notes_snapshot.is_empty() {
                                    Self::append_wait_pairs(&mut wait_notes_snapshot, &note_lines);
                                }
                            }
                            let _ = self.update_exec_wait_state_with_pairs(
                                id,
                                wait_total,
                                wait_still_pending,
                                &wait_notes_snapshot,
                            );
                        }

                        if success {
                            self.remove_background_completion_message(&call_id);
                            self.bottom_pane
                                .update_status_text("responding".to_string());
                            self.maybe_hide_spinner();
                        } else if trimmed == "Cancelled by user." {
                            self.bottom_pane
                                .update_status_text("wait cancelled".to_string());
                        } else {
                            self.bottom_pane
                                .update_status_text("waiting for command".to_string());
                        }
                        self.invalidate_height_cache();
                        self.request_redraw();
                        return;
                    }
                }
                let running_entry = self
                    .tools_state
                    .running_custom_tools
                    .remove(&ToolCallId(call_id.clone()));
                let resolved_idx = running_entry
                    .as_ref()
                    .and_then(|entry| running_tools::resolve_entry_index(self, entry, &call_id))
                    .or_else(|| running_tools::find_by_call_id(self, &call_id));

                if tool_name == "apply_patch" && success {
                    if let Some(idx) = resolved_idx {
                        if idx < self.history_cells.len() {
                            let is_running_tool = self.history_cells[idx]
                                .as_any()
                                .downcast_ref::<history_cell::RunningToolCallCell>()
                                .is_some();
                            if is_running_tool {
                                self.history_remove_at(idx);
                            }
                        }
                    }
                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }

                if tool_name == "wait" && success {
                    let target = wait_target_from_params(params_string.as_ref(), &call_id);
                    let wait_cell = history_cell::new_completed_wait_tool_call(target, duration);
                    let wait_state = wait_cell.state().clone();
                    if let Some(idx) = resolved_idx {
                        self.history_replace_with_record(
                            idx,
                            Box::new(wait_cell),
                            HistoryDomainRecord::WaitStatus(wait_state),
                        );
                    } else {
                        let _ = self.history_insert_with_key_global_tagged(
                            Box::new(wait_cell),
                            ok,
                            "untagged",
                            Some(HistoryDomainRecord::WaitStatus(wait_state)),
                        );
                    }
                    self.remove_background_completion_message(&call_id);
                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }
                if tool_name == "wait" && !success && content.trim() == "Cancelled by user." {
                    let mut emphasis = TextEmphasis::default();
                    emphasis.bold = true;
                    let wait_state = PlainMessageState {
                        id: HistoryId::ZERO,
                        role: PlainMessageRole::Error,
                        kind: PlainMessageKind::Error,
                        header: None,
                        lines: vec![MessageLine {
                            kind: MessageLineKind::Paragraph,
                            spans: vec![InlineSpan {
                                text: "Wait cancelled".into(),
                                tone: TextTone::Error,
                                emphasis,
                                entity: None,
                            }],
                        }],
                        metadata: None,
                    };

                    if let Some(idx) = resolved_idx {
                        self.history_replace_with_record(
                            idx,
                            Box::new(history_cell::PlainHistoryCell::from_state(wait_state.clone())),
                            HistoryDomainRecord::Plain(wait_state.clone()),
                        );
                    } else {
                        let _ = self.history_insert_plain_state_with_key(wait_state, ok, "untagged");
                    }

                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }
                if tool_name == "kill" {
                    let _ = self
                        .tools_state
                        .running_kill_tools
                        .remove(&ToolCallId(call_id.clone()));
                    if success {
                        self.remove_background_completion_message(&call_id);
                        self.bottom_pane
                            .update_status_text("responding".to_string());
                    } else {
                        let trimmed = content.trim();
                        if !trimmed.is_empty() {
                            self.push_background_tail(trimmed.to_string());
                        }
                        self.bottom_pane
                            .update_status_text("kill failed".to_string());
                    }
                    self.maybe_hide_spinner();
                    self.invalidate_height_cache();
                    self.request_redraw();
                    return;
                }
                // Special-case browser/web fetch to render returned markdown nicely.
                if tool_name == "web_fetch" || tool_name == "browser_fetch" {
                    let completed = history_cell::new_completed_web_fetch_tool_call(
                        &self.config,
                        params_string,
                        duration,
                        success,
                        content,
                    );
                    if let Some(idx) = resolved_idx {
                        self.history_replace_at(idx, Box::new(completed));
                    } else {
                        running_tools::collapse_spinner(self, &call_id);
                        let _ = self.history_insert_with_key_global(Box::new(completed), ok);
                    }

                    // After tool completes, likely transitioning to response
                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }
                let mut completed = history_cell::new_completed_custom_tool_call(
                    tool_name,
                    params_string,
                    duration,
                    success,
                    content,
                );
                completed.state_mut().call_id = Some(call_id.clone());
                if let Some(idx) = resolved_idx {
                    self.history_debug(format!(
                        "custom_tool_end.in_place call_id={} idx={} order=({}, {}, {})",
                        call_id,
                        idx,
                        ok.req,
                        ok.out,
                        ok.seq
                    ));
                    self.history_replace_at(idx, Box::new(completed));
                } else {
                    self.history_debug(format!(
                        "custom_tool_end.fallback_insert call_id={} order=({}, {}, {})",
                        call_id,
                        ok.req,
                        ok.out,
                        ok.seq
                    ));
                    running_tools::collapse_spinner(self, &call_id);
                    let _ = self.history_insert_with_key_global(Box::new(completed), ok);
                }

                // After tool completes, likely transitioning to response
                self.bottom_pane
                    .update_status_text("responding".to_string());
                self.maybe_hide_spinner();
            }
            EventMsg::GetHistoryEntryResponse(event) => {
                let code_core::protocol::GetHistoryEntryResponseEvent {
                    offset,
                    log_id,
                    entry,
                } = event;

                // Inform bottom pane / composer.
                self.bottom_pane
                    .on_history_entry_response(log_id, offset, entry.map(|e| e.text));
            }
            EventMsg::ShutdownComplete => {
                self.push_background_tail("🟡 ShutdownComplete".to_string());
                self.app_event_tx.send(AppEvent::ExitRequest);
            }
            EventMsg::TurnDiff(TurnDiffEvent { unified_diff }) => {
                info!("TurnDiffEvent: {unified_diff}");
            }
            EventMsg::BackgroundEvent(BackgroundEventEvent { message }) => {
                info!("BackgroundEvent: {message}");
                if browser_sessions::handle_background_event(
                    self,
                    event.order.as_ref(),
                    &message,
                ) {
                    return;
                }
                let is_agent_hint = message.starts_with("🤖 Agent");
                if is_agent_hint && self.suppress_next_agent_hint {
                    self.suppress_next_agent_hint = false;
                    self.clear_resume_placeholder();
                    return;
                }
                self.clear_resume_placeholder();
                // Route through unified system notice helper. If the core ties the
                // event to a turn (order present), prefer placing it before the next
                // provider output; else append to the tail. Use the event.id for
                // in-place replacement.
                let placement = match event.order.as_ref().and_then(|om| om.output_index) {
                    Some(v) if v == i32::MAX as u32 => SystemPlacement::EndOfCurrent,
                    Some(_) => SystemPlacement::EarlyInCurrent,
                    None => SystemPlacement::EndOfCurrent,
                };
                let id_for_replace = Some(id.clone());
                let message_clone = message.clone();
                let cell = history_cell::new_background_event(message_clone);
                let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
                self.push_system_cell(
                    Box::new(cell),
                    placement,
                    id_for_replace,
                    event.order.as_ref(),
                    "background",
                    Some(record),
                );
                // If we inserted during streaming, keep the reasoning ellipsis visible.
                self.restore_reasoning_in_progress_if_streaming();

                // Also reflect CDP connect success in the status line.
                if message.starts_with("✅ Connected to Chrome via CDP") {
                    self.bottom_pane
                        .update_status_text("using browser (CDP)".to_string());
                }

                if is_agent_hint
                    || message.starts_with("⚠️ Agent reuse")
                    || message.starts_with("⚠️ Agent prompt")
                {
                    self.recent_agent_hint = Some(message);
                }
            }
            EventMsg::AgentStatusUpdate(event) => {
                agent_runs::handle_status_update(self, &event);
                let AgentStatusUpdateEvent { agents, context, task } = event;
                // Update the active agents list from the event and track timing
                self.active_agents.clear();
                let now = Instant::now();
                for agent in agents.iter() {
                    let parsed_status = agent_status_from_str(agent.status.as_str());
                    // Update runtime map
                    let entry = self
                        .agent_runtime
                        .entry(agent.id.clone())
                        .or_insert_with(AgentRuntime::default);
                    entry.last_update = Some(now);
                    match parsed_status {
                        AgentStatus::Running => {
                            if entry.started_at.is_none() {
                                entry.started_at = Some(now);
                            }
                        }
                        AgentStatus::Completed | AgentStatus::Failed | AgentStatus::Cancelled => {
                            if entry.completed_at.is_none() {
                                entry.completed_at = entry.completed_at.or(Some(now));
                            }
                        }
                        _ => {}
                    }

                    // Mirror agent list for rendering
                    self.active_agents.push(AgentInfo {
                        id: agent.id.clone(),
                        name: agent.name.clone(),
                        status: parsed_status.clone(),
                        batch_id: agent.batch_id.clone(),
                        model: agent.model.clone(),
                        result: agent.result.clone(),
                        error: agent.error.clone(),
                        last_progress: agent.last_progress.clone(),
                    });
                }

                self.update_agents_terminal_state(&agents, context.clone(), task.clone());

                // Store shared context and task
                self.agent_context = context;
                self.agent_task = task;

                // Fallback: if every agent we know about has reached a terminal state and
                // there is no active streaming or tooling, clear the spinner even if the
                // backend hasn't sent TaskComplete yet. This prevents the footer from
                // getting stuck on "Responding..." after multi-agent runs that yield
                // early.
                if self.bottom_pane.is_task_running() {
                    let all_agents_terminal = !self.agent_runtime.is_empty()
                        && self
                            .agent_runtime
                            .values()
                            .all(|rt| rt.completed_at.is_some());
                    if all_agents_terminal {
                        let any_tools_running = !self.exec.running_commands.is_empty()
                            || !self.tools_state.running_custom_tools.is_empty()
                            || !self.tools_state.web_search_sessions.is_empty();
                        let any_streaming = self.stream.is_write_cycle_active();
                        if !(any_tools_running || any_streaming) {
                            self.bottom_pane.set_task_running(false);
                            self.bottom_pane.update_status_text(String::new());
                        }
                    }
                }

                // Update overall task status based on agent states
                let status = Self::overall_task_status_for(&self.active_agents);
                self.overall_task_status = status.to_string();

                let agents_still_active = self
                    .active_agents
                    .iter()
                    .any(|a| matches!(a.status, AgentStatus::Pending | AgentStatus::Running));
                if agents_still_active {
                    self.bottom_pane.set_task_running(true);
                }

                // Reflect concise agent status in the input border
                let count = self.active_agents.len();
                let msg = match status {
                    "preparing" => format!("agents: preparing ({} ready)", count),
                    "running" => format!("agents: running ({})", count),
                    "complete" => format!("agents: complete ({} ok)", count),
                    "failed" => "agents: failed".to_string(),
                    "cancelled" => "agents: cancelled".to_string(),
                    _ => "agents: planning".to_string(),
                };
                self.bottom_pane.update_status_text(msg);

                // Keep agents visible after completion so users can see final messages/errors.
                // HUD will be reset automatically when a new agent batch starts.

                // Reset ready to start flag when we get actual agent updates
                if !self.active_agents.is_empty() {
                    self.agents_ready_to_start = false;
                }
                // Re-evaluate spinner visibility now that agent states changed.
                self.maybe_hide_spinner();
                self.request_redraw();
            }
            EventMsg::BrowserScreenshotUpdate(payload) => {
                #[cfg(feature = "code-fork")]
                handle_browser_screenshot(&payload, &self.app_event_tx);

                let BrowserScreenshotUpdateEvent { screenshot_path, url } = payload;
                let update = browser_sessions::handle_screenshot_update(
                    self,
                    event.order.as_ref(),
                    &screenshot_path,
                    &url,
                );
                tracing::info!(
                    "Received browser screenshot update: {} at URL: {}",
                    screenshot_path.display(),
                    url
                );

                // Update the latest screenshot and URL for display
                if let Ok(mut latest) = self.latest_browser_screenshot.lock() {
                    let old_url = latest.as_ref().map(|(_, u)| u.clone());
                    *latest = Some((screenshot_path.clone(), url.clone()));
                    if old_url.as_ref() != Some(&url) {
                        tracing::info!("Browser URL changed from {:?} to {}", old_url, url);
                    }
                    tracing::debug!(
                        "Updated browser screenshot display with path: {} and URL: {}",
                        screenshot_path.display(),
                        url
                    );
                } else {
                    tracing::warn!("Failed to acquire lock for browser screenshot update");
                }

                if let Some(key) = update.session_key.as_ref() {
                    self.browser_overlay_state
                        .set_session_key(Some(key.clone()));
                    if let Some(tracker) = self.tools_state.browser_sessions.get(key) {
                        let len = tracker.cell.screenshot_history().len();
                        if len > 0 {
                            let last_index = len.saturating_sub(1);
                            let current_index = self.browser_overlay_state.screenshot_index();
                            if !self.browser_overlay_visible || current_index >= last_index {
                                self.browser_overlay_state
                                    .set_screenshot_index(last_index);
                            }
                        }
                    }
                }

                // Request a redraw to update the display immediately
                self.app_event_tx.send(AppEvent::RequestRedraw);

                if update.grouped {
                    self.bottom_pane
                        .update_status_text("using browser".to_string());
                }
            }
            // Newer protocol variants we currently ignore in the TUI
            EventMsg::UserMessage(_) => {}
            EventMsg::TurnAborted(_) => {}
            EventMsg::ConversationPath(_) => {}
            EventMsg::EnteredReviewMode(review_request) => {
                if self.auto_resolve_enabled() {
                    self.auto_resolve_handle_review_enter();
                }
                let hint = review_request.user_facing_hint.trim();
                let banner = if hint.is_empty() {
                    ">> Code review started <<".to_string()
                } else {
                    format!(">> Code review started: {hint} <<")
                };
                self.active_review_hint = Some(review_request.user_facing_hint.clone());
                self.active_review_prompt = Some(review_request.prompt.clone());
                self.push_background_before_next_output(banner);

                let prompt_text = review_request.prompt.trim();
                if !prompt_text.is_empty() {
                    let mut lines: Vec<Line<'static>> = Vec::new();
                    lines.push(Line::from(vec![RtSpan::styled(
                        "Review focus",
                        Style::default().add_modifier(Modifier::BOLD),
                    )]));
                    lines.push(Line::from(""));
                    for line in prompt_text.lines() {
                        lines.push(Line::from(line.to_string()));
                    }
                    let state = history_cell::plain_message_state_from_lines(
                        lines,
                        history_cell::HistoryCellType::Notice,
                    );
                    self.history_push_plain_state(state);
                }
                if self.auto_state.is_active() {
                    self.auto_state.on_begin_review(false);
                    self.auto_rebuild_live_ring();
                }
                self.request_redraw();
            }
            EventMsg::ExitedReviewMode(review_output) => {
                if self.auto_resolve_enabled() {
                    self.auto_resolve_handle_review_exit(review_output.clone());
                }
                let hint = self.active_review_hint.take();
                let prompt = self.active_review_prompt.take();
                match review_output {
                    Some(output) => {
                        let summary_cell = self.build_review_summary_cell(
                            hint.as_deref(),
                            prompt.as_deref(),
                            &output,
                        );
                        self.history_push(summary_cell);
                        let finish_banner = match hint.as_deref() {
                            Some(h) if !h.trim().is_empty() => {
                                let trimmed = h.trim();
                                format!("<< Code review finished: {trimmed} >>")
                            }
                            _ => "<< Code review finished >>".to_string(),
                        };
                        self.push_background_tail(finish_banner);
                    }
                    None => {
                        let banner = match hint.as_deref() {
                            Some(h) if !h.trim().is_empty() => {
                                let trimmed = h.trim();
                                format!(
                                    "<< Code review finished without a final response ({trimmed}) >>"
                                )
                            }
                            _ => "<< Code review finished without a final response >>".to_string(),
                        };
                        self.push_background_tail(banner);
                        self.history_push_plain_state(history_cell::new_warning_event(
                            "Review session ended without returning findings. Try `/review` again if you still need feedback.".to_string(),
                        ));
                    }
                }
                if self.auto_state.is_active() && self.auto_state.awaiting_review() {
                    if self.auto_resolve_should_block_auto_resume() {
                        self.request_redraw();
                    } else {
                        self.maybe_resume_auto_after_review();
                    }
                } else {
                    self.request_redraw();
                }
            }
        }
    }

    fn request_redraw(&mut self) {
        self.app_event_tx.send(AppEvent::RequestRedraw);
    }

    pub(crate) fn handle_perf_command(&mut self, args: String) {
        let arg = args.trim().to_lowercase();
        match arg.as_str() {
            "on" => {
                self.perf_state.enabled = true;
                self.perf_state.pending_scroll_rows.set(0);
                self.add_perf_output("performance tracing: on".to_string());
            }
            "off" => {
                self.perf_state.enabled = false;
                self.perf_state.pending_scroll_rows.set(0);
                self.add_perf_output("performance tracing: off".to_string());
            }
            "reset" => {
                self.perf_state.stats.borrow_mut().reset();
                self.perf_state.pending_scroll_rows.set(0);
                self.add_perf_output("performance stats reset".to_string());
            }
            "show" | "" => {
                let summary = self.perf_state.stats.borrow().summary();
                self.add_perf_output(summary);
            }
            _ => {
                self.add_perf_output("usage: /perf on | off | show | reset".to_string());
            }
        }
        self.request_redraw();
    }

    pub(crate) fn handle_demo_command(&mut self) {
        use ratatui::style::Modifier as RtModifier;
        use ratatui::style::Style as RtStyle;
        use ratatui::text::Span;

        self.push_background_tail("demo: populating history with sample cells…");
        enum DemoPatch {
            Add {
                path: &'static str,
                content: &'static str,
            },
            Update {
                path: &'static str,
                unified_diff: &'static str,
                original: &'static str,
                new_content: &'static str,
            },
        }

        let scenarios = [
            (
                "build automation",
                "How do I wire up CI, linting, and release automation for this repo?",
                vec![
                    ("Context", "scan workspace layout and toolchain."),
                    ("Next", "surface build + validation commands."),
                    ("Goal", "summarize a reproducible workflow."),
                ],
                vec![
                    "streaming preview: inspecting package manifests…",
                    "streaming preview: drafting deployment summary…",
                    "streaming preview: cross-checking lint targets…",
                ],
                "**Here's a demo walkthrough:**\n\n1. Run `./build-fast.sh perf` to compile quickly.\n2. Cache artifacts in `code-rs/target/perf`.\n3. Finish by sharing `./build-fast.sh run` output.\n\n```bash\n./build-fast.sh perf run\n```",
                vec![
                    (vec!["git", "status"], "On branch main\nnothing to commit, working tree clean\n"),
                    (vec!["rg", "--files"], ""),
                ],
                Some(DemoPatch::Add {
                    path: "src/demo.rs",
                    content: "fn main() {\n    println!(\"demo\");\n}\n",
                }),
                UpdatePlanArgs {
                    name: Some("Demo Scroll Plan".to_string()),
                    plan: vec![
                        PlanItemArg {
                            step: "Create reproducible builds".to_string(),
                            status: StepStatus::InProgress,
                        },
                        PlanItemArg {
                            step: "Verify validations".to_string(),
                            status: StepStatus::Pending,
                        },
                        PlanItemArg {
                            step: "Document follow-up tasks".to_string(),
                            status: StepStatus::Completed,
                        },
                    ],
                },
                ("browser_open", "https://example.com", "navigated to example.com"),
                ReasoningEffort::High,
                "demo: lint warnings will appear here",
                "demo: this slot shows error output",
                Some("diff --git a/src/lib.rs b/src/lib.rs\n@@ -1,3 +1,5 @@\n-pub fn hello() {}\n+pub fn hello() {\n+    println!(\"hello, demo!\");\n+}\n"),
            ),
            (
                "release rehearsal",
                "What checklist should I follow before tagging a release?",
                vec![
                    ("Inventory", "collect outstanding changes and docs."),
                    ("Verify", "run smoke tests and package audits."),
                    ("Announce", "draft release notes and rollout plan."),
                ],
                vec![
                    "streaming preview: aggregating changelog entries…",
                    "streaming preview: validating release artifacts…",
                    "streaming preview: preparing announcement copy…",
                ],
                "**Release rehearsal:**\n\n1. Run `./scripts/create_github_release.sh --dry-run`.\n2. Capture artifact hashes in the notes.\n3. Schedule follow-up validation in automation.\n\n```bash\n./scripts/create_github_release.sh 1.2.3 --dry-run\n```",
                vec![
                    (vec!["git", "--no-pager", "diff", "--stat"], " src/lib.rs | 10 ++++++----\n 1 file changed, 6 insertions(+), 4 deletions(-)\n"),
                    (vec!["ls", "-1"], "Cargo.lock\nREADME.md\nsrc\ntarget\n"),
                ],
                Some(DemoPatch::Update {
                    path: "src/release.rs",
                    unified_diff: "--- a/src/release.rs\n+++ b/src/release.rs\n@@ -1 +1,3 @@\n-pub fn release() {}\n+pub fn release() {\n+    println!(\"drafting release\");\n+}\n",
                    original: "pub fn release() {}\n",
                    new_content: "pub fn release() {\n    println!(\"drafting release\");\n}\n",
                }),
                UpdatePlanArgs {
                    name: Some("Release Gate Plan".to_string()),
                    plan: vec![
                        PlanItemArg {
                            step: "Finalize changelog".to_string(),
                            status: StepStatus::Completed,
                        },
                        PlanItemArg {
                            step: "Run smoke tests".to_string(),
                            status: StepStatus::InProgress,
                        },
                        PlanItemArg {
                            step: "Tag release".to_string(),
                            status: StepStatus::Pending,
                        },
                        PlanItemArg {
                            step: "Notify stakeholders".to_string(),
                            status: StepStatus::Pending,
                        },
                    ],
                },
                ("browser_open", "https://example.com/releases", "reviewed release dashboard"),
                ReasoningEffort::Medium,
                "demo: release checklist warning",
                "demo: release checklist error",
                Some("diff --git a/CHANGELOG.md b/CHANGELOG.md\n@@ -1,3 +1,6 @@\n+## 1.2.3\n+- polish release flow\n+- document automation hooks\n"),
            ),
        ];

        for (idx, scenario) in scenarios.iter().enumerate() {
            let (
                label,
                prompt,
                reasoning_steps,
                stream_lines,
                assistant_body,
                execs,
                patch_change,
                plan,
                tool_call,
                effort,
                warning_text,
                error_text,
                diff_snippet,
            ) = scenario;

            self.push_background_tail(format!(
                "demo: scenario {} — {}",
                idx + 1,
                label
            ));

            self.history_push_plain_state(history_cell::new_user_prompt((*prompt).to_string()));

            let mut reasoning_lines: Vec<Line<'static>> = reasoning_steps
                .iter()
                .map(|(title, body)| {
                    Line::from(vec![
                        Span::styled(
                            format!("{}:", title),
                            RtStyle::default().add_modifier(RtModifier::BOLD),
                        ),
                        Span::raw(format!(" {body}")),
                    ])
                })
                .collect();
            reasoning_lines.push(
                Line::from(format!("Scenario summary: {}", label))
                    .style(RtStyle::default().fg(crate::colors::text_dim())),
            );
            let reasoning_cell = history_cell::CollapsibleReasoningCell::new_with_id(
                reasoning_lines,
                Some(format!("demo-reasoning-{}", idx)),
            );
            reasoning_cell.set_collapsed(false);
            reasoning_cell.set_in_progress(false);
            self.history_push(reasoning_cell);

            let preview_lines: Vec<ratatui::text::Line<'static>> = stream_lines
                .iter()
                .map(|line| Line::from((*line).to_string()))
                .collect();
            let state = self.synthesize_stream_state_from_lines(None, &preview_lines, false);
            let streaming_preview = history_cell::new_streaming_content(state, &self.config);
            self.history_push(streaming_preview);

            let assistant_state = AssistantMessageState {
                id: HistoryId::ZERO,
                stream_id: None,
                markdown: (*assistant_body).to_string(),
                citations: Vec::new(),
                metadata: None,
                token_usage: None,
                created_at: SystemTime::now(),
            };
            let assistant_cell =
                history_cell::AssistantMarkdownCell::from_state(assistant_state, &self.config);
            self.history_push(assistant_cell);

            for (command_tokens, stdout) in execs {
                let cmd_vec: Vec<String> = command_tokens.iter().map(|s| s.to_string()).collect();
                let parsed = code_core::parse_command::parse_command(&cmd_vec);
                self.history_push(history_cell::new_active_exec_command(
                    cmd_vec.clone(),
                    parsed.clone(),
                ));
                if !stdout.is_empty() {
                    let output = history_cell::CommandOutput {
                        exit_code: 0,
                        stdout: stdout.to_string(),
                        stderr: String::new(),
                    };
                    self.history_push(history_cell::new_completed_exec_command(
                        cmd_vec,
                        parsed,
                        output,
                    ));
                }
            }

            if let Some(diff) = diff_snippet {
                self.history_push_diff(None, diff.to_string());
            }

            if let Some(patch) = patch_change {
                let mut patch_changes = HashMap::new();
                let message = match patch {
                    DemoPatch::Add { path, content } => {
                        patch_changes.insert(
                            PathBuf::from(path),
                            code_core::protocol::FileChange::Add {
                                content: (*content).to_string(),
                            },
                        );
                        format!("patch: simulated failure while applying {}", path)
                    }
                    DemoPatch::Update {
                        path,
                        unified_diff,
                        original,
                        new_content,
                    } => {
                        patch_changes.insert(
                            PathBuf::from(path),
                            code_core::protocol::FileChange::Update {
                                unified_diff: (*unified_diff).to_string(),
                                move_path: None,
                                original_content: (*original).to_string(),
                                new_content: (*new_content).to_string(),
                            },
                        );
                        format!("patch: simulated failure while applying {}", path)
                    }
                };
                self.history_push(history_cell::new_patch_event(
                    history_cell::PatchEventType::ApprovalRequest,
                    patch_changes,
                ));
                self.history_push_plain_state(history_cell::new_patch_apply_failure(message));
            }

            self.history_push(history_cell::new_plan_update(plan.clone()));

            let (tool_name, url, result) = tool_call;
            self.history_push(history_cell::new_completed_custom_tool_call(
                (*tool_name).to_string(),
                Some((*url).to_string()),
                Duration::from_millis(420 + (idx as u64 * 150)),
                true,
                (*result).to_string(),
            ));

            self.history_push_plain_state(history_cell::new_warning_event((*warning_text).to_string()));
            self.history_push_plain_state(history_cell::new_error_event((*error_text).to_string()));

            self.history_push_plain_state(history_cell::new_model_output("gpt-5-codex", *effort));
            self.history_push_plain_state(history_cell::new_reasoning_output(effort));

            self.history_push_plain_state(history_cell::new_status_output(
                &self.config,
                &self.total_token_usage,
                &self.last_token_usage,
            ));

            self.history_push_plain_state(history_cell::new_prompts_output());
        }

        let final_preview_lines = vec![
            Line::from("streaming preview: final tokens rendered."),
            Line::from("streaming preview: viewport ready for scroll testing."),
        ];
        let final_state =
            self.synthesize_stream_state_from_lines(None, &final_preview_lines, false);
        let final_stream = history_cell::new_streaming_content(final_state, &self.config);
        self.history_push(final_stream);

        self.push_background_tail("demo: rendering sample tool cards for theme review…");

        let mut agent_card = history_cell::AgentRunCell::new("Demo Agent Batch".to_string());
        agent_card.set_batch_label(Some("Demo Agents".to_string()));
        agent_card.set_task(Some("Draft a release checklist".to_string()));
        agent_card.set_context(Some("Context: codex workspace demo run".to_string()));
        agent_card.set_plan(vec![
            "Collect recent commits".to_string(),
            "Summarize blockers".to_string(),
            "Draft announcement".to_string(),
        ]);
        let mut completed_preview = history_cell::AgentStatusPreview::default();
        completed_preview.id = "demo-completed".to_string();
        completed_preview.name = "Docs Scout".to_string();
        completed_preview.status = "Completed".to_string();
        completed_preview.model = Some("gpt-5.1-large".to_string());
        completed_preview.details = vec![history_cell::AgentDetail::Result(
            "Summarized API changes".to_string(),
        )];
        completed_preview.status_kind = history_cell::AgentStatusKind::Completed;
        completed_preview.step_progress = Some(history_cell::StepProgress { completed: 3, total: 3 });
        completed_preview.elapsed = Some(Duration::from_secs(32));
        completed_preview.last_update = Some("Wrapped up summary".to_string());
        let mut running_preview = history_cell::AgentStatusPreview::default();
        running_preview.id = "demo-running".to_string();
        running_preview.name = "Lint Fixer".to_string();
        running_preview.status = "Running".to_string();
        running_preview.model = Some("code-gpt-5".to_string());
        running_preview.details = vec![history_cell::AgentDetail::Progress(
            "Refining suggested fixes".to_string(),
        )];
        running_preview.status_kind = history_cell::AgentStatusKind::Running;
        running_preview.step_progress = Some(history_cell::StepProgress { completed: 1, total: 3 });
        running_preview.elapsed = Some(Duration::from_secs(18));
        running_preview.last_update = Some("Step 2 of 3".to_string());
        agent_card.set_agent_overview(vec![completed_preview, running_preview]);
        agent_card.set_latest_result(vec!["Generated release briefing".to_string()]);
        agent_card.record_action("Collecting changelog entries");
        agent_card.record_action("Writing release notes");
        agent_card.set_duration(Some(Duration::from_secs(96)));
        agent_card.set_write_mode(Some(true));
        agent_card.set_status_label("Completed");
        agent_card.mark_completed();
        self.history_push(agent_card);

        let mut agent_read_card = history_cell::AgentRunCell::new("Demo Read Batch".to_string());
        agent_read_card.set_batch_label(Some("Read Agents".to_string()));
        agent_read_card.set_task(Some("Survey docs for regression notes".to_string()));
        agent_read_card.set_context(Some("Scope: analyze docs, no writes".to_string()));
        agent_read_card.set_plan(vec![
            "Gather doc highlights".to_string(),
            "Verify changelog snippets".to_string(),
        ]);
        let mut pending_preview = history_cell::AgentStatusPreview::default();
        pending_preview.id = "demo-read-pending".to_string();
        pending_preview.name = "Doc Harvester".to_string();
        pending_preview.status = "Pending".to_string();
        pending_preview.model = Some("gpt-4.5".to_string());
        pending_preview.details = vec![history_cell::AgentDetail::Info(
            "Waiting for search index".to_string(),
        )];
        pending_preview.status_kind = history_cell::AgentStatusKind::Pending;
        let mut running_read = history_cell::AgentStatusPreview::default();
        running_read.id = "demo-read-running".to_string();
        running_read.name = "Spec Parser".to_string();
        running_read.status = "Running".to_string();
        running_read.model = Some("code-gpt-3.5".to_string());
        running_read.details = vec![history_cell::AgentDetail::Progress(
            "Scanning RFC summaries".to_string(),
        )];
        running_read.status_kind = history_cell::AgentStatusKind::Running;
        running_read.step_progress = Some(history_cell::StepProgress { completed: 2, total: 5 });
        running_read.elapsed = Some(Duration::from_secs(22));
        agent_read_card.set_agent_overview(vec![pending_preview, running_read]);
        agent_read_card.record_action("Fetching documentation excerpts");
        agent_read_card.set_duration(Some(Duration::from_secs(54)));
        agent_read_card.set_write_mode(Some(false));
        agent_read_card.set_status_label("Running");
        self.history_push(agent_read_card);

        let mut browser_card = history_cell::BrowserSessionCell::new();
        browser_card.set_url("https://example.dev/releases");
        browser_card.set_headless(Some(false));
        browser_card.record_action(
            Duration::from_millis(0),
            Duration::from_millis(420),
            "open".to_string(),
            Some("https://example.dev/releases".to_string()),
            None,
            Some("status=200".to_string()),
        );
        browser_card.record_action(
            Duration::from_millis(620),
            Duration::from_millis(380),
            "scroll".to_string(),
            Some("main timeline".to_string()),
            Some("dy=512".to_string()),
            None,
        );
        browser_card.record_action(
            Duration::from_millis(1280),
            Duration::from_millis(520),
            "click".to_string(),
            Some(".release-card".to_string()),
            Some("index=2".to_string()),
            Some("status=OK".to_string()),
        );
        browser_card.add_console_message("Loaded demo assets".to_string());
        browser_card.add_console_message("Fetched changelog via XHR".to_string());
        browser_card.set_status_code(Some("200 OK".to_string()));
        self.history_push(browser_card);

        let mut search_card = history_cell::WebSearchSessionCell::new();
        search_card.set_query(Some("rust async cancellation strategy".to_string()));
        search_card.ensure_started_message();
        search_card.record_info(Duration::from_millis(120), "Searching documentation index");
        search_card.record_success(Duration::from_millis(620), "Found tokio.rs guides");
        search_card.record_success(Duration::from_millis(1040), "Linked blog: cancellation patterns");
        search_card.set_status(history_cell::WebSearchStatus::Completed);
        search_card.set_duration(Some(Duration::from_millis(1400)));
        self.history_push(search_card);

        let mut auto_drive_card =
            history_cell::AutoDriveCardCell::new(Some("Stabilize nightly CI pipeline".to_string()));
        auto_drive_card.push_action(
            "Queued smoke tests across agents",
            history_cell::AutoDriveActionKind::Info,
        );
        auto_drive_card.push_action(
            "Warning: macOS shard flaked",
            history_cell::AutoDriveActionKind::Warning,
        );
        auto_drive_card.push_action(
            "Action required: retry or pause run",
            history_cell::AutoDriveActionKind::Error,
        );
        auto_drive_card.set_status(history_cell::AutoDriveStatus::Paused);
        self.history_push(auto_drive_card);

        self.push_background_tail("demo: finished populating sample history.");
        self.request_redraw();
    }

    fn add_perf_output(&mut self, text: String) {
        let mut lines: Vec<ratatui::text::Line<'static>> = Vec::new();
        lines.push(ratatui::text::Line::from("performance".dim()));
        for l in text.lines() {
            lines.push(ratatui::text::Line::from(l.to_string()))
        }
        let state = history_cell::plain_message_state_from_lines(
            lines,
            crate::history_cell::HistoryCellType::Notice,
        );
        self.history_push_plain_state(state);
    }

    pub(crate) fn add_diff_output(&mut self, diff_output: String) {
        self.history_push_diff(None, diff_output);
    }

    pub(crate) fn add_status_output(&mut self) {
        self.history_push_plain_state(history_cell::new_status_output(
            &self.config,
            &self.total_token_usage,
            &self.last_token_usage,
        ));
    }

    pub(crate) fn show_limits_settings_ui(&mut self) {
        self.ensure_settings_overlay_section(SettingsSection::Limits);

        if let Some(cached) = self.limits.cached_content.take() {
            self.update_limits_settings_content(cached);
        }

        let snapshot = self.rate_limit_snapshot.clone();
        let needs_refresh = self.should_refresh_limits();

        if self.rate_limit_fetch_inflight || needs_refresh {
            self.set_limits_overlay_content(LimitsOverlayContent::Loading);
        } else {
            let reset_info = self.rate_limit_reset_info();
            let tabs = self.build_limits_tabs(snapshot.clone(), reset_info);
            self.set_limits_overlay_tabs(tabs);
        }

        self.request_redraw();

        if needs_refresh {
            self.request_latest_rate_limits(snapshot.is_none());
        }
    }

    fn request_latest_rate_limits(&mut self, show_loading: bool) {
        if self.rate_limit_fetch_inflight {
            return;
        }

        if show_loading {
            self.set_limits_overlay_content(LimitsOverlayContent::Loading);
            self.request_redraw();
        }

        self.rate_limit_fetch_inflight = true;

        start_rate_limit_refresh(
            self.app_event_tx.clone(),
            self.config.clone(),
            self.config.debug,
        );
    }

    fn should_refresh_limits(&self) -> bool {
        if self.rate_limit_fetch_inflight {
            return false;
        }
        match self.rate_limit_last_fetch_at {
            Some(ts) => Utc::now() - ts > RATE_LIMIT_REFRESH_INTERVAL,
            None => true,
        }
    }

    pub(crate) fn on_auto_upgrade_completed(&mut self, version: String) {
        let notice = format!("Auto-upgraded to version {version}");
        self.latest_upgrade_version = None;
        self.push_background_tail(notice.clone());
        self.bottom_pane.flash_footer_notice(notice);
        self.request_redraw();
    }

    pub(crate) fn on_rate_limit_refresh_failed(&mut self, message: String) {
        self.rate_limit_fetch_inflight = false;

        let content = if self.rate_limit_snapshot.is_some() {
            LimitsOverlayContent::Error(message.clone())
        } else {
            LimitsOverlayContent::Placeholder
        };
        self.set_limits_overlay_content(content);
        self.request_redraw();

        if self.rate_limit_snapshot.is_some() {
            self.history_push_plain_state(history_cell::new_warning_event(message));
        }
    }

    fn rate_limit_reset_info(&self) -> RateLimitResetInfo {
        let auto_compact_limit = self
            .config
            .model_auto_compact_token_limit
            .and_then(|limit| (limit > 0).then_some(limit as u64));
        let session_tokens_used = if auto_compact_limit.is_some() {
            Some(self.total_token_usage.total_tokens)
        } else {
            None
        };
        let context_window = self.config.model_context_window;
        let context_tokens_used = context_window.map(|_| self.last_token_usage.tokens_in_context_window());

        RateLimitResetInfo {
            primary_next_reset: self.rate_limit_primary_next_reset_at,
            secondary_next_reset: self.rate_limit_secondary_next_reset_at,
            session_tokens_used,
            auto_compact_limit,
            overflow_auto_compact: true,
            context_window,
            context_tokens_used,
        }
    }

    fn update_rate_limit_resets(&mut self, current: &RateLimitSnapshotEvent) {
        let now = Utc::now();
        if let Some(secs) = current.primary_reset_after_seconds {
            self.rate_limit_primary_next_reset_at =
                Some(now + ChronoDuration::seconds(secs as i64));
        } else {
            self.rate_limit_primary_next_reset_at = None;
        }
        if let Some(secs) = current.secondary_reset_after_seconds {
            self.rate_limit_secondary_next_reset_at =
                Some(now + ChronoDuration::seconds(secs as i64));
        } else {
            self.rate_limit_secondary_next_reset_at = None;
        }
    }

    pub(crate) fn handle_update_command(&mut self, command_args: &str) {
        let trimmed = command_args.trim();
        if trimmed.eq_ignore_ascii_case("settings")
            || trimmed.eq_ignore_ascii_case("ui")
            || trimmed.eq_ignore_ascii_case("config")
        {
            self.ensure_updates_settings_overlay();
            return;
        }

        // Always surface the update settings overlay before kicking off any upgrade flow.
        self.ensure_updates_settings_overlay();

        if !crate::updates::upgrade_ui_enabled() {
            return;
        }

        match crate::updates::resolve_upgrade_resolution() {
            crate::updates::UpgradeResolution::Command { command, display } => {
                if command.is_empty() {
                    self.history_push_plain_state(history_cell::new_error_event(
                        "`/update` — no upgrade command available for this install.".to_string(),
                    ));
                    self.request_redraw();
                    return;
                }

                let latest = self.latest_upgrade_version.clone();
                self.push_background_tail(
                    "Opening a guided upgrade terminal to finish installing updates.".to_string(),
                );
                if let Some(launch) = self.launch_update_command(command, display, latest) {
                    self.app_event_tx.send(AppEvent::OpenTerminal(launch));
                }
            }
            crate::updates::UpgradeResolution::Manual { instructions } => {
                self.push_background_tail(instructions);
                self.request_redraw();
            }
        }
    }

    pub(crate) fn handle_notifications_command(&mut self, args: String) {
        let trimmed = args.trim();
        if trimmed.is_empty() {
            self.show_settings_overlay(Some(SettingsSection::Notifications));
            return;
        }

        let keyword = trimmed.split_whitespace().next().unwrap_or("").to_ascii_lowercase();
        match keyword.as_str() {
            "status" => {
                match &self.config.tui.notifications {
                    Notifications::Enabled(true) => {
                        self.push_background_tail("🔔 TUI notifications are enabled.".to_string());
                    }
                    Notifications::Enabled(false) => {
                        self.push_background_tail("🔕 TUI notifications are disabled.".to_string());
                    }
                    Notifications::Custom(entries) => {
                        let filters = if entries.is_empty() {
                            "<none>".to_string()
                        } else {
                            entries.join(", ")
                        };
                        self.push_background_tail(format!(
                            "🔔 TUI notifications use custom filters: [{}]",
                            filters
                        ));
                    }
                }
            }
            "on" | "off" => {
                let enable = keyword == "on";
                match &self.config.tui.notifications {
                    Notifications::Enabled(current) => {
                        if *current == enable {
                            self.push_background_tail(format!(
                                "TUI notifications already {}.",
                                if enable { "enabled" } else { "disabled" }
                            ));
                        } else {
                            self.app_event_tx
                                .send(AppEvent::UpdateTuiNotifications(enable));
                        }
                    }
                    Notifications::Custom(entries) => {
                        let filters = if entries.is_empty() {
                            "<none>".to_string()
                        } else {
                            entries.join(", ")
                        };
                        self.push_background_tail(format!(
                            "TUI notifications use custom filters ([{}]); edit ~/.code/config.toml to change them.",
                            filters
                        ));
                    }
                }
            }
            _ => {
                self.push_background_tail(
                    "Usage: /notifications [status|on|off]".to_string(),
                );
            }
        }
    }

    pub(crate) fn add_prompts_output(&mut self) {
        self.history_push_plain_state(history_cell::new_prompts_output());
    }

    #[allow(dead_code)]
    pub(crate) fn add_agents_output(&mut self) {
        use ratatui::text::Line;

        // Gather active agents from current UI state
        let mut lines: Vec<Line<'static>> = Vec::new();
        lines.push(Line::from("/agents").fg(crate::colors::keyword()));
        lines.push(Line::from(""));
        // Show current subagent command configuration summary
        lines.push(Line::from("Subagents configuration".bold()));
        if self.config.subagent_commands.is_empty() {
            lines.push(Line::from(
                "  • No subagent commands in config (using defaults)",
            ));
        } else {
            for cmd in &self.config.subagent_commands {
                let mode = if cmd.read_only { "read-only" } else { "write" };
                let agents = if cmd.agents.is_empty() {
                    "<inherit>".to_string()
                } else {
                    cmd.agents.join(", ")
                };
                lines.push(Line::from(format!(
                    "  • {} — {} — [{}]",
                    cmd.name, mode, agents
                )));
            }
        }
        lines.push(Line::from(""));
        lines.push(Line::from("Manage in the overlay:".bold()));
        lines.push(Line::from(
            "  /agents  — configure agents (↑↓ navigate • Enter edit • Esc back)"
                .fg(crate::colors::text_dim()),
        ));
        lines.push(Line::from(""));

        // Platform + environment summary to aid debugging
        lines.push(Line::from(vec!["🖥  ".into(), "Environment".bold()]));
        let os = std::env::consts::OS;
        let arch = std::env::consts::ARCH;
        lines.push(Line::from(format!("  • Platform: {os}-{arch}")));
        lines.push(Line::from(format!(
            "  • CWD: {}",
            self.config.cwd.display()
        )));
        let in_git = code_core::git_info::get_git_repo_root(&self.config.cwd).is_some();
        lines.push(Line::from(format!(
            "  • Git repo: {}",
            if in_git { "yes" } else { "no" }
        )));
        // PATH summary
        if let Some(path_os) = std::env::var_os("PATH") {
            let entries: Vec<String> = std::env::split_paths(&path_os)
                .map(|p| p.display().to_string())
                .collect();
            let shown = entries
                .iter()
                .take(6)
                .cloned()
                .collect::<Vec<_>>()
                .join("; ");
            let suffix = if entries.len() > 6 {
                format!(" (+{} more)", entries.len() - 6)
            } else {
                String::new()
            };
            lines.push(Line::from(format!(
                "  • PATH ({} entries): {}{}",
                entries.len(),
                shown,
                suffix
            )));
        }
        #[cfg(target_os = "windows")]
        if let Ok(pathext) = std::env::var("PATHEXT") {
            lines.push(Line::from(format!("  • PATHEXT: {}", pathext)));
        }
        lines.push(Line::from(""));

        // Section: Active agents
        lines.push(Line::from(vec!["🤖 ".into(), "Active Agents".bold()]));
        if self.active_agents.is_empty() {
            if self.agents_ready_to_start {
                lines.push(Line::from("  • preparing agents…"));
            } else {
                lines.push(Line::from("  • No active agents"));
            }
        } else {
            for a in &self.active_agents {
                let status = match a.status {
                    AgentStatus::Pending => "pending",
                    AgentStatus::Running => "running",
                    AgentStatus::Completed => "completed",
                    AgentStatus::Failed => "failed",
                    AgentStatus::Cancelled => "cancelled",
                };
                lines.push(Line::from(format!("  • {} — {}", a.name, status)));
            }
        }

        lines.push(Line::from(""));

        // Section: Availability
        lines.push(Line::from(vec!["🧭 ".into(), "Availability".bold()]));

        // Determine which agents to check: configured (enabled) or defaults
        let mut to_check: Vec<(String, String, bool)> = Vec::new();
        if !self.config.agents.is_empty() {
            for a in &self.config.agents {
                if !a.enabled {
                    continue;
                }
                let name = a.name.clone();
                let cmd = if let Some(spec) = agent_model_spec(&a.name) {
                    spec.cli.to_string()
                } else {
                    a.command.clone()
                };
                let builtin = matches!(cmd.as_str(), "code" | "codex" | "cloud");
                to_check.push((name, cmd, builtin));
            }
        } else {
            for spec in enabled_agent_model_specs() {
                let name = spec.slug.to_string();
                let cmd = spec.cli.to_string();
                let builtin = matches!(spec.cli, "code" | "codex" | "cloud");
                to_check.push((name, cmd, builtin));
            }
        }

        // Helper: PATH presence + resolved path
        let resolve_cmd = |cmd: &str| -> Option<String> {
            which::which(cmd).ok().map(|p| p.display().to_string())
        };

        for (name, cmd, builtin) in to_check {
            if builtin {
                let exe = std::env::current_exe()
                    .ok()
                    .map(|p| p.display().to_string())
                    .unwrap_or_else(|| "(unknown)".to_string());
                lines.push(Line::from(format!(
                    "  • {} — available (built-in, exe: {})",
                    name, exe
                )));
            } else if let Some(path) = resolve_cmd(&cmd) {
                lines.push(Line::from(format!(
                    "  • {} — available ({} at {})",
                    name, cmd, path
                )));
            } else {
                lines.push(Line::from(format!(
                    "  • {} — not found (command: {})",
                    name, cmd
                )));
                // Short cross-platform hint
                lines.push(Line::from(
                    "      Debug: ensure the CLI is installed and on PATH",
                ));
                lines.push(Line::from(
                    "      Windows: run `where <cmd>`; macOS/Linux: `which <cmd>`",
                ));
            }
        }

        let state = history_cell::plain_message_state_from_lines(
            lines,
            crate::history_cell::HistoryCellType::Notice,
        );
        self.history_push_plain_state(state);
        self.request_redraw();
    }

    pub(crate) fn handle_agents_command(&mut self, args: String) {
        if !args.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Usage: /agents".to_string(),
            ));
        }
        self.show_settings_overlay(Some(SettingsSection::Agents));
    }

    pub(crate) fn handle_limits_command(&mut self, args: String) {
        if !args.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Usage: /limits".to_string(),
            ));
        }
        self.show_settings_overlay(Some(SettingsSection::Limits));
    }

    pub(crate) fn handle_login_command(&mut self) {
        self.show_login_accounts_view();
    }

    pub(crate) fn auth_manager(&self) -> Arc<AuthManager> {
        self.auth_manager.clone()
    }

    pub(crate) fn reload_auth(&self) -> bool {
        self.auth_manager.reload()
    }

    pub(crate) fn show_login_accounts_view(&mut self) {
        let ticket = self.make_background_tail_ticket();
        let (view, state_rc) = LoginAccountsView::new(
            self.config.code_home.clone(),
            self.app_event_tx.clone(),
            ticket,
        );
        self.login_view_state = Some(LoginAccountsState::weak_handle(&state_rc));
        self.login_add_view_state = None;
        self.bottom_pane.show_login_accounts(view);
        self.request_redraw();
    }

    pub(crate) fn show_login_add_account_view(&mut self) {
        let ticket = self.make_background_tail_ticket();
        let (view, state_rc) = LoginAddAccountView::new(
            self.config.code_home.clone(),
            self.app_event_tx.clone(),
            ticket,
        );
        self.login_add_view_state = Some(LoginAddAccountState::weak_handle(&state_rc));
        self.login_view_state = None;
        self.bottom_pane.show_login_add_account(view);
        self.request_redraw();
    }

    fn with_login_add_view<F>(&mut self, f: F) -> bool
    where
        F: FnOnce(&mut LoginAddAccountState),
    {
        if let Some(weak) = &self.login_add_view_state {
            if let Some(state_rc) = weak.upgrade() {
                f(&mut state_rc.borrow_mut());
                self.request_redraw();
                return true;
            }
        }
        false
    }

    pub(crate) fn notify_login_chatgpt_started(&mut self, auth_url: String) {
        if self.with_login_add_view(|state| state.acknowledge_chatgpt_started(auth_url.clone())) {
            return;
        }
    }

    pub(crate) fn notify_login_chatgpt_failed(&mut self, error: String) {
        if self.with_login_add_view(|state| state.acknowledge_chatgpt_failed(error.clone())) {
            return;
        }
    }

    pub(crate) fn notify_login_chatgpt_complete(&mut self, result: Result<(), String>) {
        if self.with_login_add_view(|state| state.on_chatgpt_complete(result.clone())) {
            return;
        }
    }

    pub(crate) fn notify_login_chatgpt_cancelled(&mut self) {
        if self.with_login_add_view(|state| state.cancel_chatgpt_wait()) {
            return;
        }
    }

    pub(crate) fn login_add_view_active(&self) -> bool {
        self.login_add_view_state
            .as_ref()
            .and_then(|weak| weak.upgrade())
            .is_some()
    }

    pub(crate) fn set_using_chatgpt_auth(&mut self, using: bool) {
        self.config.using_chatgpt_auth = using;
        self.bottom_pane.set_using_chatgpt_auth(using);
    }

    fn spawn_update_refresh(&self, shared_state: std::sync::Arc<std::sync::Mutex<UpdateSharedState>>) {
        let config = self.config.clone();
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            let result = crate::updates::check_for_updates_now(&config).await;
            let mut state = shared_state.lock().expect("update state poisoned");
            match result {
                Ok(info) => {
                    state.checking = false;
                    state.latest_version = info.latest_version;
                    state.error = None;
                }
                Err(err) => {
                    state.checking = false;
                    state.latest_version = None;
                    state.error = Some(err.to_string());
                }
            }
            drop(state);
            let _ = tx.send(AppEvent::RequestRedraw);
        });
    }

    fn prepare_update_settings_view(&mut self) -> Option<UpdateSettingsView> {
        let allow_refresh = crate::updates::upgrade_ui_enabled();

        let shared_state = std::sync::Arc::new(std::sync::Mutex::new(UpdateSharedState {
            checking: allow_refresh,
            latest_version: None,
            error: None,
        }));

        let resolution = crate::updates::resolve_upgrade_resolution();
        let (command, display, instructions) = match &resolution {
            crate::updates::UpgradeResolution::Command { command, display } => (
                Some(command.clone()),
                Some(display.clone()),
                None,
            ),
            crate::updates::UpgradeResolution::Manual { instructions } => {
                (None, None, Some(instructions.clone()))
            }
        };

        let view = UpdateSettingsView::new(
            self.app_event_tx.clone(),
            self.make_background_tail_ticket(),
            code_version::version().to_string(),
            self.config.auto_upgrade_enabled,
            command,
            display,
            instructions,
            shared_state.clone(),
        );

        if allow_refresh {
            self.spawn_update_refresh(shared_state);
        }
        Some(view)
    }

    fn build_updates_settings_content(&mut self) -> Option<UpdatesSettingsContent> {
        self.prepare_update_settings_view()
            .map(UpdatesSettingsContent::new)
    }

    fn build_validation_settings_content(&mut self) -> ValidationSettingsContent {
        let groups = vec![
            (
                GroupStatus {
                    group: ValidationGroup::Functional,
                    name: "Functional checks",
                },
                self.config.validation.groups.functional,
            ),
            (
                GroupStatus {
                    group: ValidationGroup::Stylistic,
                    name: "Stylistic checks",
                },
                self.config.validation.groups.stylistic,
            ),
        ];

        let tool_rows: Vec<ToolRow> = validation_settings_view::detect_tools()
            .into_iter()
            .map(|status| {
                let group = match status.category {
                    ValidationCategory::Functional => ValidationGroup::Functional,
                    ValidationCategory::Stylistic => ValidationGroup::Stylistic,
                };
                let requested = self.validation_tool_requested(status.name);
                let group_enabled = self.validation_group_enabled(group);
                ToolRow { status, enabled: requested, group_enabled }
            })
            .collect();

        let view = ValidationSettingsView::new(groups, tool_rows, self.app_event_tx.clone());
        ValidationSettingsContent::new(view)
    }

    fn build_github_settings_content(&mut self) -> GithubSettingsContent {
        let enabled = self.config.github.check_workflows_on_push;
        let token_info = gh_actions::get_github_token().map(|(_, src)| src);
        let (ready, token_status) = match token_info {
            Some(gh_actions::TokenSource::Env) => (
                true,
                "Token: detected (env: GITHUB_TOKEN/GH_TOKEN)".to_string(),
            ),
            Some(gh_actions::TokenSource::GhCli) => (
                true,
                "Token: detected via gh auth".to_string(),
            ),
            None => (
                false,
                "Token: not set (set GH_TOKEN/GITHUB_TOKEN or run 'gh auth login')".to_string(),
            ),
        };

        let view = GithubSettingsView::new(enabled, token_status, ready, self.app_event_tx.clone());
        GithubSettingsContent::new(view)
    }

    fn build_auto_drive_settings_content(&mut self) -> AutoDriveSettingsContent {
        let review = self.auto_state.review_enabled;
        let agents = self.auto_state.subagents_enabled;
        let cross = self.auto_state.cross_check_enabled;
        let qa = self.auto_state.qa_automation_enabled;
        let mode = self.auto_state.continue_mode;
        let review_auto_resolve = self.config.tui.review_auto_resolve;
        let view = AutoDriveSettingsView::new(
            self.app_event_tx.clone(),
            review,
            agents,
            cross,
            qa,
            mode,
            review_auto_resolve,
        );
        AutoDriveSettingsContent::new(view)
    }

    fn ensure_updates_settings_overlay(&mut self) {
        if self.settings.overlay.is_none() {
            self.show_settings_overlay(Some(SettingsSection::Updates));
            return;
        }
        if let Some(content) = self.build_updates_settings_content() {
            if let Some(overlay) = self.settings.overlay.as_mut() {
                overlay.set_updates_content(content);
            }
        }
        self.ensure_settings_overlay_section(SettingsSection::Updates);
        self.request_redraw();
    }

    fn ensure_validation_settings_overlay(&mut self) {
        if self.settings.overlay.is_none() {
            self.show_settings_overlay(Some(SettingsSection::Validation));
            return;
        }
        let content = self.build_validation_settings_content();
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_validation_content(content);
        }
        self.ensure_settings_overlay_section(SettingsSection::Validation);
        self.request_redraw();
    }

    fn ensure_github_settings_overlay(&mut self) {
        if self.settings.overlay.is_none() {
            self.show_settings_overlay(Some(SettingsSection::Github));
            return;
        }
        let content = self.build_github_settings_content();
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_github_content(content);
        }
        self.ensure_settings_overlay_section(SettingsSection::Github);
        self.request_redraw();
    }

    fn ensure_auto_drive_settings_overlay(&mut self) {
        if self.settings.overlay.is_none() {
            self.show_settings_overlay(Some(SettingsSection::AutoDrive));
            return;
        }
        let content = self.build_auto_drive_settings_content();
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_auto_drive_content(content);
        }
        self.ensure_settings_overlay_section(SettingsSection::AutoDrive);
        self.request_redraw();
    }

    pub(crate) fn show_agents_overview_ui(&mut self) {
        let (rows, commands) = self.collect_agents_overview_rows();
        let total_rows = rows
            .len()
            .saturating_add(commands.len())
            .saturating_add(1);
        let selected = if total_rows == 0 {
            0
        } else {
            self
                .agents_overview_selected_index
                .min(total_rows.saturating_sub(1))
        };
        self.agents_overview_selected_index = selected;

        self.ensure_settings_overlay_section(SettingsSection::Agents);

        let updated = self.try_update_agents_settings_overview(
            rows.clone(),
            commands.clone(),
            selected,
        );

        if !updated {
            if let Some(overlay) = self.settings.overlay.as_mut() {
                let content = AgentsSettingsContent::new_overview(
                    rows,
                    commands,
                    selected,
                    self.app_event_tx.clone(),
                );
                overlay.set_agents_content(content);
            }
        }

        self.request_redraw();
    }

    fn try_update_agents_settings_overview(
        &mut self,
        rows: Vec<AgentOverviewRow>,
        commands: Vec<String>,
        selected: usize,
    ) -> bool {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_overview(rows, commands, selected);
                } else {
                    overlay.set_agents_content(AgentsSettingsContent::new_overview(
                        rows,
                        commands,
                        selected,
                        self.app_event_tx.clone(),
                    ));
                }
                return true;
            }
        }
        false
    }

    fn try_set_agents_settings_editor(&mut self, editor: SubagentEditorView) -> bool {
        let mut editor = Some(editor);
        let mut needs_content = false;

        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_editor(editor.take().expect("editor set once"));
                    self.request_redraw();
                    return true;
                } else {
                    needs_content = true;
                }
            }
        }

        if needs_content {
            let (rows, commands) = self.collect_agents_overview_rows();
            let total = rows.len().saturating_add(commands.len()).saturating_add(1);
            let selected = if total == 0 {
                0
            } else {
                self.agents_overview_selected_index.min(total.saturating_sub(1))
            };
            self.agents_overview_selected_index = selected;

            if let Some(overlay) = self.settings.overlay.as_mut() {
                if overlay.active_section() == SettingsSection::Agents {
                    let mut content = AgentsSettingsContent::new_overview(
                        rows,
                        commands,
                        selected,
                        self.app_event_tx.clone(),
                    );
                    content.set_editor(editor.take().expect("editor set once"));
                    overlay.set_agents_content(content);
                    self.request_redraw();
                    return true;
                }
            }
        }

        false
    }

    fn try_set_agents_settings_agent_editor(&mut self, editor: AgentEditorView) -> bool {
        let mut editor = Some(editor);
        let mut needs_content = false;

        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_agent_editor(editor.take().expect("editor set once"));
                    self.request_redraw();
                    return true;
                } else {
                    needs_content = true;
                }
            }
        }

        if needs_content {
            let (rows, commands) = self.collect_agents_overview_rows();
            let total = rows.len().saturating_add(commands.len()).saturating_add(1);
            let selected = if total == 0 {
                0
            } else {
                self.agents_overview_selected_index.min(total.saturating_sub(1))
            };
            self.agents_overview_selected_index = selected;

            if let Some(overlay) = self.settings.overlay.as_mut() {
                if overlay.active_section() == SettingsSection::Agents {
                    let mut content = AgentsSettingsContent::new_overview(
                        rows,
                        commands,
                        selected,
                        self.app_event_tx.clone(),
                    );
                    content.set_agent_editor(editor.take().expect("editor set once"));
                    overlay.set_agents_content(content);
                    self.request_redraw();
                    return true;
                }
            }
        }

        false
    }

    pub(crate) fn set_agents_overview_selection(&mut self, index: usize) {
        self.agents_overview_selected_index = index;
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_overview_selection(index);
                }
            }
        }
    }

    fn agent_batch_metadata(&self, batch_id: &str) -> AgentBatchMetadata {
        if let Some(key) = self.tools_state.agent_run_by_batch.get(batch_id) {
            if let Some(tracker) = self.tools_state.agent_runs.get(key) {
                return AgentBatchMetadata {
                    label: tracker.overlay_display_label(),
                    prompt: tracker.overlay_task(),
                    context: tracker.overlay_context(),
                };
            }
        }
        AgentBatchMetadata::default()
    }

    fn append_agents_overlay_section(
        &self,
        lines: &mut Vec<ratatui::text::Line<'static>>,
        title: &str,
        text: &str,
    ) {
        let trimmed = text.trim();
        if trimmed.is_empty() {
            return;
        }
        let header_style = ratatui::style::Style::default()
            .fg(crate::colors::text())
            .add_modifier(ratatui::style::Modifier::BOLD);
        lines.push(ratatui::text::Line::from(vec![
            ratatui::text::Span::raw(" "),
            ratatui::text::Span::styled(title.to_string(), header_style),
        ]));
        for raw_line in trimmed.lines() {
            let content = raw_line.trim_end();
            lines.push(ratatui::text::Line::from(vec![
                ratatui::text::Span::raw("   "),
                ratatui::text::Span::styled(
                    content.to_string(),
                    ratatui::style::Style::default().fg(crate::colors::text()),
                ),
            ]));
        }
    }

    fn append_agent_log_lines(
        &self,
        lines: &mut Vec<ratatui::text::Line<'static>>,
        timestamp: DateTime<Local>,
        kind: AgentLogKind,
        message: &str,
        agent_label: Option<&str>,
    ) {
        use ratatui::style::{Modifier, Style};
        use ratatui::text::{Line, Span};

        let timestamp_text = format!("[{timestamp}] ", timestamp = timestamp.format("%H:%M:%S"));
        let label = agent_log_label(kind);
        let label_prefix = format!("{label}: ");
        let timestamp_style = Style::default().fg(crate::colors::text_dim());
        let label_style = Style::default()
            .fg(agent_log_color(kind))
            .add_modifier(Modifier::BOLD);
        let message_style = Style::default().fg(crate::colors::text());
        let agent_label_string = agent_label.map(|label_text| format!("{label_text} "));
        let agent_style = Style::default()
            .fg(crate::colors::text_dim())
            .add_modifier(Modifier::BOLD);

        let indent_len = 1
            + timestamp_text.chars().count()
            + agent_label_string
                .as_ref()
                .map(|value| value.chars().count())
                .unwrap_or(0)
            + label_prefix.chars().count();
        let indent_string = " ".repeat(indent_len);

        let mut prefix_spans = vec![
            Span::raw(" "),
            Span::styled(timestamp_text.clone(), timestamp_style),
        ];
        if let Some(agent_text) = agent_label_string.as_ref() {
            prefix_spans.push(Span::styled(agent_text.clone(), agent_style));
        }
        prefix_spans.push(Span::styled(label_prefix.clone(), label_style));

        match kind {
            AgentLogKind::Result => {
                let mut markdown_lines: Vec<Line<'static>> = Vec::new();
                crate::markdown::append_markdown(message, &mut markdown_lines, &self.config);
                if markdown_lines.is_empty() {
                    let mut spans = prefix_spans.clone();
                    spans.push(Span::styled(
                        "(no result)".to_string(),
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                    lines.push(Line::from(spans));
                    return;
                }

                let mut markdown_iter = markdown_lines.into_iter();
                if let Some(mut first) = markdown_iter.next() {
                    let mut spans = prefix_spans.clone();
                    spans.extend(first.spans.drain(..));
                    lines.push(Line::from(spans));
                }
                for md_line in markdown_iter {
                    let mut spans = vec![Span::raw(indent_string.clone())];
                    spans.extend(md_line.spans);
                    lines.push(Line::from(spans));
                }
            }
            _ => {
                let mut parts = message.split('\n');
                let first = parts.next().unwrap_or("");
                let mut spans = prefix_spans.clone();
                spans.push(Span::styled(first.to_string(), message_style));
                lines.push(Line::from(spans));
                for part in parts {
                    lines.push(Line::from(vec![
                        Span::raw(indent_string.clone()),
                        Span::styled(part.to_string(), message_style),
                    ]));
                }
            }
        }
    }

    fn ensure_trailing_blank_line(
        &self,
        lines: &mut Vec<ratatui::text::Line<'static>>,
    ) {
        if lines
            .last()
            .map(|line| {
                line.spans.is_empty()
                    || (line.spans.len() == 1 && line.spans[0].content.is_empty())
            })
            .unwrap_or(false)
        {
            return;
        }
        lines.push(ratatui::text::Line::from(""));
    }

    fn update_agents_terminal_state(
        &mut self,
        agents: &[code_core::protocol::AgentInfo],
        context: Option<String>,
        task: Option<String>,
    ) {
        self.agents_terminal.shared_context = context;
        self.agents_terminal.shared_task = task;

        let mut saw_new_agent = false;
        for info in agents {
            let status = agent_status_from_str(info.status.as_str());
            let batch_metadata = info
                .batch_id
                .as_deref()
                .map(|id| self.agent_batch_metadata(id))
                .unwrap_or_default();
            let is_new = !self.agents_terminal.entries.contains_key(&info.id);
            if is_new
                && !self
                    .agents_terminal
                    .order
                    .iter()
                    .any(|id| id == &info.id)
            {
                self.agents_terminal.order.push(info.id.clone());
                saw_new_agent = true;
            }

            let entry = self.agents_terminal.entries.entry(info.id.clone());
            let entry = entry.or_insert_with(|| {
                saw_new_agent = true;
                let mut new_entry = AgentTerminalEntry::new(
                    info.name.clone(),
                    info.model.clone(),
                    status.clone(),
                    info.batch_id.clone(),
                );
                new_entry.push_log(
                    AgentLogKind::Status,
                    format!("Status → {}", agent_status_label(status.clone())),
                );
                new_entry
            });

            entry.name = info.name.clone();
            entry.batch_id = info.batch_id.clone();
            entry.model = info.model.clone();

            let AgentBatchMetadata { label, prompt: meta_prompt, context: meta_context } = batch_metadata;
            let previous_label = entry.batch_label.clone();
            entry.batch_label = label
                .or_else(|| info.batch_id.clone())
                .or(previous_label);

            let fallback_prompt = self
                .agents_terminal
                .shared_task
                .clone()
                .or_else(|| self.agent_task.clone());
            let previous_prompt = entry.batch_prompt.clone();
            entry.batch_prompt = meta_prompt
                .or(fallback_prompt)
                .or(previous_prompt);

            let fallback_context = self
                .agents_terminal
                .shared_context
                .clone()
                .or_else(|| self.agent_context.clone());
            let previous_context = entry.batch_context.clone();
            entry.batch_context = meta_context
                .or(fallback_context)
                .or(previous_context);

            if entry.status != status {
                entry.status = status.clone();
                entry.push_log(
                    AgentLogKind::Status,
                    format!("Status → {}", agent_status_label(status.clone())),
                );
            }

            if let Some(progress) = info.last_progress.as_ref() {
                if entry.last_progress.as_ref() != Some(progress) {
                    entry.last_progress = Some(progress.clone());
                    entry.push_log(AgentLogKind::Progress, progress.clone());
                }
            }

            if let Some(result) = info.result.as_ref() {
                if entry.result.as_ref() != Some(result) {
                    entry.result = Some(result.clone());
                    entry.push_log(AgentLogKind::Result, result.clone());
                }
            }

            if let Some(error) = info.error.as_ref() {
                if entry.error.as_ref() != Some(error) {
                    entry.error = Some(error.clone());
                    entry.push_log(AgentLogKind::Error, error.clone());
                }
            }
        }

        self.agents_terminal.clamp_selected_index();

        if saw_new_agent && self.agents_terminal.active {
            self.layout.scroll_offset = 0;
        }
    }

    fn enter_agents_terminal_mode(&mut self) {
        if self.agents_terminal.active {
            return;
        }
        self.browser_overlay_visible = false;
        self.agents_terminal.active = true;
        self.agents_terminal.focus_sidebar();
        self.bottom_pane.set_input_focus(false);
        self.agents_terminal.saved_scroll_offset = self.layout.scroll_offset;
        if self.agents_terminal.order.is_empty() {
            for agent in &self.active_agents {
                if !self
                    .agents_terminal
                    .entries
                    .contains_key(&agent.id)
                {
                    self.agents_terminal.order.push(agent.id.clone());
                    let mut entry = AgentTerminalEntry::new(
                        agent.name.clone(),
                        agent.model.clone(),
                        agent.status.clone(),
                        agent.batch_id.clone(),
                    );
                    let batch_metadata = agent
                        .batch_id
                        .as_deref()
                        .map(|id| self.agent_batch_metadata(id))
                        .unwrap_or_default();
                    let AgentBatchMetadata { label, prompt: meta_prompt, context: meta_context } = batch_metadata;
                    entry.batch_label = label
                        .or_else(|| agent.batch_id.clone())
                        .or(entry.batch_label.clone());
                    let fallback_prompt = self
                        .agents_terminal
                        .shared_task
                        .clone()
                        .or_else(|| self.agent_task.clone());
                    entry.batch_prompt = meta_prompt
                        .or(fallback_prompt)
                        .or(entry.batch_prompt.clone());
                    let fallback_context = self
                        .agents_terminal
                        .shared_context
                        .clone()
                        .or_else(|| self.agent_context.clone());
                    entry.batch_context = meta_context
                        .or(fallback_context)
                        .or(entry.batch_context.clone());
                    if let Some(progress) = agent.last_progress.as_ref() {
                        entry.last_progress = Some(progress.clone());
                        entry.push_log(AgentLogKind::Progress, progress.clone());
                    }
                    if let Some(result) = agent.result.as_ref() {
                        entry.result = Some(result.clone());
                        entry.push_log(AgentLogKind::Result, result.clone());
                    }
                    if let Some(error) = agent.error.as_ref() {
                        entry.error = Some(error.clone());
                        entry.push_log(AgentLogKind::Error, error.clone());
                    }
                    self.agents_terminal
                        .entries
                        .insert(agent.id.clone(), entry);
                }
            }
        }
        self.agents_terminal.clamp_selected_index();
        self.restore_selected_agent_scroll();
        self.request_redraw();
    }

    fn exit_agents_terminal_mode(&mut self) {
        if !self.agents_terminal.active {
            return;
        }
        self.record_current_agent_scroll();
        self.agents_terminal.active = false;
        self.agents_terminal.focus_sidebar();
        self.layout.scroll_offset = self.agents_terminal.saved_scroll_offset;
        self.bottom_pane.set_input_focus(true);
        self.request_redraw();
    }

    fn record_current_agent_scroll(&mut self) {
        if let Some(entry) = self.agents_terminal.current_sidebar_entry() {
            let capped = self
                .layout
                .scroll_offset
                .min(self.layout.last_max_scroll.get());
            self.agents_terminal
                .scroll_offsets
                .insert(entry.scroll_key(), capped);
        }
    }

    fn restore_selected_agent_scroll(&mut self) {
        let offset = self
            .agents_terminal
            .current_sidebar_entry()
            .and_then(|entry| {
                self.agents_terminal
                    .scroll_offsets
                    .get(&entry.scroll_key())
                    .copied()
            })
            .unwrap_or(0);
        self.layout.scroll_offset = offset;
    }

    fn navigate_agents_terminal_selection(&mut self, delta: isize) {
        let entries = self.agents_terminal.sidebar_entries();
        if entries.is_empty() {
            return;
        }
        self.agents_terminal.focus_sidebar();
        let len = entries.len() as isize;
        self.record_current_agent_scroll();
        let mut new_index = self.agents_terminal.selected_index as isize + delta;
        if new_index >= len {
            new_index %= len;
        }
        while new_index < 0 {
            new_index += len;
        }
        self.agents_terminal.selected_index = new_index as usize;
        self.agents_terminal.clamp_selected_index();
        self.restore_selected_agent_scroll();
        self.request_redraw();
    }
    fn resolve_agent_install_command(&self, agent_name: &str) -> Option<(Vec<String>, String)> {
        let cmd = self
            .config
            .agents
            .iter()
            .find(|a| a.name.eq_ignore_ascii_case(agent_name))
            .map(|cfg| cfg.command.clone())
            .filter(|s| !s.trim().is_empty())
            .unwrap_or_else(|| agent_name.to_string());
        if cmd.trim().is_empty() {
            return None;
        }

        #[cfg(target_os = "windows")]
        {
            let script = format!(
                "if (Get-Command {cmd} -ErrorAction SilentlyContinue) {{ Write-Output \"{cmd} already installed\"; exit 0 }} else {{ Write-Warning \"{cmd} is not installed.\"; Write-Output \"Please install {cmd} via winget, Chocolatey, or the vendor installer.\"; exit 1 }}",
                cmd = cmd
            );
            let command = vec![
                "powershell.exe".to_string(),
                "-NoProfile".to_string(),
                "-ExecutionPolicy".to_string(),
                "Bypass".to_string(),
                "-Command".to_string(),
                script.clone(),
            ];
            return Some((command, format!("PowerShell install check for {cmd}")));
        }

        #[cfg(target_os = "macos")]
        {
            let brew_formula = macos_brew_formula_for_command(&cmd);
            let script = format!("brew install {brew_formula}");
            let command = vec!["/bin/bash".to_string(), "-lc".to_string(), script.clone()];
            return Some((command, script));
        }

        #[cfg(not(any(target_os = "windows", target_os = "macos")))]
        {
            fn linux_agent_install_script(agent_cmd: &str, npm_package: &str) -> String {
                format!(
                    "set -euo pipefail\n\
if ! command -v npm >/dev/null 2>&1; then\n\
    echo \"npm is required to install {agent_cmd}. Install Node.js 20+ and rerun.\" >&2\n\
    exit 1\n\
fi\n\
prefix=\"$(npm config get prefix 2>/dev/null || true)\"\n\
if [ -z \"$prefix\" ] || [ ! -w \"$prefix\" ]; then\n\
    prefix=\"$HOME/.npm-global\"\n\
fi\n\
mkdir -p \"$prefix/bin\"\n\
export PATH=\"$prefix/bin:$PATH\"\n\
export npm_config_prefix=\"$prefix\"\n\
node_major=0\n\
if command -v node >/dev/null 2>&1; then\n\
    node_major=\"$(node -v | sed 's/^v\\([0-9][0-9]*\\).*/\\1/')\"\n\
fi\n\
if [ \"$node_major\" -lt 20 ]; then\n\
    npm install -g n\n\
    export N_PREFIX=\"${{N_PREFIX:-$HOME/.n}}\"\n\
    mkdir -p \"$N_PREFIX/bin\"\n\
    export PATH=\"$N_PREFIX/bin:$PATH\"\n\
    n 20.18.1\n\
    hash -r\n\
    node_major=\"$(node -v | sed 's/^v\\([0-9][0-9]*\\).*/\\1/')\"\n\
    if [ \"$node_major\" -lt 20 ]; then\n\
        echo \"Failed to activate Node.js 20+. Check that $N_PREFIX/bin is on PATH.\" >&2\n\
        exit 1\n\
    fi\n\
else\n\
    export N_PREFIX=\"${{N_PREFIX:-$HOME/.n}}\"\n\
    if [ -d \"$N_PREFIX/bin\" ]; then\n\
        export PATH=\"$N_PREFIX/bin:$PATH\"\n\
    fi\n\
fi\n\
npm install -g {npm_package}\n\
hash -r\n\
if ! command -v {agent_cmd} >/dev/null 2>&1; then\n\
    echo \"{agent_cmd} installed but not found on PATH. Add 'export PATH=\\\"$prefix/bin:$PATH\\\"' to your shell profile.\" >&2\n\
    exit 1\n\
fi\n\
{agent_cmd} --version\n",
                    agent_cmd = agent_cmd,
                    npm_package = npm_package,
                )
            }

            let lowercase = agent_name.trim().to_ascii_lowercase();
            let script = match lowercase.as_str() {
                "claude" => linux_agent_install_script(&cmd, "@anthropic-ai/claude-code"),
                "gemini" => linux_agent_install_script(&cmd, "@google/gemini-cli"),
                "qwen" => linux_agent_install_script(&cmd, "@qwen-code/qwen-code"),
                _ => format!(
                    "{cmd} --version || (echo \"Please install {cmd} via your package manager\" && false)",
                    cmd = cmd
                ),
            };
            let command = vec!["/bin/bash".to_string(), "-lc".to_string(), script.clone()];
            return Some((command, script));
        }

        #[allow(unreachable_code)]
        {
            None
        }
    }

    pub(crate) fn launch_agent_install(
        &mut self,
        name: String,
        selected_index: usize,
    ) -> Option<TerminalLaunch> {
        self.agents_overview_selected_index = selected_index;
        let Some((_, default_command)) = self.resolve_agent_install_command(&name) else {
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "No install command available for agent '{name}' on this platform."
            )));
            self.show_agents_overview_ui();
            return None;
        };
        let id = self.terminal.alloc_id();
        self.terminal.after = Some(TerminalAfter::RefreshAgentsAndClose { selected_index });
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let cwd = self.config.cwd.to_string_lossy().to_string();
        self.push_background_before_next_output(format!(
            "Starting guided install for agent '{name}'"
        ));
        start_agent_install_session(
            self.app_event_tx.clone(),
            id,
            name.clone(),
            default_command.clone(),
            Some(cwd),
            controller.clone(),
            controller_rx,
            selected_index,
            self.config.debug,
        );
        Some(TerminalLaunch {
            id,
            title: format!("Install {name}"),
            command: Vec::new(),
            command_display: "Preparing install assistant…".to_string(),
            controller: Some(controller),
            auto_close_on_success: false,
            start_running: true,
        })
    }

    pub(crate) fn launch_validation_tool_install(
        &mut self,
        tool_name: &str,
        install_hint: &str,
    ) -> Option<TerminalLaunch> {
        let trimmed = install_hint.trim();
        if trimmed.is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "No install command available for validation tool '{tool_name}'."
            )));
            self.request_redraw();
            return None;
        }

        let wrapped = wrap_command(trimmed);
        if wrapped.is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "Unable to build install command for validation tool '{tool_name}'."
            )));
            self.request_redraw();
            return None;
        }

        let id = self.terminal.alloc_id();
        let display = Self::truncate_with_ellipsis(trimmed, 128);
        let launch = TerminalLaunch {
            id,
            title: format!("Install {tool_name}"),
            command: wrapped,
            command_display: display,
            controller: None,
            auto_close_on_success: false,
            start_running: true,
        };

        self.push_background_before_next_output(format!(
            "Installing validation tool '{tool_name}' with `{trimmed}`"
        ));
        Some(launch)
    }

    fn try_handle_terminal_shortcut(&mut self, raw_text: &str) -> bool {
        let trimmed = raw_text.trim_start();
        if let Some(rest) = trimmed.strip_prefix("$$") {
            let prompt = rest.trim();
            if prompt.is_empty() {
                self.history_push_plain_state(history_cell::new_error_event(
                    "No prompt provided after '$$'.".to_string(),
                ));
                self.app_event_tx.send(AppEvent::RequestRedraw);
            } else {
                self.launch_guided_terminal_prompt(prompt);
            }
            return true;
        }
        if let Some(rest) = trimmed.strip_prefix('$') {
            let command = rest.trim();
            if command.is_empty() {
                self.launch_manual_terminal();
            } else {
                self.run_terminal_command(command);
            }
            return true;
        }
        false
    }

    fn launch_manual_terminal(&mut self) {
        let id = self.terminal.alloc_id();
        let launch = TerminalLaunch {
            id,
            title: "Shell".to_string(),
            command: Vec::new(),
            command_display: String::new(),
            controller: None,
            auto_close_on_success: false,
            start_running: false,
        };
        self.app_event_tx.send(AppEvent::OpenTerminal(launch));
    }

    fn run_terminal_command(&mut self, command: &str) {
        if wrap_command(command).is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Unable to build shell command for execution.".to_string(),
            ));
            self.app_event_tx.send(AppEvent::RequestRedraw);
            return;
        }

        let id = self.terminal.alloc_id();
        let title = Self::truncate_with_ellipsis(&format!("Shell: {command}"), 64);
        let display = Self::truncate_with_ellipsis(command, 128);
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let launch = TerminalLaunch {
            id,
            title,
            command: Vec::new(),
            command_display: display,
            controller: Some(controller.clone()),
            auto_close_on_success: false,
            start_running: true,
        };
        self.push_background_before_next_output(format!(
            "Terminal command: {command}"
        ));
        self.app_event_tx.send(AppEvent::OpenTerminal(launch));
        let cwd = self.config.cwd.to_string_lossy().to_string();
        start_direct_terminal_session(
            self.app_event_tx.clone(),
            id,
            command.to_string(),
            Some(cwd),
            controller,
            controller_rx,
            self.config.debug,
        );
    }

    fn launch_guided_terminal_prompt(&mut self, prompt: &str) {
        let id = self.terminal.alloc_id();
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let cwd = self.config.cwd.to_string_lossy().to_string();
        let title = Self::truncate_with_ellipsis(&format!("Guided: {prompt}"), 64);
        let display = Self::truncate_with_ellipsis(prompt, 128);

        let launch = TerminalLaunch {
            id,
            title,
            command: Vec::new(),
            command_display: display.clone(),
            controller: Some(controller.clone()),
            auto_close_on_success: false,
            start_running: true,
        };

        self.push_background_before_next_output(format!(
            "Guided terminal request: {prompt}"
        ));
        self.app_event_tx.send(AppEvent::OpenTerminal(launch));
        start_prompt_terminal_session(
            self.app_event_tx.clone(),
            id,
            prompt.to_string(),
            Some(cwd),
            controller,
            controller_rx,
            self.config.debug,
        );
    }

    fn is_cli_running(&self) -> bool {
        if !self.exec.running_commands.is_empty() {
            return true;
        }
        if !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty()
        {
            return true;
        }
        if self.stream.is_write_cycle_active() {
            return true;
        }
        if !self.active_task_ids.is_empty() {
            return true;
        }
        false
    }

    fn refresh_auto_drive_visuals(&mut self) {
        if self.auto_state.is_active()
            || self.auto_state.should_show_goal_entry()
            || self.auto_state.last_run_summary.is_some()
        {
            self.auto_rebuild_live_ring();
        }
    }

    fn auto_reduced_motion_preference() -> bool {
        match std::env::var("CODE_TUI_REDUCED_MOTION") {
            Ok(value) => {
                let normalized = value.trim().to_ascii_lowercase();
                !matches!(normalized.as_str(), "" | "0" | "false" | "off" | "no")
            }
            Err(_) => false,
        }
    }

    fn auto_reset_intro_timing(&mut self) {
        self.auto_state.reset_intro_timing();
    }

    fn auto_ensure_intro_timing(&mut self) {
        let reduced_motion = Self::auto_reduced_motion_preference();
        self.auto_state.ensure_intro_timing(reduced_motion);
    }

    fn auto_show_goal_entry_panel(&mut self) {
        self.auto_state.set_phase(AutoRunPhase::AwaitingGoalEntry);
        self.auto_state.goal = None;
        self.auto_pending_goal_request = false;

        self.auto_goal_bootstrap_done = false;
        let seed_intro = self.auto_state.take_intro_pending();
        if seed_intro {
            self.auto_reset_intro_timing();
            self.auto_ensure_intro_timing();
        }
        self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        let hint = "Let's do this! What's your goal?".to_string();
        let status_lines = vec![hint];
        let model = AutoCoordinatorViewModel::Active(AutoActiveViewModel {
            goal: None,
            status_lines,
            cli_prompt: None,
            cli_context: None,
            show_composer: true,
            awaiting_submission: false,
            waiting_for_response: false,
            coordinator_waiting: false,
            waiting_for_review: false,
            countdown: None,
            button: None,
            manual_hint: None,
            ctrl_switch_hint: String::new(),
            cli_running: false,
            turns_completed: 0,
            started_at: None,
            elapsed: None,
            progress_past: None,
            progress_current: None,
            editing_prompt: false,
            intro_started_at: self.auto_state.intro_started_at,
            intro_reduced_motion: self.auto_state.intro_reduced_motion,
        });
        self.bottom_pane.show_auto_coordinator_view(model);
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.update_status_text("Auto Drive".to_string());
        self.auto_update_terminal_hint();
        self.bottom_pane.ensure_input_focus();
        self.clear_composer();
        self.request_redraw();
    }

    fn auto_exit_goal_entry_preserve_draft(&mut self) -> bool {
        if !self.auto_state.should_show_goal_entry() {
            return false;
        }

        let last_run_summary = self.auto_state.last_run_summary.clone();
        let last_decision_summary = self.auto_state.last_decision_summary.clone();
        let last_decision_progress_past = self.auto_state.last_decision_progress_past.clone();
        let last_decision_progress_current =
            self.auto_state.last_decision_progress_current.clone();
        let last_decision_display = self.auto_state.last_decision_display.clone();
        let last_decision_display_is_summary = self.auto_state.last_decision_display_is_summary;

        self.auto_state.reset();
        self.auto_state.last_run_summary = last_run_summary;
        self.auto_state.last_decision_summary = last_decision_summary;
        self.auto_state.last_decision_progress_past = last_decision_progress_past;
        self.auto_state.last_decision_progress_current = last_decision_progress_current;
        self.auto_state.last_decision_display = last_decision_display;
        self.auto_state.last_decision_display_is_summary = last_decision_display_is_summary;
        self.auto_state.set_phase(AutoRunPhase::Idle);
        self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        self.bottom_pane.clear_auto_coordinator_view(true);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.update_status_text(String::new());
        self.auto_rebuild_live_ring();
        self.request_redraw();
        true
    }

    fn auto_launch_with_goal(
        &mut self,
        goal: String,
        derive_goal_from_history: bool,
        review_enabled: bool,
        subagents_enabled: bool,
        cross_check_enabled: bool,
        qa_automation_enabled: bool,
        continue_mode: AutoContinueMode,
    ) {
        let conversation = self.rebuild_auto_history();
        let reduced_motion = Self::auto_reduced_motion_preference();
        self.auto_state.prepare_launch(
            goal.clone(),
            review_enabled,
            subagents_enabled,
            cross_check_enabled,
            qa_automation_enabled,
            continue_mode,
            reduced_motion,
        );
        self.auto_review_pending = false;
        self.auto_review_cleanup = None;
        self.pending_review_commit = None;
        self.config.auto_drive.cross_check_enabled = cross_check_enabled;
        self.config.auto_drive.qa_automation_enabled = qa_automation_enabled;
        let coordinator_events = {
            let app_event_tx = self.app_event_tx.clone();
            AutoCoordinatorEventSender::new(move |event| {
                match event {
                    AutoCoordinatorEvent::Decision {
                        status,
                        progress_past,
                        progress_current,
                        goal,
                        cli,
                        agents_timing,
                        agents,
                        transcript,
                        turn_descriptor,
                        review_commit,
                    } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorDecision {
                            status,
                            progress_past,
                            progress_current,
                            goal,
                            cli,
                            agents_timing,
                            agents,
                            transcript,
                            turn_descriptor,
                            review_commit,
                        });
                    }
                    AutoCoordinatorEvent::Thinking { delta, summary_index } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorThinking { delta, summary_index });
                    }
                    AutoCoordinatorEvent::UserReply {
                        user_response,
                        cli_command,
                    } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorUserReply {
                            user_response,
                            cli_command,
                        });
                    }
                }
            })
        };

        match start_auto_coordinator(
            coordinator_events,
            goal.clone(),
            conversation,
            self.config.clone(),
            self.config.debug,
            derive_goal_from_history,
        ) {
            Ok(handle) => {
                self.auto_handle = Some(handle);
                let placeholder = auto_drive_strings::next_auto_drive_phrase().to_string();
                let effects = self
                    .auto_state
                    .launch_succeeded(goal.clone(), Some(placeholder), Instant::now());
                self.auto_apply_controller_effects(effects);
            }
            Err(err) => {
                let effects = self
                    .auto_state
                    .launch_failed(goal.clone(), err.to_string());
                self.auto_apply_controller_effects(effects);
            }
        }
    }

    pub(crate) fn handle_auto_command(&mut self, goal: Option<String>) {
        let provided = goal.unwrap_or_default();
        let trimmed = provided.trim();

        if trimmed.eq_ignore_ascii_case("settings") {
            self.ensure_auto_drive_settings_overlay();
            return;
        }

        let full_auto_enabled = matches!(
            (&self.config.sandbox_policy, self.config.approval_policy),
            (SandboxPolicy::DangerFullAccess, AskForApproval::Never)
        );

        if !full_auto_enabled && !(trimmed.is_empty() && self.auto_state.is_active()) {
            self.push_background_tail(
                "Please use Shift+Tab to switch to Full Auto before using Auto Drive"
                    .to_string(),
            );
            self.request_redraw();
            return;
        }
        if trimmed.is_empty() {
            if self.auto_state.is_active() {
                self.auto_stop(None);
            }
            let started = self.auto_start_bootstrap_from_history();
            if !started {
                self.auto_state.reset();
                self.auto_state.set_phase(AutoRunPhase::Idle);
                self.auto_show_goal_entry_panel();
            }
            self.request_redraw();
            return;
        }

        let goal_text = trimmed.to_string();

        if self.auto_state.is_active() {
            self.auto_stop(None);
        }

        let defaults = self.config.auto_drive.clone();
        let default_mode = auto_continue_from_config(defaults.continue_mode);

        self.auto_state.mark_intro_pending();
        self.auto_launch_with_goal(
            goal_text,
            false,
            defaults.review_enabled,
            defaults.agents_enabled,
            defaults.cross_check_enabled,
            defaults.qa_automation_enabled,
            default_mode,
        );
    }

    pub(crate) fn show_auto_drive_settings(&mut self) {
        self.ensure_auto_drive_settings_overlay();
    }

    pub(crate) fn close_auto_drive_settings(&mut self) {
        if matches!(
            self.settings
                .overlay
                .as_ref()
                .map(|overlay| overlay.active_section()),
            Some(SettingsSection::AutoDrive)
        ) {
            self.close_settings_overlay();
        }
        let should_rebuild_view = if self.auto_state.is_active() {
            !self.auto_state.is_paused_manual()
        } else {
            self.auto_state.should_show_goal_entry() || self.auto_state.last_run_summary.is_some()
        };

        if should_rebuild_view {
            self.auto_rebuild_live_ring();
        }
        self.bottom_pane.ensure_input_focus();
    }

    pub(crate) fn apply_auto_drive_settings(
        &mut self,
        review_enabled: bool,
        agents_enabled: bool,
        cross_check_enabled: bool,
        qa_automation_enabled: bool,
        continue_mode: AutoContinueMode,
        review_auto_resolve: bool,
    ) {
        let mut changed = false;
        if self.auto_state.review_enabled != review_enabled {
            self.auto_state.review_enabled = review_enabled;
            changed = true;
        }
        if self.auto_state.subagents_enabled != agents_enabled {
            self.auto_state.subagents_enabled = agents_enabled;
            changed = true;
        }
        if self.auto_state.cross_check_enabled != cross_check_enabled {
            self.auto_state.cross_check_enabled = cross_check_enabled;
            changed = true;
        }
        if self.auto_state.qa_automation_enabled != qa_automation_enabled {
            self.auto_state.qa_automation_enabled = qa_automation_enabled;
            changed = true;
        }
        if self.auto_state.continue_mode != continue_mode {
            let effects = self.auto_state.update_continue_mode(continue_mode);
            self.auto_apply_controller_effects(effects);
            changed = true;
        }
        if self.config.tui.review_auto_resolve != review_auto_resolve {
            self.config.tui.review_auto_resolve = review_auto_resolve;
            changed = true;
            if let Ok(home) = code_core::config::find_code_home() {
                if let Err(err) = code_core::config::set_tui_review_auto_resolve(&home, review_auto_resolve) {
                    tracing::warn!("Failed to persist review auto resolve setting: {err}");
                }
            }
        }

        if !changed {
            return;
        }

        self.config.auto_drive.review_enabled = review_enabled;
        self.config.auto_drive.agents_enabled = agents_enabled;
        self.config.auto_drive.cross_check_enabled = cross_check_enabled;
        self.config.auto_drive.qa_automation_enabled = qa_automation_enabled;
        self.config.auto_drive.continue_mode = auto_continue_to_config(continue_mode);

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) =
                code_core::config::set_auto_drive_settings(&home, &self.config.auto_drive)
            {
                tracing::warn!("Failed to persist Auto Drive settings: {err}");
            }
        } else {
            tracing::warn!("Could not locate config home to persist Auto Drive settings");
        }

        self.refresh_settings_overview_rows();
        self.refresh_auto_drive_visuals();
        self.request_redraw();
    }

    fn auto_send_conversation(&mut self) {
        if !self.auto_state.is_active() || self.auto_state.is_waiting_for_response() {
            return;
        }
        self.auto_state.on_complete_review();
        if !self.auto_state.is_paused_manual() {
            self.auto_state.clear_bypass_coordinator_flag();
        }
        let conversation = self.current_auto_history();
        let Some(handle) = self.auto_handle.as_ref() else {
            return;
        };
        if handle
            .send(AutoCoordinatorCommand::UpdateConversation(conversation))
            .is_err()
        {
            self.auto_stop(Some("Coordinator stopped unexpectedly.".to_string()));
        } else {
            self.bottom_pane.set_standard_terminal_hint(None);
            self.auto_state.on_prompt_submitted();
            self.auto_state.set_coordinator_waiting(true);
            self.auto_state.current_summary = None;
            self.auto_state.current_progress_past = None;
            self.auto_state.current_progress_current = None;
            self.auto_state.current_cli_prompt = None;
            self.auto_state.current_cli_context = None;
            self.auto_state.last_broadcast_summary = None;
            self.auto_state.current_summary_index = None;
            self.auto_state.current_display_line = None;
            self.auto_state.current_display_is_summary = false;
            self.auto_state.current_reasoning_title = None;
            self.auto_state.placeholder_phrase =
                Some(auto_drive_strings::next_auto_drive_phrase().to_string());
            self.auto_state.thinking_prefix_stripped = false;
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn auto_send_conversation_force(&mut self) {
        if !self.auto_state.is_active() {
            return;
        }
        if !self.auto_state.is_paused_manual() {
            self.auto_state.clear_bypass_coordinator_flag();
        }
        let conversation = self.current_auto_history();
        let Some(handle) = self.auto_handle.as_ref() else {
            return;
        };
        if handle
            .send(AutoCoordinatorCommand::UpdateConversation(conversation))
            .is_err()
        {
            self.auto_stop(Some("Coordinator stopped unexpectedly.".to_string()));
        } else {
            self.bottom_pane.set_standard_terminal_hint(None);
            self.auto_state.on_prompt_submitted();
            self.auto_state.set_coordinator_waiting(true);
            self.auto_state.current_summary = None;
            self.auto_state.current_progress_past = None;
            self.auto_state.current_progress_current = None;
            self.auto_state.current_cli_prompt = None;
            self.auto_state.current_cli_context = None;
            self.auto_state.last_broadcast_summary = None;
            self.auto_state.current_summary_index = None;
            self.auto_state.current_display_line = None;
            self.auto_state.current_display_is_summary = false;
            self.auto_state.current_reasoning_title = None;
            self.auto_state.placeholder_phrase =
                Some(auto_drive_strings::next_auto_drive_phrase().to_string());
            self.auto_state.thinking_prefix_stripped = false;
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn auto_send_user_prompt_to_coordinator(
        &mut self,
        prompt: String,
        conversation: Vec<ResponseItem>,
    ) -> bool {
        let Some(handle) = self.auto_handle.as_ref() else {
            return false;
        };
        let command = AutoCoordinatorCommand::HandleUserPrompt {
            _prompt: prompt,
            conversation,
        };
        match handle.send(command) {
            Ok(()) => {
                self.auto_state.on_prompt_submitted();
                self.auto_state.set_coordinator_waiting(true);
                self.auto_state.placeholder_phrase =
                    Some(auto_drive_strings::next_auto_drive_phrase().to_string());
                self.auto_rebuild_live_ring();
                self.request_redraw();
                true
            }
            Err(err) => {
                tracing::warn!("failed to dispatch user prompt to coordinator: {err}");
                false
            }
        }
    }

    fn auto_failure_is_transient(message: &str) -> bool {
        let lower = message.to_ascii_lowercase();
        const TRANSIENT_MARKERS: &[&str] = &[
            "stream error",
            "network error",
            "timed out",
            "timeout",
            "temporarily unavailable",
            "retry window exceeded",
            "retry limit exceeded",
            "connection reset",
            "connection refused",
            "broken pipe",
            "dns error",
            "host unreachable",
            "send request",
        ];
        TRANSIENT_MARKERS.iter().any(|needle| lower.contains(needle))
    }

    fn auto_schedule_restart_event(&self, token: u64, attempt: u32, delay: Duration) {
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            if !delay.is_zero() {
                tokio::time::sleep(delay).await;
            }
            tx.send(AppEvent::AutoCoordinatorRestart { token, attempt });
        });
    }

    fn auto_pause_for_transient_failure(&mut self, message: String) {
        warn!("auto drive transient failure: {}", message);

        if let Some(handle) = self.auto_handle.take() {
            handle.cancel();
        }

        self.pending_auto_turn_config = None;

        let effects = self
            .auto_state
            .pause_for_transient_failure(Instant::now(), message);
        self.auto_apply_controller_effects(effects);
    }

    pub(crate) fn auto_handle_decision(
        &mut self,
        status: AutoCoordinatorStatus,
        progress_past: Option<String>,
        progress_current: Option<String>,
        goal: Option<String>,
        cli: Option<AutoTurnCliAction>,
        agents_timing: Option<AutoTurnAgentsTiming>,
        agents: Vec<AutoTurnAgentsAction>,
        transcript: Vec<code_protocol::models::ResponseItem>,
        turn_descriptor: Option<TurnDescriptor>,
        review_commit: Option<ReviewCommitDescriptor>,
    ) {
        if !self.auto_state.is_active() {
            return;
        }

        self.auto_pending_goal_request = false;

        if let Some(goal_text) = goal.as_ref().map(|g| g.trim()).filter(|g| !g.is_empty()) {
            let derived_goal = goal_text.to_string();
            self.auto_state.goal = Some(derived_goal.clone());
            self.auto_goal_bootstrap_done = true;
            self.auto_card_set_goal(Some(derived_goal));
        }

        let progress_past = Self::normalize_progress_field(progress_past);
        let progress_current = Self::normalize_progress_field(progress_current);

        self.auto_state.turns_completed = self.auto_state.turns_completed.saturating_add(1);

        if !transcript.is_empty() {
            self.auto_history.append_raw(&transcript);
        }

        self.auto_state.current_progress_past = progress_past.clone();
        self.auto_state.current_progress_current = progress_current.clone();
        self.auto_state.last_decision_progress_past = progress_past.clone();
        self.auto_state.last_decision_progress_current = progress_current.clone();
        let cli_context = cli
            .as_ref()
            .and_then(|action| Self::normalize_progress_field(action.context.clone()));
        let cli_prompt = cli.as_ref().map(|action| action.prompt.clone());

        self.auto_state.current_cli_context = cli_context.clone();

        let summary_text = Self::compose_progress_summary(&progress_current, &progress_past);
        self.auto_state.last_decision_summary = Some(summary_text.clone());
        self.auto_state.set_coordinator_waiting(false);
        self.auto_on_reasoning_final(&summary_text);
        self.auto_state.last_decision_display = self.auto_state.current_display_line.clone();
        self.auto_state.last_decision_display_is_summary =
            self.auto_state.current_display_is_summary;
            self.auto_state.on_resume_from_manual();

        self.pending_auto_turn_config = None;

        if let Some(current) = progress_current
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
        {
            self.auto_card_add_action(
                format!("Progress: {current}"),
                AutoDriveActionKind::Info,
            );
        }

        let mut promoted_agents: Vec<String> = Vec::new();
        let continue_status = matches!(status, AutoCoordinatorStatus::Continue);

        if let Some(descriptor) = turn_descriptor.clone() {
            self.pending_turn_descriptor = Some(descriptor);
        } else if !continue_status {
            self.pending_turn_descriptor = None;
        }

        match review_commit.clone() {
            Some(commit) => self.pending_review_commit = Some(commit),
            None if !continue_status => {
                self.pending_review_commit = None;
            }
            _ => {}
        }

        let resolved_agents: Vec<AutoTurnAgentsAction> = agents
            .into_iter()
            .map(|mut action| {
                let original = action.write;
                let requested = action.write_requested;
                let resolved = self.resolve_agent_write_flag(requested);
                if resolved && !original {
                    promoted_agents.push(action.prompt.clone());
                }
                action.write = resolved;
                action
            })
            .collect();

        if continue_status {
            self.auto_state.pending_agent_actions = resolved_agents;
            self.auto_state.pending_agent_timing = agents_timing
                .filter(|_| !self.auto_state.pending_agent_actions.is_empty());
        } else {
            self.auto_state.pending_agent_actions.clear();
            self.auto_state.pending_agent_timing = None;
        }

        if !promoted_agents.is_empty() {
            let joined = promoted_agents
                .into_iter()
                .map(|prompt| {
                    let trimmed = prompt.trim();
                    if trimmed.is_empty() {
                        "<empty prompt>".to_string()
                    } else {
                        format!("\"{trimmed}\"")
                    }
                })
                .collect::<Vec<_>>()
                .join(", ");
            self.auto_card_add_action(
                format!("Auto Drive enabled write mode for agent prompt(s): {joined}"),
                AutoDriveActionKind::Info,
            );
        }

        if !matches!(status, AutoCoordinatorStatus::Failed) {
            self.auto_state.transient_restart_attempts = 0;
           self.auto_state.on_recovery_attempt();
            self.auto_state.pending_restart = None;
        }

        match status {
            AutoCoordinatorStatus::Continue => {
                let Some(prompt_text) = cli_prompt else {
                    self.auto_stop(Some("Coordinator response omitted a prompt.".to_string()));
                    return;
                };
                self.schedule_auto_cli_prompt(prompt_text);
            }
            AutoCoordinatorStatus::Success => {
                let normalized = summary_text.trim();
                let message = if normalized.is_empty() {
                    "Coordinator success.".to_string()
                } else if normalized
                    .to_ascii_lowercase()
                    .starts_with("coordinator success:")
                {
                    summary_text
                } else {
                    format!("Coordinator success: {summary_text}")
                };

                let diagnostics_goal = self
                    .auto_state
                    .goal
                    .as_deref()
                    .unwrap_or("(goal unavailable)");

                let prompt_text = format!(
                    r#"Here was the original goal:
{diagnostics_goal}

Have we met every part of this goal and is there no further work to do?"#
                );

                let tf = TextFormat {
                    r#type: "json_schema".to_string(),
                    name: Some("auto_drive_diagnostics".to_string()),
                    strict: Some(true),
                    schema: Some(code_auto_drive_diagnostics::AutoDriveDiagnostics::completion_schema()),
                };
                self.submit_op(Op::SetNextTextFormat { format: tf.clone() });
                self.next_cli_text_format = Some(tf);
                self.auto_state.pending_stop_message = Some(message);
                self.auto_card_add_action(
                    "Auto Drive Diagnostics: Validating progress".to_string(),
                    AutoDriveActionKind::Info,
                );
                self.schedule_auto_cli_prompt(prompt_text);
                self.auto_submit_prompt();
                return;
            }
            AutoCoordinatorStatus::Failed => {
                let normalized = summary_text.trim();
                let message = if normalized.is_empty() {
                    "Coordinator error.".to_string()
                } else if normalized
                    .to_ascii_lowercase()
                    .starts_with("coordinator error:")
                {
                    summary_text
                } else {
                    format!("Coordinator error: {summary_text}")
                };
                if Self::auto_failure_is_transient(&message) {
                    self.auto_pause_for_transient_failure(message);
                } else {
                    self.auto_stop(Some(message));
                }
                return;
            }
        }
    }

    pub(crate) fn auto_handle_user_reply(
        &mut self,
        user_response: Option<String>,
        cli_command: Option<String>,
    ) {
        if let Some(text) = user_response.clone() {
            if let Some(item) = Self::auto_drive_make_assistant_message(text.clone()) {
                self.auto_history
                    .append_raw(std::slice::from_ref(&item));
            }
            let mut lines = Vec::with_capacity(2);
            lines.push("AUTO DRIVE RESPONSE".to_string());
            lines.push(text);
            self.history_push_plain_paragraphs(PlainMessageKind::Notice, lines);
        }

        if let Some(command) = cli_command {
            if command.trim_start().starts_with('/') {
                self.app_event_tx
                    .send(AppEvent::DispatchCommand(SlashCommand::Auto, command));
            } else {
                let mut message: UserMessage = command.into();
                message.suppress_persistence = true;
                self.submit_user_message(message);
            }
        } else {
            self.auto_state.set_phase(AutoRunPhase::Active);
            self.auto_state.placeholder_phrase = None;
        }

        self.auto_rebuild_live_ring();
        self.request_redraw();
    }

    fn should_schedule_auto_commit_review(&self) -> bool {
        if self.auto_review_pending {
            return false;
        }
        if !self.auto_state.is_active() {
            return false;
        }
        if !self.auto_state.qa_automation_enabled {
            return false;
        }
        if !self.auto_state.review_enabled {
            return false;
        }
        if self
            .pending_review_commit
            .as_ref()
            .and_then(|desc| desc.sha.as_ref())
            .is_none()
        {
            return false;
        }
        matches!(
            self.pending_review_commit
                .as_ref()
                .map(|desc| desc.source.as_str()),
            Some("commit")
        )
    }

    fn spawn_auto_commit_review(&mut self) {
        let repo_root = self.config.cwd.clone();
        let base_snapshot = self
            .auto_turn_review_state
            .as_ref()
            .and_then(|state| state.base_commit.as_ref())
            .map(|commit| BaseCommitSnapshot {
                id: commit.id().to_string(),
                parent: commit.parent().map(|p| p.to_string()),
            });
        let name_hint = self
            .pending_review_commit
            .as_ref()
            .and_then(|desc| desc.sha.clone())
            .or_else(|| self.auto_state.goal.clone());
        let app_event_tx = self.app_event_tx.clone();
        self.auto_review_pending = true;

        spawn(async move {
            let outcome = auto_review::prepare_commit_review(
                &repo_root,
                base_snapshot,
                name_hint.as_deref(),
            )
            .await;
            app_event_tx.send(AppEvent::AutoReviewCommitReady { outcome });
        });
    }

    pub(crate) fn handle_auto_review_commit_ready(&mut self, outcome: AutoReviewOutcome) {
        self.auto_review_pending = false;
        match outcome {
            AutoReviewOutcome::Skip { reason } => {
                self.pending_review_commit = None;
                self.push_background_tail(format!("Auto Drive review skipped: {reason}"));
                self.cleanup_active_review_worktree();
            }
            AutoReviewOutcome::Error(err) => {
                self.pending_review_commit = None;
                self.push_background_tail(format!("Auto Drive review prep failed: {err}"));
                tracing::warn!("auto_review_prep_failed" = %err);
                self.cleanup_active_review_worktree();
            }
            AutoReviewOutcome::Commit(prepared) => {
                self.launch_commit_review(prepared);
            }
        }
        self.request_redraw();
    }

    fn launch_commit_review(&mut self, prepared: PreparedCommitReview) {
        let file_label = if prepared.file_count == 1 {
            "1 file".to_string()
        } else {
            format!("{} files", prepared.file_count)
        };
        let mut prompt = format!(
            "Review commit {} generated during the latest Auto Drive turn. Highlight bugs, regressions, risky patterns, and missing tests before merge.",
            prepared.commit_sha
        );
        let mut hint = format!(
            "auto turn changes — {} ({})",
            prepared.short_sha,
            file_label
        );
        if let Some(subject) = prepared.subject.as_ref().filter(|s| !s.is_empty()) {
            hint = format!("{hint} — {subject}");
        }

        if let Some(descriptor) = self.pending_turn_descriptor.as_ref() {
            if let Some(strategy) = descriptor.review_strategy.as_ref() {
                if let Some(custom_prompt) = strategy
                    .custom_prompt
                    .as_ref()
                    .and_then(|text| {
                        let trimmed = text.trim();
                        (!trimmed.is_empty()).then_some(trimmed)
                    })
                {
                    prompt = custom_prompt.to_string();
                }

                if let Some(scope_hint) = strategy
                    .scope_hint
                    .as_ref()
                    .and_then(|text| {
                        let trimmed = text.trim();
                        (!trimmed.is_empty()).then_some(trimmed)
                    })
                {
                    hint = scope_hint.to_string();
                }
            }
        }

        let metadata = ReviewContextMetadata {
            scope: Some("commit".to_string()),
            commit: Some(prepared.commit_sha.clone()),
            base_branch: prepared.base_branch.clone(),
            current_branch: prepared.current_branch.clone(),
            worktree_path: Some(prepared.worktree_path.display().to_string()),
        };

        let preparation = format!("Preparing code review for commit {}", prepared.short_sha);
        self.auto_state.on_begin_review(false);
        self.auto_review_cleanup = Some(prepared.cleanup);
        self.begin_review(prompt, hint, Some(preparation), Some(metadata));
        self.pending_review_commit = None;
        self.auto_turn_review_state = None;
        self.auto_card_add_action(
            format!("Auto Drive prepared commit review for {}", prepared.short_sha),
            AutoDriveActionKind::Info,
        );
    }

    fn cleanup_active_review_worktree(&mut self) {
        if let Some(token) = self.auto_review_cleanup.take() {
            spawn(async move {
                if let Err(err) = cleanup_review_worktree(token).await {
                    tracing::warn!("failed to cleanup review worktree: {err}");
                }
            });
        }
    }

    fn schedule_auto_cli_prompt(&mut self, prompt_text: String) {
        self.schedule_auto_cli_prompt_with_override(prompt_text, None);
    }

    fn schedule_auto_cli_prompt_with_override(
        &mut self,
        prompt_text: String,
        countdown_override: Option<u8>,
    ) {
        let effects = self
            .auto_state
            .schedule_cli_prompt(prompt_text, countdown_override);
        self.auto_apply_controller_effects(effects);
    }

    fn auto_can_bootstrap_from_history(&self) -> bool {
        self.history_cells.iter().any(|cell| match cell.kind() {
            HistoryCellType::User | HistoryCellType::Assistant | HistoryCellType::Plain => true,
            HistoryCellType::Exec { .. } => true,
            _ => false,
        })
    }

    fn auto_apply_controller_effects(&mut self, effects: Vec<AutoControllerEffect>) {
        for effect in effects {
        match effect {
            AutoControllerEffect::RefreshUi => {
                    self.auto_rebuild_live_ring();
                    self.request_redraw();
                }
                AutoControllerEffect::StartCountdown {
                    countdown_id,
                    seconds,
                } => {
                    if seconds == 0 {
                        let _ = self.app_event_tx.send(AppEvent::AutoCoordinatorCountdown {
                            countdown_id,
                            seconds_left: 0,
                        });
                    } else {
                        self.auto_spawn_countdown(countdown_id, seconds);
                    }
                }
                AutoControllerEffect::SubmitPrompt => {
                    if self.auto_state.should_bypass_coordinator_next_submit()
                        && self.auto_state.is_paused_manual()
                    {
                        self.auto_state.clear_bypass_coordinator_flag();
                        self.auto_state.set_phase(AutoRunPhase::Active);
                    }
                    if !self.auto_state.should_bypass_coordinator_next_submit() {
                        self.auto_submit_prompt();
                    }
                }
                AutoControllerEffect::LaunchStarted { goal } => {
                    self.bottom_pane.set_task_running(false);
                    self.bottom_pane.update_status_text("Auto Drive".to_string());
                    self.auto_card_start(Some(goal.clone()));
                    self.auto_card_add_action(
                        format!("Auto Drive started: {goal}"),
                        AutoDriveActionKind::Info,
                    );
                    self.auto_card_set_status(AutoDriveStatus::Running);
                }
                AutoControllerEffect::LaunchFailed { goal, error } => {
                    let message = format!(
                        "Coordinator failed to start for goal '{goal}': {error}"
                    );
                    self.auto_card_finalize(
                        Some(message),
                        AutoDriveStatus::Failed,
                        AutoDriveActionKind::Error,
                    );
                }
                AutoControllerEffect::StopCompleted { summary, message } => {
                    if let Some(handle) = self.auto_handle.take() {
                        handle.cancel();
                        let _ = handle.send(AutoCoordinatorCommand::Stop);
                    }
                    let final_message = message.or_else(|| summary.message.clone());
                    if let Some(msg) = final_message.clone() {
                        if !msg.trim().is_empty() {
                            self.auto_card_finalize(
                                Some(msg),
                                AutoDriveStatus::Stopped,
                                AutoDriveActionKind::Info,
                            );
                        } else {
                            self.auto_card_finalize(None, AutoDriveStatus::Stopped, AutoDriveActionKind::Info);
                        }
                    } else {
                        self.auto_card_finalize(None, AutoDriveStatus::Stopped, AutoDriveActionKind::Info);
                    }
                    self.auto_turn_review_state = None;
                    if ENABLE_WARP_STRIPES {
                        self.header_wave.set_enabled(false, Instant::now());
                    }
                }
                AutoControllerEffect::TransientPause {
                    attempt,
                    delay,
                    reason,
                } => {
                    let human_delay = format_duration(delay);
                    self.bottom_pane.set_task_running(false);
                    self.bottom_pane
                        .update_status_text("Auto Drive paused".to_string());
                    self.bottom_pane.set_standard_terminal_hint(Some(
                        "Press Esc again to exit Auto Drive".to_string(),
                    ));
                    let message = format!(
                        "Auto Drive will retry automatically in {human_delay} (attempt {attempt}/{AUTO_RESTART_MAX_ATTEMPTS}). Last error: {reason}"
                    );
                    self.auto_card_add_action(message, AutoDriveActionKind::Warning);
                    self.auto_card_set_status(AutoDriveStatus::Paused);
                }
                AutoControllerEffect::ScheduleRestart {
                    token,
                    attempt,
                    delay,
                } => {
                    self.auto_schedule_restart_event(token, attempt, delay);
                }
                AutoControllerEffect::CancelCoordinator => {
                    if let Some(handle) = self.auto_handle.take() {
                        handle.cancel();
                        let _ = handle.send(AutoCoordinatorCommand::Stop);
                    }
                }
                AutoControllerEffect::ResetHistory => {
                    self.auto_history.clear();
                }
                AutoControllerEffect::UpdateTerminalHint { hint } => {
                    self.bottom_pane.set_standard_terminal_hint(hint);
                }
                AutoControllerEffect::SetTaskRunning { running } => {
                    let has_activity = running
                        || !self.exec.running_commands.is_empty()
                        || !self.tools_state.running_custom_tools.is_empty()
                        || !self.tools_state.web_search_sessions.is_empty()
                        || !self.tools_state.running_wait_tools.is_empty()
                        || !self.tools_state.running_kill_tools.is_empty()
                        || self.stream.is_write_cycle_active()
                        || !self.active_task_ids.is_empty();

                    self.bottom_pane.set_task_running(has_activity);
                    if !has_activity {
                        self.bottom_pane.update_status_text(String::new());
                    }
                }
                AutoControllerEffect::EnsureInputFocus => {
                    self.bottom_pane.ensure_input_focus();
                }
                AutoControllerEffect::ClearCoordinatorView => {
                    self.bottom_pane.clear_auto_coordinator_view(true);
                }
                AutoControllerEffect::ShowGoalEntry => {
                    self.auto_show_goal_entry_panel();
                }
            }
        }
    }

    fn auto_spawn_countdown(&self, countdown_id: u64, seconds: u8) {
        let tx = self.app_event_tx.clone();
        let fallback_tx = tx.clone();
        if thread_spawner::spawn_lightweight("countdown", move || {
            let mut remaining = seconds;
            while remaining > 0 {
                std::thread::sleep(std::time::Duration::from_secs(1));
                remaining -= 1;
                if !tx.send_with_result(AppEvent::AutoCoordinatorCountdown {
                    countdown_id,
                    seconds_left: remaining,
                }) {
                    break;
                }
            }
        })
        .is_none()
        {
            let _ = fallback_tx.send(AppEvent::AutoCoordinatorCountdown {
                countdown_id,
                seconds_left: 0,
            });
        }
    }

    pub(crate) fn auto_handle_countdown(&mut self, countdown_id: u64, seconds_left: u8) {
        let effects = self
            .auto_state
            .handle_countdown_tick(countdown_id, seconds_left);
        if effects.is_empty() {
            return;
        }
        self.auto_apply_controller_effects(effects);
    }

    pub(crate) fn auto_handle_restart(&mut self, token: u64, attempt: u32) {
        if !self.auto_state.is_active() || !self.auto_state.in_transient_recovery() {
            return;
        }
        let Some(restart) = self.auto_state.pending_restart.clone() else {
            return;
        };
        if restart.token != token || restart.attempt != attempt {
            return;
        }

        let Some(goal) = self.auto_state.goal.clone() else {
            self.auto_card_add_action(
                "Auto Drive restart skipped because the goal is no longer available.".to_string(),
                AutoDriveActionKind::Warning,
            );
            self.auto_state.pending_restart = None;
            self.auto_state.on_recovery_attempt();
            self.auto_stop(Some("Auto Drive restart aborted.".to_string()));
            return;
        };

        let cross_check_enabled = self.auto_state.cross_check_enabled;
        let continue_mode = self.auto_state.continue_mode;
        let previous_turns = self.auto_state.turns_completed;
        let previous_started_at = self.auto_state.started_at;
        let restart_attempts = self.auto_state.transient_restart_attempts;
        let review_enabled = self.auto_state.review_enabled;
        let agents_enabled = self.auto_state.subagents_enabled;
        let qa_automation_enabled = self.auto_state.qa_automation_enabled;

        self.auto_state.pending_restart = None;
        self.auto_state.on_recovery_attempt();
        self.auto_state.restart_token = token;

        let resume_message = if restart.reason.is_empty() {
            format!(
                "Auto Drive resuming automatically (attempt {attempt}/{AUTO_RESTART_MAX_ATTEMPTS})."
            )
        } else {
            format!(
                "Auto Drive resuming automatically (attempt {attempt}/{AUTO_RESTART_MAX_ATTEMPTS}); previous error: {}",
                restart.reason
            )
        };
        self.auto_card_add_action(resume_message, AutoDriveActionKind::Info);
        self.auto_card_set_status(AutoDriveStatus::Running);

        self.auto_launch_with_goal(
            goal,
            false,
            review_enabled,
            agents_enabled,
            cross_check_enabled,
            qa_automation_enabled,
            continue_mode,
        );

        if previous_turns > 0 {
            self.auto_state.turns_completed = previous_turns;
        }
        if let Some(started_at) = previous_started_at {
            self.auto_state.started_at = Some(started_at);
        }
        self.auto_state.transient_restart_attempts = restart_attempts;
        self.auto_state.current_progress_current = None;
        self.auto_state.current_progress_past = None;
        self.auto_rebuild_live_ring();
        self.auto_update_terminal_hint();
        self.request_redraw();
        self.rebuild_auto_history();
    }

    pub(crate) fn auto_handle_thinking(&mut self, delta: String, summary_index: Option<u32>) {
        if !self.auto_state.is_active() {
            return;
        }
        self.auto_on_reasoning_delta(&delta, summary_index);
    }

    fn prepare_auto_turn_review_state(&mut self) {
        if !self.auto_state.is_active() || !self.auto_state.review_enabled {
            self.auto_turn_review_state = None;
            return;
        }

        let read_only = self
            .pending_auto_turn_config
            .as_ref()
            .map(|cfg| cfg.read_only)
            .unwrap_or(false);

        if read_only {
            self.auto_turn_review_state = None;
            return;
        }

        match self.capture_auto_turn_commit("auto turn base snapshot", None) {
            Ok(commit) => {
                self.auto_turn_review_state = Some(AutoTurnReviewState {
                    base_commit: Some(commit),
                });
            }
            Err(err) => {
                tracing::warn!("failed to capture auto turn base snapshot: {err}");
                self.auto_turn_review_state = None;
            }
        }
    }

    fn capture_auto_turn_commit(
        &self,
        message: &'static str,
        parent: Option<&GhostCommit>,
    ) -> Result<GhostCommit, GitToolingError> {
        #[cfg(test)]
        if let Some(stub) = CAPTURE_AUTO_TURN_COMMIT_STUB.lock().unwrap().as_ref() {
            let parent_id = parent.map(|commit| commit.id().to_string());
            return stub(message, parent_id);
        }
        let mut options = CreateGhostCommitOptions::new(self.config.cwd.as_path()).message(message);
        if let Some(parent_commit) = parent {
            options = options.parent(parent_commit.id());
        }
        create_ghost_commit(&options)
    }

    fn auto_submit_prompt(&mut self) {
        if !self.auto_state.is_active() {
            return;
        }

        if self.auto_pending_goal_request {
            self.auto_pending_goal_request = false;
            self.auto_send_conversation_force();
            return;
        }

        let Some(original_prompt) = self.auto_state.current_cli_prompt.clone() else {
            self.auto_stop(Some("Coordinator prompt missing when attempting to submit.".to_string()));
            return;
        };

        if original_prompt.trim().is_empty() {
            self.auto_stop(Some("Coordinator produced an empty prompt.".to_string()));
            return;
        }

        let Some(full_prompt) = self.build_auto_turn_message(&original_prompt) else {
            self.auto_stop(Some("Coordinator produced an empty prompt.".to_string()));
            return;
        };

        self.auto_dispatch_cli_prompt(full_prompt);
    }

    fn auto_start_bootstrap_from_history(&mut self) -> bool {
        if !self.auto_can_bootstrap_from_history() {
            return false;
        }

        let defaults = self.config.auto_drive.clone();
        let default_mode = auto_continue_from_config(defaults.continue_mode);

        if self.auto_state.is_active() {
            self.auto_stop(None);
        }

        self.auto_state.mark_intro_pending();
        self.auto_launch_with_goal(
            AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string(),
            true,
            defaults.review_enabled,
            defaults.agents_enabled,
            defaults.cross_check_enabled,
            defaults.qa_automation_enabled,
            default_mode,
        );

        if self.auto_handle.is_none() {
            return false;
        }

        self.auto_state.current_cli_context = None;
        self.auto_state.current_cli_prompt = Some(String::new());
        self.auto_pending_goal_request = true;
        self.auto_goal_bootstrap_done = false;

        let override_seconds = if matches!(
            self.auto_state.continue_mode,
            AutoContinueMode::Immediate
        ) {
            Some(10)
        } else {
            None
        };
        self.schedule_auto_cli_prompt_with_override(String::new(), override_seconds);
        true
    }

    fn auto_dispatch_cli_prompt(&mut self, full_prompt: String) {
        self.auto_pending_goal_request = false;

        self.bottom_pane.set_standard_terminal_hint(None);
        self.auto_state.on_prompt_submitted();
        self.auto_state.set_coordinator_waiting(false);
        self.auto_state.clear_bypass_coordinator_flag();
        self.auto_state.seconds_remaining = 0;
        let post_submit_display = self.auto_state.last_decision_display.clone();
        self.auto_state.current_summary = None;
        self.auto_state.current_progress_past = None;
        self.auto_state.current_progress_current = None;
        self.auto_state.last_broadcast_summary = None;
        self.auto_state.current_display_line = post_submit_display.clone();
        self.auto_state.current_display_is_summary =
            self.auto_state.last_decision_display_is_summary && post_submit_display.is_some();
        self.auto_state.current_summary_index = None;
        self.auto_state.placeholder_phrase = post_submit_display.is_none().then(|| {
            auto_drive_strings::next_auto_drive_phrase().to_string()
        });
        self.auto_state.current_reasoning_title = None;
        self.auto_state.thinking_prefix_stripped = false;

        let should_prepare_agents = self.auto_state.subagents_enabled
            && !self.auto_state.pending_agent_actions.is_empty();
        if should_prepare_agents {
            self.prepare_agents();
        }

        if self.auto_state.review_enabled {
            self.prepare_auto_turn_review_state();
        } else {
            self.auto_turn_review_state = None;
        }
        self.bottom_pane.update_status_text(String::new());
        self.bottom_pane.set_task_running(false);
        let mut message: UserMessage = full_prompt.into();
        message.suppress_persistence = true;
        if self.auto_state.pending_stop_message.is_some() {
            message.display_text.clear();
        }
        self.submit_user_message(message);
        self.auto_state.pending_agent_actions.clear();
        self.auto_state.pending_agent_timing = None;
        self.auto_rebuild_live_ring();
        self.request_redraw();
    }

    fn auto_pause_for_manual_edit(&mut self, force: bool) {
        if !self.auto_state.is_active() {
            return;
        }

        if !force && !self.auto_state.awaiting_coordinator_submit() {
            return;
        }

        let prompt_text = self
            .auto_state
            .current_cli_prompt
            .clone()
            .unwrap_or_default();
        let full_prompt = self
            .build_auto_turn_message(&prompt_text)
            .unwrap_or_else(|| prompt_text.clone());

        self.auto_state.on_pause_for_manual(true);
        self.auto_state.set_bypass_coordinator_next_submit();
        self.auto_state.countdown_id = self.auto_state.countdown_id.wrapping_add(1);
        self.auto_state.reset_countdown();
        self.clear_composer();
        if !full_prompt.is_empty() {
            self.insert_str(&full_prompt);
        } else if force && !prompt_text.is_empty() {
            self.insert_str(&prompt_text);
        }
        self.bottom_pane.ensure_input_focus();
        self.bottom_pane.set_task_running(true);
        self.bottom_pane
            .update_status_text("Auto Drive paused".to_string());
        self.show_auto_drive_exit_hint();
        self.auto_rebuild_live_ring();
        self.request_redraw();
    }

    // Build a hidden preface for the next Auto turn based on coordinator hints.
    fn build_auto_turn_message(&self, prompt_cli: &str) -> Option<String> {
        let mut sections: Vec<String> = Vec::new();

        if let Some(ctx) = self
            .auto_state
            .current_cli_context
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
        {
            sections.push(ctx.to_string());
        }

        if !prompt_cli.trim().is_empty() {
            sections.push(prompt_cli.trim().to_string());
        }

        let agent_actions = &self.auto_state.pending_agent_actions;
        if !agent_actions.is_empty() {
            let agent_timing = self.auto_state.pending_agent_timing;
            let mut agent_lines = Vec::with_capacity(agent_actions.len() * 4 + 5);
            const BLOCK_PREFIX: &str = "   ";
            const LINE_PREFIX: &str = "      ";

            agent_lines.push(format!("{BLOCK_PREFIX}<agents>"));
            agent_lines.push(format!(
                "{LINE_PREFIX}Please use agents to help you complete this task."
            ));

            for action in agent_actions {
                let prompt = action
                    .prompt
                    .trim()
                    .replace('\n', " ")
                    .replace('"', "\\\"");
                let write_text = if action.write { "write: true" } else { "write: false" };

                agent_lines.push(String::new());
                agent_lines.push(format!(
                    "{LINE_PREFIX}Please run agent.create with {write_text} and prompt like \"{prompt}\"."
                ));

                if let Some(ctx) = action
                    .context
                    .as_deref()
                    .map(str::trim)
                    .filter(|s| !s.is_empty())
                {
                    agent_lines.push(format!(
                        "{LINE_PREFIX}Context: {}",
                        ctx.replace('\n', " ")
                    ));
                }

                if let Some(models) = action
                    .models
                    .as_ref()
                    .filter(|list| !list.is_empty())
                {
                    agent_lines.push(format!(
                        "{LINE_PREFIX}Models: [{}]",
                        models.join(", ")
                    ));
                }
            }

            agent_lines.push(String::new());
            let timing_line = match agent_timing {
                Some(AutoTurnAgentsTiming::Parallel) =>
                    "Timing (parallel): Launch these agents in the background while you continue the CLI prompt. Call agent.wait with the batch_id when you are ready to merge their results.".to_string(),
                Some(AutoTurnAgentsTiming::Blocking) =>
                    "Timing (blocking): Launch these agents first, then wait with agent.wait (use the batch_id from agent.create) and only continue the CLI prompt once their results are ready.".to_string(),
                None =>
                    "Timing (default blocking): After launching the agents, wait with agent.wait (use the batch_id returned by agent.create) and fold their output into your plan.".to_string(),
            };
            agent_lines.push(format!("{LINE_PREFIX}{timing_line}"));
            agent_lines.push(String::new());

            if agent_actions.iter().any(|action| !action.write) {
                agent_lines.push(format!(
                    "{LINE_PREFIX}Call agent.result to get the results from the agent if needed."
                ));
                agent_lines.push(String::new());
            }

            if agent_actions.iter().any(|action| action.write) {
                agent_lines.push(format!(
                    "{LINE_PREFIX}When agents run with write: true, they perform edits in their own worktree. Considering reviewing and merging the best worktree once they complete."
                ));
                agent_lines.push(String::new());
            }

            agent_lines.push(format!("{BLOCK_PREFIX}</agents>"));

            sections.push(agent_lines.join("\n"));
        }

        let combined = sections.join("\n\n");
        if combined.trim().is_empty() {
            None
        } else {
            Some(combined)
        }
    }

    fn auto_agents_can_write(&self) -> bool {
        matches!(
            self.config.sandbox_policy,
            SandboxPolicy::DangerFullAccess | SandboxPolicy::WorkspaceWrite { .. }
        )
    }

    fn resolve_agent_write_flag(&self, requested_write: Option<bool>) -> bool {
        if !self.auto_agents_can_write() {
            return false;
        }
        if !self.auto_state.subagents_enabled {
            return requested_write.unwrap_or(false);
        }
        true
    }

    fn auto_stop(&mut self, message: Option<String>) {
        self.next_cli_text_format = None;
        self.auto_pending_goal_request = false;
        self.auto_goal_bootstrap_done = false;
        self.cleanup_active_review_worktree();
        self.auto_review_pending = false;
        self.pending_review_commit = None;
        let effects = self
            .auto_state
            .stop_run(Instant::now(), message);
        self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        self.auto_apply_controller_effects(effects);
    }

    fn auto_on_assistant_final(&mut self) {
        if !self.auto_state.is_active() || !self.auto_state.is_waiting_for_response() {
            return;
        }
        self.auto_state.on_resume_from_manual();
        self.auto_state.reset_countdown();
        self.auto_state.current_summary = Some(String::new());
        self.auto_state.current_progress_past = None;
        self.auto_state.current_progress_current = None;
        self.auto_state.current_summary_index = None;
        self.auto_state.placeholder_phrase = None;
        self.auto_state.thinking_prefix_stripped = false;

        let auto_resolve_blocking = self.auto_resolve_should_block_auto_resume();
        let review_pending = self.is_review_flow_active()
            || (self.auto_state.review_enabled
                && self
                    .pending_auto_turn_config
                    .as_ref()
                    .is_some_and(|cfg| !cfg.read_only));

        if review_pending || auto_resolve_blocking {
            self.auto_state.on_begin_review(false);
        } else {
            self.auto_state.on_complete_review();
        }
        self.auto_rebuild_live_ring();
        self.request_redraw();
        self.rebuild_auto_history();

        if self.auto_state.awaiting_review() {
            return;
        }

        if !self.auto_state.should_bypass_coordinator_next_submit() {
            self.auto_send_conversation();
        }
    }

    fn auto_rebuild_live_ring(&mut self) {
        if !self.auto_state.is_active() {
            if self.auto_state.should_show_goal_entry() {
                self.auto_show_goal_entry_panel();
                return;
            }
            if let Some(summary) = self.auto_state.last_run_summary.clone() {
                self.bottom_pane.clear_live_ring();
                self.auto_reset_intro_timing();
                self.auto_ensure_intro_timing();
                let mut status_lines: Vec<String> = Vec::new();
                if let Some(msg) = summary.message.as_ref() {
                    let trimmed = msg.trim();
                    if !trimmed.is_empty() {
                        status_lines.push(trimmed.to_string());
                    }
                }
                if status_lines.is_empty() {
                    if let Some(goal) = summary.goal.as_ref() {
                        status_lines.push(format!("Auto Drive completed: {goal}"));
                    } else {
                        status_lines.push("Auto Drive completed.".to_string());
                    }
                }
                let model = AutoCoordinatorViewModel::Active(AutoActiveViewModel {
                    goal: summary.goal.clone(),
                    status_lines,
                    cli_prompt: None,
                    cli_context: None,
                    show_composer: true,
            awaiting_submission: false,
            waiting_for_response: false,
            coordinator_waiting: false,
            waiting_for_review: false,
                    countdown: None,
                    button: None,
                    manual_hint: None,
                    ctrl_switch_hint: "Esc to exit Auto Drive".to_string(),
                    cli_running: false,
                    turns_completed: summary.turns_completed,
                    started_at: None,
                    elapsed: Some(summary.duration),
                    progress_past: None,
                    progress_current: None,
                    editing_prompt: false,
                    intro_started_at: self.auto_state.intro_started_at,
                    intro_reduced_motion: self.auto_state.intro_reduced_motion,
                });
            self
                .bottom_pane
                .show_auto_coordinator_view(model);
            self.bottom_pane.release_auto_drive_style();
            self.bottom_pane.set_standard_terminal_hint(None);
            return;
        }

        self.bottom_pane.clear_auto_coordinator_view(true);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_standard_terminal_hint(None);
        self.auto_reset_intro_timing();
        return;
    }

    if self.auto_state.is_paused_manual() {
        self.bottom_pane.clear_auto_coordinator_view(false);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_standard_terminal_hint(None);
        return;
    }

        self.bottom_pane.clear_live_ring();

        let status_text = if self.auto_state.awaiting_review() {
            "waiting for code review...".to_string()
        } else if let Some(line) = self
            .auto_state
            .current_display_line
            .as_ref()
            .filter(|line| !line.trim().is_empty())
        {
            line.clone()
        } else {
            self
                .auto_state
                .placeholder_phrase
                .get_or_insert_with(|| auto_drive_strings::next_auto_drive_phrase().to_string())
                .clone()
        };

        let headline = self.auto_format_status_headline(&status_text);
        let mut status_lines = vec![headline];
        if !self.auto_state.awaiting_review() {
            self.auto_append_progress_lines(
                &mut status_lines,
                self.auto_state.current_progress_current.as_ref(),
                self.auto_state.current_progress_past.as_ref(),
            );
            if self.auto_state.is_waiting_for_response() && !self.auto_state.is_coordinator_waiting() {
                let appended = self.auto_append_progress_lines(
                    &mut status_lines,
                    self.auto_state.last_decision_progress_current.as_ref(),
                    self.auto_state.last_decision_progress_past.as_ref(),
                );
                if !appended {
                    if let Some(summary) = self.auto_state.last_decision_summary.as_ref() {
                        let trimmed = summary.trim();
                        if !trimmed.is_empty() {
                            let collapsed = trimmed
                                .split_whitespace()
                                .collect::<Vec<_>>()
                                .join(" ");
                            if !collapsed.is_empty() {
                                let current_line = status_lines
                                    .first()
                                    .map(|line| line.trim_end_matches('…').trim())
                                    .unwrap_or("");
                                if collapsed != current_line {
                                    let display = Self::truncate_with_ellipsis(&collapsed, 160);
                                    status_lines.push(display);
                                }
                            }
                        }
                    }
                }
            }
        }
        let cli_running = self.is_cli_running();
        let progress_hint_active = self.auto_state.awaiting_coordinator_submit()
            || (self.auto_state.is_waiting_for_response() && !self.auto_state.is_coordinator_waiting())
            || cli_running;

        // Keep the most recent coordinator progress visible across approval and
        // CLI execution. The coordinator clears `current_progress_*` once it
        // starts streaming the next turn, so fall back to the last decision while
        // we are still acting on it.
        let progress_current_for_view = if progress_hint_active {
            self.auto_state
                .current_progress_current
                .clone()
                .or_else(|| self.auto_state.last_decision_progress_current.clone())
        } else {
            None
        };
        let progress_past_for_view = if progress_hint_active {
            self.auto_state
                .current_progress_past
                .clone()
                .or_else(|| self.auto_state.last_decision_progress_past.clone())
        } else {
            None
        };

        let cli_prompt = self
            .auto_state
            .current_cli_prompt
            .clone()
            .filter(|p| !p.trim().is_empty());
        let cli_context = self
            .auto_state
            .current_cli_context
            .clone()
            .filter(|value| !value.trim().is_empty());

        let bootstrap_pending = self.auto_pending_goal_request;
        let continue_mode = self.auto_state.continue_mode;
        let continue_cta_active = self.auto_state.awaiting_coordinator_submit()
            && !self.auto_state.is_paused_manual()
            && continue_mode != AutoContinueMode::Manual;

        let countdown_limit = self.auto_state.countdown_seconds();
        let countdown_active = self.auto_state.countdown_active();
        let countdown = if self.auto_state.awaiting_coordinator_submit() {
            match countdown_limit {
                Some(limit) if limit > 0 => Some(CountdownState {
                    remaining: self.auto_state.seconds_remaining.min(limit),
                }),
                _ => None,
            }
        } else {
            None
        };

        let button = if self.auto_state.awaiting_coordinator_submit() {
            let has_cli_prompt = cli_prompt.is_some();
            let base_label = if bootstrap_pending {
                "Complete Current Task"
            } else if has_cli_prompt {
                "Send prompt"
            } else if continue_cta_active {
                "Continue current task"
            } else {
                "Send prompt"
            };
            let label = if countdown_active {
                format!("{base_label} ({}s)", self.auto_state.seconds_remaining)
            } else {
                base_label.to_string()
            };
            Some(AutoCoordinatorButton {
                label,
                enabled: true,
            })
        } else {
            None
        };

        let manual_hint = if self.auto_state.awaiting_coordinator_submit() {
            if self.auto_state.is_paused_manual() {
                Some("Edit the prompt, then press Enter to continue.".to_string())
            } else if bootstrap_pending {
                None
            } else if continue_cta_active {
                if countdown_active {
                    Some("Enter to continue now • Esc to stop".to_string())
                } else {
                    Some("Enter to continue • Esc to stop".to_string())
                }
            } else if countdown_active {
                Some("Enter to send now • Esc to edit".to_string())
            } else {
                Some("Enter to send • Esc to edit".to_string())
            }
        } else {
            None
        };

        let ctrl_switch_hint = if self.auto_state.awaiting_coordinator_submit() {
            let has_cli_prompt = cli_prompt.is_some();
            if self.auto_state.is_paused_manual() {
                "Esc to cancel".to_string()
            } else if bootstrap_pending {
                "Esc enter new goal".to_string()
            } else if has_cli_prompt {
                "Esc to edit".to_string()
            } else if continue_cta_active {
                "Esc to stop".to_string()
            } else {
                "Esc to edit".to_string()
            }
        } else if self.auto_state.is_waiting_for_response() {
            String::new()
        } else {
            String::new()
        };

        let show_composer =
            !self.auto_state.awaiting_coordinator_submit() || self.auto_state.is_paused_manual();

        let model = AutoCoordinatorViewModel::Active(AutoActiveViewModel {
            goal: self.auto_state.goal.clone(),
            status_lines,
            cli_prompt,
            awaiting_submission: self.auto_state.awaiting_coordinator_submit(),
            waiting_for_response: self.auto_state.is_waiting_for_response(),
            coordinator_waiting: self.auto_state.is_coordinator_waiting(),
            waiting_for_review: self.auto_state.awaiting_review(),
            countdown,
            button,
            manual_hint,
            ctrl_switch_hint,
            cli_running,
            turns_completed: self.auto_state.turns_completed,
            started_at: self.auto_state.started_at,
            elapsed: self.auto_state.elapsed_override,
            progress_past: progress_past_for_view,
            progress_current: progress_current_for_view,
            cli_context,
            show_composer,
            editing_prompt: self.auto_state.is_paused_manual(),
            intro_started_at: self.auto_state.intro_started_at,
            intro_reduced_motion: self.auto_state.intro_reduced_motion,
        });

        self
            .bottom_pane
            .show_auto_coordinator_view(model);

        self.auto_update_terminal_hint();

        if self.auto_state.started_at.is_some() {
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(Duration::from_secs(1)));
        }
    }

    fn auto_format_status_headline(&self, text: &str) -> String {
        let trimmed = text.trim_end();
        if trimmed.is_empty() {
            return String::new();
        }

        if self.auto_state.current_display_is_summary {
            return trimmed.to_string();
        }

        let show_summary_without_ellipsis = self.auto_state.awaiting_coordinator_submit()
            && self.auto_state.current_reasoning_title.is_none()
            && self
                .auto_state
                .current_summary
                .as_ref()
                .map(|summary| !summary.trim().is_empty())
                .unwrap_or(false);

        if show_summary_without_ellipsis {
            trimmed.to_string()
        } else {
            append_thought_ellipsis(trimmed)
        }
    }

    fn auto_update_terminal_hint(&mut self) {
        if !self.auto_state.is_active() && !self.auto_state.should_show_goal_entry() {
            self.bottom_pane.set_standard_terminal_hint(None);
            return;
        }

        let agents_label = if self.auto_state.subagents_enabled {
            "Agents Enabled"
        } else {
            "Agents Disabled"
        };
        let diagnostics_enabled = self.auto_state.qa_automation_enabled
            && (self.auto_state.review_enabled || self.auto_state.cross_check_enabled);
        let diagnostics_label = if diagnostics_enabled {
            "Diagnostics Enabled"
        } else {
            "Diagnostics Disabled"
        };

        let left = format!("{}  •  {}", agents_label, diagnostics_label);

        let hint = left.to_string();
        self.bottom_pane
            .set_standard_terminal_hint(Some(hint));
    }

    fn auto_update_display_title(&mut self) {
        if !self.auto_state.is_active() {
            return;
        }

        let Some(summary) = self.auto_state.current_summary.as_ref() else {
            return;
        };

        let display = summary.lines().find_map(|line| {
            let trimmed = line.trim();
            (!trimmed.is_empty()).then(|| Self::truncate_with_ellipsis(trimmed, 160))
        });

        let Some(display) = display else {
            return;
        };

        let needs_update = self
            .auto_state
            .current_display_line
            .as_ref()
            .map(|current| current != &display)
            .unwrap_or(true);

        if needs_update {
            self.auto_state.current_display_line = Some(display);
            self.auto_state.current_display_is_summary = true;
            self.auto_state.placeholder_phrase = None;
            self.auto_state.current_reasoning_title = None;
        }
    }

    fn auto_broadcast_summary(&mut self, raw: &str) {
        if !self.auto_state.is_active() {
            return;
        }

        let display_text = extract_latest_bold_title(raw).or_else(|| {
            raw.lines().find_map(|line| {
                let trimmed = line.trim();
                (!trimmed.is_empty()).then_some(trimmed.to_string())
            })
        });

        let Some(display_text) = display_text else {
            return;
        };

        if self
            .auto_state
            .last_broadcast_summary
            .as_ref()
            .map(|prev| prev == &display_text)
            .unwrap_or(false)
        {
            return;
        }

        self.auto_state.last_broadcast_summary = Some(display_text);
    }

    fn auto_on_reasoning_delta(&mut self, delta: &str, summary_index: Option<u32>) {
        if !self.auto_state.is_active() || delta.trim().is_empty() {
            return;
        }

        let mut needs_refresh = false;

        if let Some(idx) = summary_index {
            if self.auto_state.current_summary_index != Some(idx) {
                self.auto_state.current_summary_index = Some(idx);
                self.auto_state.current_summary = Some(String::new());
                self.auto_state.thinking_prefix_stripped = false;
                self.auto_state.current_reasoning_title = None;
                self.auto_state.current_display_line = None;
                self.auto_state.current_display_is_summary = false;
                self.auto_state.placeholder_phrase =
                    Some(auto_drive_strings::next_auto_drive_phrase().to_string());
                needs_refresh = true;
            }
        }

        let cleaned_delta = if !self.auto_state.thinking_prefix_stripped {
            let (without_prefix, stripped) = strip_role_prefix_if_present(delta);
            if stripped {
                self.auto_state.thinking_prefix_stripped = true;
            }
            without_prefix.to_string()
        } else {
            delta.to_string()
        };

        if !self.auto_state.thinking_prefix_stripped && !cleaned_delta.trim().is_empty() {
            self.auto_state.thinking_prefix_stripped = true;
        }

        {
            let entry = self
                .auto_state
                .current_summary
                .get_or_insert_with(String::new);

            if auto_drive_strings::is_auto_drive_phrase(entry) {
                entry.clear();
            }

            entry.push_str(&cleaned_delta);

            let mut display_updated = false;

            if let Some(title) = extract_latest_bold_title(entry) {
                let needs_update = self
                    .auto_state
                    .current_reasoning_title
                    .as_ref()
                    .map(|existing| existing != &title)
                    .unwrap_or(true);
                if needs_update {
                    self.auto_state.current_reasoning_title = Some(title.clone());
                    self.auto_state.current_display_line = Some(title);
                    self.auto_state.current_display_is_summary = false;
                    self.auto_state.placeholder_phrase = None;
                    display_updated = true;
                }
            } else if self.auto_state.current_reasoning_title.is_none() {
                let previous_line = self.auto_state.current_display_line.clone();
                let previous_is_summary = self.auto_state.current_display_is_summary;
                self.auto_update_display_title();
                let updated_line = self.auto_state.current_display_line.clone();
                let updated_is_summary = self.auto_state.current_display_is_summary;
                if updated_is_summary
                    && (updated_line != previous_line || !previous_is_summary)
                {
                    display_updated = true;
                }
            }

            if display_updated {
                needs_refresh = true;
            }
        }

        if needs_refresh {
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn auto_on_reasoning_final(&mut self, text: &str) {
        if !self.auto_state.is_active() {
            return;
        }

        self.auto_state.current_reasoning_title = None;
        self.auto_state.current_summary = Some(text.to_string());
        self.auto_state.thinking_prefix_stripped = true;
        self.auto_state.current_summary_index = None;
        self.auto_update_display_title();
        self.auto_broadcast_summary(text);

        if self.auto_state.is_waiting_for_response() {
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn truncate_with_ellipsis(text: &str, max_chars: usize) -> String {
        if max_chars == 0 {
            return String::new();
        }
        let total = text.chars().count();
        if total <= max_chars {
            return text.to_string();
        }
        let take = max_chars.saturating_sub(1);
        let mut out = String::with_capacity(max_chars);
        for (idx, ch) in text.chars().enumerate() {
            if idx >= take {
                break;
            }
            out.push(ch);
        }
        out.push('…');
        out
    }

    fn normalize_progress_field(field: Option<String>) -> Option<String> {
        field.and_then(|value| {
            let trimmed = value.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_string())
            }
        })
    }

    fn compose_progress_summary(
        progress_current: &Option<String>,
        progress_past: &Option<String>,
    ) -> String {
        let mut lines = Vec::new();
        if let Some(current) = progress_current.as_ref() {
            lines.push(current.clone());
        }
        if let Some(past) = progress_past.as_ref() {
            lines.push(past.clone());
        }
        lines.join("\n")
    }

    fn auto_append_progress_lines(
        &self,
        lines: &mut Vec<String>,
        progress_current: Option<&String>,
        progress_past: Option<&String>,
    ) -> bool {
        let initial_len = lines.len();
        Self::append_progress_line(lines, progress_current);
        Self::append_progress_line(lines, progress_past);
        lines.len() > initial_len
    }

    fn append_progress_line(lines: &mut Vec<String>, progress: Option<&String>) {
        if let Some(progress) = progress {
            let trimmed = progress.trim();
            if trimmed.is_empty() {
                return;
            }
            let display = Self::truncate_with_ellipsis(trimmed, 160);
            if !lines.iter().any(|existing| existing.trim() == display) {
                lines.push(display);
            }
        }
    }

    pub(crate) fn launch_update_command(
        &mut self,
        command: Vec<String>,
        display: String,
        latest_version: Option<String>,
    ) -> Option<TerminalLaunch> {
        if !crate::updates::upgrade_ui_enabled() {
            return None;
        }

        self.pending_upgrade_notice = None;
        if command.is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "`/update` — no upgrade command available for this install.".to_string(),
            ));
            self.request_redraw();
            return None;
        }

        let command_text = if display.trim().is_empty() {
            strip_bash_lc_and_escape(&command)
        } else {
            display.clone()
        };

        if command_text.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "`/update` — unable to resolve upgrade command text.".to_string(),
            ));
            self.request_redraw();
            return None;
        }

        let id = self.terminal.alloc_id();
        if let Some(version) = &latest_version {
            self.pending_upgrade_notice = Some((id, version.clone()));
        }

        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let display_label = Self::truncate_with_ellipsis(&format!("Guided: {command_text}"), 128);

        let launch = TerminalLaunch {
            id,
            title: "Upgrade Code".to_string(),
            command: Vec::new(),
            command_display: display_label,
            controller: Some(controller.clone()),
            auto_close_on_success: false,
            start_running: true,
        };

        let cwd = self.config.cwd.to_string_lossy().to_string();
        start_upgrade_terminal_session(
            self.app_event_tx.clone(),
            id,
            command_text,
            latest_version,
            Some(cwd),
            controller,
            controller_rx,
            self.config.clone(),
            self.config.debug,
        );

        Some(launch)
    }

    pub(crate) fn terminal_open(&mut self, launch: &TerminalLaunch) {
        let mut overlay = TerminalOverlay::new(
            launch.id,
            launch.title.clone(),
            launch.command_display.clone(),
            launch.auto_close_on_success,
        );
        if !launch.start_running {
            overlay.running = false;
        }
        let visible = self.terminal.last_visible_rows.get();
        overlay.visible_rows = visible;
        overlay.clamp_scroll();
        overlay.ensure_pending_command();
        self.terminal.overlay = Some(overlay);
        self.request_redraw();
    }

    pub(crate) fn terminal_append_chunk(&mut self, id: u64, chunk: &[u8], is_stderr: bool) {
        let mut needs_redraw = false;
        let visible = self.terminal.last_visible_rows.get();
        let visible_cols = self.terminal.last_visible_cols.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                if visible > 0 {
                    overlay.pty_rows = visible;
                }
                if visible_cols > 0 {
                    overlay.pty_cols = visible_cols;
                }
                if visible != overlay.visible_rows {
                    overlay.visible_rows = visible;
                    overlay.clamp_scroll();
                }
                overlay.append_chunk(chunk, is_stderr);
                needs_redraw = true;
            }
        }
        if needs_redraw {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_dimensions_hint(&self) -> Option<(u16, u16)> {
        let rows = self.terminal.last_visible_rows.get();
        let cols = self.terminal.last_visible_cols.get();
        if rows > 0 && cols > 0 {
            Some((rows, cols))
        } else {
            None
        }
    }

    pub(crate) fn terminal_apply_resize(&mut self, id: u64, rows: u16, cols: u16) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id && overlay.update_pty_dimensions(rows, cols) {
                self.request_redraw();
            }
        }
    }

    pub(crate) fn request_terminal_cancel(&mut self, id: u64) {
        let mut needs_redraw = false;
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.push_info_message("Cancel requested…");
                if overlay.running {
                    overlay.running = false;
                    needs_redraw = true;
                }
            }
        }
        if needs_redraw {
            self.request_redraw();
        }
        self.app_event_tx.send(AppEvent::TerminalCancel { id });
    }

    pub(crate) fn terminal_update_message(&mut self, id: u64, message: String) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.push_info_message(&message);
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_set_assistant_message(&mut self, id: u64, message: String) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.push_assistant_message(&message);
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_set_command_display(&mut self, id: u64, command: String) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.command_display = command;
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_prepare_command(
        &mut self,
        id: u64,
        suggestion: String,
        ack: Sender<TerminalCommandGate>,
    ) {
        let mut updated = false;
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.set_pending_command(suggestion, ack);
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_accept_pending_command(&mut self) -> Option<PendingCommandAction> {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.running {
                return None;
            }
            if let Some(action) = overlay.accept_pending_command() {
                match &action {
                    PendingCommandAction::Forwarded(command)
                    | PendingCommandAction::Manual(command) => {
                        overlay.command_display = command.clone();
                    }
                }
                self.request_redraw();
                return Some(action);
            }
        }
        None
    }

    pub(crate) fn terminal_execute_manual_command(&mut self, id: u64, command: String) {
        let trimmed = command.trim();
        if trimmed.is_empty() {
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.ensure_pending_command();
            }
            self.request_redraw();
            return;
        }

        if let Some(rest) = trimmed.strip_prefix("$$") {
            let prompt_text = rest.trim();
            if prompt_text.is_empty() {
                if let Some(overlay) = self.terminal.overlay_mut() {
                    overlay.push_info_message("Provide a prompt after '$'.");
                    overlay.ensure_pending_command();
                }
                self.request_redraw();
                return;
            }

            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.cancel_pending_command();
                overlay.running = true;
                overlay.exit_code = None;
                overlay.duration = None;
                overlay.push_assistant_message("Preparing guided command…");
            }

            let (controller_tx, controller_rx) = mpsc::channel();
            let controller = TerminalRunController { tx: controller_tx };
            let cwd = self.config.cwd.to_string_lossy().to_string();

            start_prompt_terminal_session(
                self.app_event_tx.clone(),
                id,
                prompt_text.to_string(),
                Some(cwd),
                controller,
                controller_rx,
                self.config.debug,
            );

            self.push_background_before_next_output(format!(
                "Terminal prompt: {prompt_text}"
            ));
            return;
        }

        let mut command_body = trimmed;
        let mut run_direct = false;
        if let Some(rest) = trimmed.strip_prefix('$') {
            let candidate = rest.trim();
            if candidate.is_empty() {
                if let Some(overlay) = self.terminal.overlay_mut() {
                    overlay.push_info_message("Provide a command after '$'.");
                    overlay.ensure_pending_command();
                }
                self.request_redraw();
                return;
            }
            command_body = candidate;
            run_direct = true;
        }

        let command_string = command_body.to_string();
        let wrapped_command = wrap_command(&command_string);
        if wrapped_command.is_empty() {
            self.app_event_tx.send(AppEvent::TerminalSetAssistantMessage {
                id,
                message: "Command could not be constructed.".to_string(),
            });
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.ensure_pending_command();
            }
            self.request_redraw();
            return;
        }

        if !matches!(self.config.sandbox_policy, SandboxPolicy::DangerFullAccess) {
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.cancel_pending_command();
            }
            self.pending_manual_terminal.insert(
                id,
                PendingManualTerminal {
                    command: command_string.clone(),
                    run_direct,
                },
            );
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.push_assistant_message("Awaiting approval to run this command…");
                overlay.running = false;
            }
            let ticket = self.make_background_before_next_output_ticket();
            self.bottom_pane.push_approval_request(
                ApprovalRequest::TerminalCommand {
                    id,
                    command: command_string,
                },
                ticket,
            );
            self.request_redraw();
            return;
        }

        if run_direct && self.terminal_dimensions_hint().is_some() {
            self.start_direct_terminal_command(id, command_string, wrapped_command);
        } else {
            self.start_manual_terminal_session(id, command_string);
        }
    }

    fn start_manual_terminal_session(&mut self, id: u64, command: String) {
        if command.is_empty() {
            return;
        }
        if let Some(overlay) = self.terminal.overlay_mut() {
            overlay.cancel_pending_command();
            overlay.running = true;
            overlay.exit_code = None;
            overlay.duration = None;
        }
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let cwd = self.config.cwd.to_string_lossy().to_string();
        start_direct_terminal_session(
            self.app_event_tx.clone(),
            id,
            command,
            Some(cwd),
            controller,
            controller_rx,
            self.config.debug,
        );
    }

    fn start_direct_terminal_command(
        &mut self,
        id: u64,
        display: String,
        command: Vec<String>,
    ) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            overlay.cancel_pending_command();
        }
        self.app_event_tx.send(AppEvent::TerminalRunCommand {
            id,
            command,
            command_display: display,
            controller: None,
        });
    }

    pub(crate) fn terminal_send_input(&mut self, id: u64, data: Vec<u8>) {
        if data.is_empty() {
            return;
        }
        self.app_event_tx
            .send(AppEvent::TerminalSendInput { id, data });
    }

    pub(crate) fn terminal_mark_running(&mut self, id: u64) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.running = true;
                overlay.exit_code = None;
                overlay.duration = None;
                overlay.start_time = Some(Instant::now());
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_finalize(
        &mut self,
        id: u64,
        exit_code: Option<i32>,
        duration: Duration,
    ) -> Option<TerminalAfter> {
        let mut success = false;
        let mut after = None;
        let mut needs_redraw = false;
        let mut should_close = false;
        let mut take_after = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.cancel_pending_command();
                if visible != overlay.visible_rows {
                    overlay.visible_rows = visible;
                    overlay.clamp_scroll();
                }
                let was_following = overlay.is_following();
                overlay.finalize(exit_code, duration);
                overlay.auto_follow(was_following);
                needs_redraw = true;
                if exit_code == Some(0) {
                    success = true;
                    take_after = true;
                    if overlay.auto_close_on_success {
                        should_close = true;
                    }
                }
                overlay.ensure_pending_command();
            }
        }
        if take_after {
            after = self.terminal.after.take();
        }
        if should_close {
            self.terminal.overlay = None;
        }
        if needs_redraw {
            self.request_redraw();
        }
        if success {
            if crate::updates::upgrade_ui_enabled() {
                if let Some((pending_id, version)) = self.pending_upgrade_notice.take() {
                    if pending_id == id {
                        self.bottom_pane
                            .flash_footer_notice(format!("Upgraded to {version}"));
                        self.latest_upgrade_version = None;
                    } else {
                        self.pending_upgrade_notice = Some((pending_id, version));
                    }
                }
            }
            after
        } else {
            None
        }
    }

    pub(crate) fn terminal_prepare_rerun(&mut self, id: u64) -> bool {
        let mut reset = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id && !overlay.running {
                overlay.reset_for_rerun();
                overlay.visible_rows = visible;
                overlay.clamp_scroll();
                overlay.ensure_pending_command();
                reset = true;
            }
        }
        if reset {
            self.request_redraw();
        }
        reset
    }

    pub(crate) fn handle_terminal_approval_decision(&mut self, id: u64, approved: bool) {
        let pending = self.pending_manual_terminal.remove(&id);
        if approved {
            if let Some(entry) = pending {
                if self
                    .terminal
                    .overlay()
                    .map(|overlay| overlay.id == id)
                    .unwrap_or(false)
                {
                    if let Some(overlay) = self.terminal.overlay_mut() {
                        overlay.push_assistant_message("Approval granted. Running command…");
                    }
                    if entry.run_direct && self.terminal_dimensions_hint().is_some() {
                        let command_vec = wrap_command(&entry.command);
                        self.start_direct_terminal_command(id, entry.command, command_vec);
                    } else {
                        self.start_manual_terminal_session(id, entry.command);
                    }
                    self.request_redraw();
                }
            }
            return;
        }

        if let Some(entry) = pending {
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.push_info_message("Command was not approved. You can edit it and try again.");
                overlay.running = false;
                overlay.exit_code = None;
                overlay.duration = None;
                overlay.pending_command = Some(PendingCommand::manual_with_input(entry.command));
            }
            self.request_redraw();
        }
    }

    pub(crate) fn close_terminal_overlay(&mut self) {
        let mut cancel_id = None;
        let mut preserved_visible = None;
        let mut overlay_id = None;
        if let Some(overlay) = self.terminal.overlay_mut() {
            overlay_id = Some(overlay.id);
            if overlay.running {
                cancel_id = Some(overlay.id);
            }
            overlay.cancel_pending_command();
            preserved_visible = Some(overlay.visible_rows);
        }
        if let Some(id) = cancel_id {
            self.app_event_tx.send(AppEvent::TerminalCancel { id });
        }
        if let Some(id) = overlay_id {
            self.pending_manual_terminal.remove(&id);
        }
        if let Some(visible_rows) = preserved_visible {
            self.terminal.last_visible_rows.set(visible_rows);
        }
        self.terminal.clear();
        self.request_redraw();
    }

    pub(crate) fn terminal_overlay_id(&self) -> Option<u64> {
        self.terminal.overlay().map(|o| o.id)
    }

    pub(crate) fn terminal_overlay_active(&self) -> bool {
        self.terminal.overlay().is_some()
    }

    pub(crate) fn terminal_is_running(&self) -> bool {
        self.terminal.overlay().map(|o| o.running).unwrap_or(false)
    }

    pub(crate) fn ctrl_c_requests_exit(&self) -> bool {
        !self.terminal_overlay_active() && self.bottom_pane.ctrl_c_quit_hint_visible()
    }

    pub(crate) fn terminal_has_pending_command(&self) -> bool {
        self.terminal
            .overlay()
            .and_then(|overlay| overlay.pending_command.as_ref())
            .is_some()
    }

    pub(crate) fn terminal_handle_pending_key(&mut self, key_event: KeyEvent) -> bool {
        if self.terminal_is_running() {
            return false;
        }
        if !self.terminal_has_pending_command() {
            return false;
        }
        if !matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat) {
            return true;
        }

        let mut needs_redraw = false;
        let mut handled = false;

        if let Some(overlay) = self.terminal.overlay_mut() {
            if let Some(pending) = overlay.pending_command.as_mut() {
                match key_event.code {
                    KeyCode::Char(ch) => {
                        if key_event
                            .modifiers
                            .intersects(KeyModifiers::CONTROL | KeyModifiers::ALT | KeyModifiers::SUPER)
                        {
                            handled = true;
                        } else if pending.insert_char(ch) {
                            needs_redraw = true;
                            handled = true;
                        } else {
                            handled = true;
                        }
                    }
                    KeyCode::Backspace => {
                        handled = true;
                        if pending.backspace() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Delete => {
                        handled = true;
                        if pending.delete() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Left => {
                        handled = true;
                        if pending.move_left() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Right => {
                        handled = true;
                        if pending.move_right() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Home => {
                        handled = true;
                        if pending.move_home() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::End => {
                        handled = true;
                        if pending.move_end() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Tab => {
                        handled = true;
                    }
                    _ => {}
                }
            }
        }

        if needs_redraw {
            self.request_redraw();
        }
        handled
    }

    pub(crate) fn terminal_scroll_lines(&mut self, delta: i32) {
        let mut updated = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if visible != overlay.visible_rows {
                overlay.visible_rows = visible;
            }
            let current = overlay.scroll as i32;
            let max_scroll = overlay.max_scroll() as i32;
            let mut next = current + delta;
            if next < 0 {
                next = 0;
            } else if next > max_scroll {
                next = max_scroll;
            }
            if next as u16 != overlay.scroll {
                overlay.scroll = next as u16;
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_scroll_page(&mut self, direction: i32) {
        let mut delta = None;
        let visible_value = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            let visible = visible_value.max(1);
            if visible != overlay.visible_rows {
                overlay.visible_rows = visible;
            }
            delta = Some((visible.saturating_sub(1)) as i32 * direction);
        }
        if let Some(amount) = delta {
            self.terminal_scroll_lines(amount);
        }
    }

    pub(crate) fn terminal_scroll_to_top(&mut self) {
        let mut updated = false;
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.scroll != 0 {
                overlay.scroll = 0;
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_scroll_to_bottom(&mut self) {
        let mut updated = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if visible != overlay.visible_rows {
                overlay.visible_rows = visible;
            }
            let max_scroll = overlay.max_scroll();
            if overlay.scroll != max_scroll {
                overlay.scroll = max_scroll;
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn handle_terminal_after(&mut self, after: TerminalAfter) {
        match after {
            TerminalAfter::RefreshAgentsAndClose { selected_index } => {
                self.agents_overview_selected_index = selected_index;
                self.show_agents_overview_ui();
            }
        }
    }

    // show_subagent_editor_ui removed; use show_subagent_editor_for_name or show_new_subagent_editor

    pub(crate) fn show_subagent_editor_for_name(&mut self, name: String) {
        // Build available agents from enabled ones (or sensible defaults)
        let available_agents: Vec<String> = if self.config.agents.is_empty() {
            enabled_agent_model_specs()
                .into_iter()
                .map(|spec| spec.slug.to_string())
                .collect()
        } else {
            self.config
                .agents
                .iter()
                .filter(|a| a.enabled)
                .map(|a| a.name.clone())
                .collect()
        };
        let existing = self.config.subagent_commands.clone();
        let app_event_tx = self.app_event_tx.clone();
        let build_editor = || {
            SubagentEditorView::new_with_data(
                name.clone(),
                available_agents.clone(),
                existing.clone(),
                false,
                app_event_tx.clone(),
            )
        };

        if self.try_set_agents_settings_editor(build_editor()) {
            self.request_redraw();
            return;
        }

        self.ensure_settings_overlay_section(SettingsSection::Agents);
        self.show_agents_overview_ui();
        let _ = self.try_set_agents_settings_editor(build_editor());
        self.request_redraw();
    }

    pub(crate) fn show_new_subagent_editor(&mut self) {
        let available_agents: Vec<String> = if self.config.agents.is_empty() {
            enabled_agent_model_specs()
                .into_iter()
                .map(|spec| spec.slug.to_string())
                .collect()
        } else {
            self.config
                .agents
                .iter()
                .filter(|a| a.enabled)
                .map(|a| a.name.clone())
                .collect()
        };
        let existing = self.config.subagent_commands.clone();
        let app_event_tx = self.app_event_tx.clone();
        let build_editor = || {
            SubagentEditorView::new_with_data(
                String::new(),
                available_agents.clone(),
                existing.clone(),
                true,
                app_event_tx.clone(),
            )
        };

        if self.try_set_agents_settings_editor(build_editor()) {
            self.request_redraw();
            return;
        }

        self.ensure_settings_overlay_section(SettingsSection::Agents);
        self.show_agents_overview_ui();
        let _ = self.try_set_agents_settings_editor(build_editor());
        self.request_redraw();
    }

    pub(crate) fn show_agent_editor_ui(&mut self, name: String) {
        if let Some(cfg) = self
            .config
            .agents
            .iter()
            .find(|a| a.name.eq_ignore_ascii_case(&name))
            .cloned()
        {
            let ro = if let Some(ref v) = cfg.args_read_only {
                Some(v.clone())
            } else if !cfg.args.is_empty() {
                Some(cfg.args.clone())
            } else {
                let d = code_core::agent_defaults::default_params_for(
                    &cfg.name, true, /*read_only*/
                );
                if d.is_empty() { None } else { Some(d) }
            };
            let wr = if let Some(ref v) = cfg.args_write {
                Some(v.clone())
            } else if !cfg.args.is_empty() {
                Some(cfg.args.clone())
            } else {
                let d = code_core::agent_defaults::default_params_for(
                    &cfg.name, false, /*read_only*/
                );
                if d.is_empty() { None } else { Some(d) }
            };
            let app_event_tx = self.app_event_tx.clone();
            let cfg_name = cfg.name.clone();
            let cfg_enabled = cfg.enabled;
            let cfg_instructions = cfg.instructions.clone();
            let cfg_command = Self::resolve_agent_command(
                &cfg.name,
                Some(cfg.command.as_str()),
                Some(cfg.command.as_str()),
            );
            let build_editor = || {
                AgentEditorView::new(
                    cfg_name.clone(),
                    cfg_enabled,
                    ro.clone(),
                    wr.clone(),
                    cfg_instructions.clone(),
                    cfg_command.clone(),
                    app_event_tx.clone(),
                )
            };
            if self.try_set_agents_settings_agent_editor(build_editor()) {
                self.request_redraw();
                return;
            }

            self.ensure_settings_overlay_section(SettingsSection::Agents);
            self.show_agents_overview_ui();
            let _ = self.try_set_agents_settings_agent_editor(build_editor());
            self.request_redraw();
        } else {
            // Fallback: synthesize defaults
            let cmd = Self::resolve_agent_command(&name, None, None);
            let ro = code_core::agent_defaults::default_params_for(&name, true /*read_only*/);
            let wr =
                code_core::agent_defaults::default_params_for(&name, false /*read_only*/);
            let app_event_tx = self.app_event_tx.clone();
            let build_editor = || {
                AgentEditorView::new(
                    name.clone(),
                    true,
                    if ro.is_empty() { None } else { Some(ro.clone()) },
                    if wr.is_empty() { None } else { Some(wr.clone()) },
                    None,
                    cmd.clone(),
                    app_event_tx.clone(),
                )
            };
            if self.try_set_agents_settings_agent_editor(build_editor()) {
                self.request_redraw();
                return;
            }

            self.ensure_settings_overlay_section(SettingsSection::Agents);
            self.show_agents_overview_ui();
            let _ = self.try_set_agents_settings_agent_editor(build_editor());
            self.request_redraw();
        }
    }

    pub(crate) fn apply_subagent_update(
        &mut self,
        cmd: code_core::config_types::SubagentCommandConfig,
    ) {
        if let Some(slot) = self
            .config
            .subagent_commands
            .iter_mut()
            .find(|c| c.name.eq_ignore_ascii_case(&cmd.name))
        {
            *slot = cmd;
        } else {
            self.config.subagent_commands.push(cmd);
        }

        self.refresh_settings_overview_rows();
    }

    pub(crate) fn delete_subagent_by_name(&mut self, name: &str) {
        self.config
            .subagent_commands
            .retain(|c| !c.name.eq_ignore_ascii_case(name));
        self.refresh_settings_overview_rows();
    }

    pub(crate) fn apply_agent_update(
        &mut self,
        name: &str,
        enabled: bool,
        args_ro: Option<Vec<String>>,
        args_wr: Option<Vec<String>>,
        instr: Option<String>,
        command: String,
    ) {
        let mut updated_existing = false;
        let provided_command = if command.trim().is_empty() { None } else { Some(command.as_str()) };
        let mut command_to_persist: Option<String> = None;
        if let Some(slot) = self
            .config
            .agents
            .iter_mut()
            .find(|a| a.name.eq_ignore_ascii_case(name))
        {
            slot.enabled = enabled;
            slot.args_read_only = args_ro.clone();
            slot.args_write = args_wr.clone();
            slot.instructions = instr.clone();
            let resolved = Self::resolve_agent_command(name, provided_command, Some(slot.command.as_str()));
            slot.command = resolved.clone();
            command_to_persist = Some(resolved);
            updated_existing = true;
        }

        if !updated_existing {
            let resolved = Self::resolve_agent_command(name, provided_command, None);
            let new_cfg = AgentConfig {
                name: name.to_string(),
                command: resolved.clone(),
                args: Vec::new(),
                read_only: false,
                enabled,
                description: None,
                env: None,
                args_read_only: args_ro.clone(),
                args_write: args_wr.clone(),
                instructions: instr.clone(),
            };
            self.config.agents.push(new_cfg);
            command_to_persist = Some(resolved);
        }
        // Persist asynchronously
        if let Ok(home) = code_core::config::find_code_home() {
            let name_s = name.to_string();
            let (en2, ro2, wr2, ins2) = (enabled, args_ro, args_wr, instr);
            let cmd2 = command_to_persist.clone();
            tokio::spawn(async move {
                let _ = code_core::config_edit::upsert_agent_config(
                    &home,
                    &name_s,
                    Some(en2),
                    None, // keep plain args as‑is
                    ro2.as_deref(),
                    wr2.as_deref(),
                    ins2.as_deref(),
                    cmd2.as_deref(),
                )
                .await;
            });
        }

        self.refresh_settings_overview_rows();
    }

    fn resolve_agent_command(
        name: &str,
        provided: Option<&str>,
        existing: Option<&str>,
    ) -> String {
        let spec = agent_model_spec(name);
        if let Some(cmd) = provided {
            if let Some(resolved) = Self::normalize_agent_command(cmd, name, spec) {
                return resolved;
            }
        }
        if let Some(cmd) = existing {
            if let Some(resolved) = Self::normalize_agent_command(cmd, name, spec) {
                return resolved;
            }
        }
        if let Some(spec) = spec {
            return spec.cli.to_string();
        }
        name.to_string()
    }

    fn normalize_agent_command(
        candidate: &str,
        name: &str,
        spec: Option<&code_core::agent_defaults::AgentModelSpec>,
    ) -> Option<String> {
        if candidate.trim().is_empty() {
            return None;
        }
        if let Some(spec) = spec {
            if candidate.eq_ignore_ascii_case(name) && !spec.cli.eq_ignore_ascii_case(name) {
                return Some(spec.cli.to_string());
            }
            if candidate.eq_ignore_ascii_case(spec.slug) && !spec.cli.eq_ignore_ascii_case(spec.slug) {
                return Some(spec.cli.to_string());
            }
        }
        Some(candidate.to_string())
    }

    pub(crate) fn show_diffs_popup(&mut self) {
        use crate::diff_render::create_diff_details_only;
        // Build a latest-first unique file list
        let mut order: Vec<PathBuf> = Vec::new();
        let mut seen: std::collections::HashSet<PathBuf> = std::collections::HashSet::new();
        for changes in self.diffs.session_patch_sets.iter().rev() {
            for (path, change) in changes.iter() {
                // If this change represents a move/rename, show the destination path in the tabs
                let display_path: PathBuf = match change {
                    code_core::protocol::FileChange::Update {
                        move_path: Some(dest),
                        ..
                    } => dest.clone(),
                    _ => path.clone(),
                };
                if seen.insert(display_path.clone()) {
                    order.push(display_path);
                }
            }
        }
        // Build tabs: for each file, create a single unified diff against the original baseline
        let mut tabs: Vec<(String, Vec<DiffBlock>)> = Vec::new();
        for path in order {
            // Resolve baseline (first-seen content) and current (on-disk) content
            let baseline = self
                .diffs
                .baseline_file_contents
                .get(&path)
                .cloned()
                .unwrap_or_default();
            let current = std::fs::read_to_string(&path).unwrap_or_default();
            // Build a unified diff from baseline -> current
            let unified = diffy::create_patch(&baseline, &current).to_string();
            // Render detailed lines (no header) using our diff renderer helpers
            let mut single = HashMap::new();
            single.insert(
                path.clone(),
                code_core::protocol::FileChange::Update {
                    unified_diff: unified.clone(),
                    move_path: None,
                    original_content: baseline.clone(),
                    new_content: current.clone(),
                },
            );
            let detail = create_diff_details_only(&single);
            let mut blocks: Vec<DiffBlock> = vec![DiffBlock { lines: detail }];

            // Count adds/removes for the header label from the unified diff
            let mut total_added: usize = 0;
            let mut total_removed: usize = 0;
            if let Ok(patch) = diffy::Patch::from_str(&unified) {
                for h in patch.hunks() {
                    for l in h.lines() {
                        match l {
                            diffy::Line::Insert(_) => total_added += 1,
                            diffy::Line::Delete(_) => total_removed += 1,
                            _ => {}
                        }
                    }
                }
            } else {
                for l in unified.lines() {
                    if l.starts_with("+++") || l.starts_with("---") || l.starts_with("@@") {
                        continue;
                    }
                    if let Some(b) = l.as_bytes().first() {
                        if *b == b'+' {
                            total_added += 1;
                        } else if *b == b'-' {
                            total_removed += 1;
                        }
                    }
                }
            }
            // Prepend a header block with the full path and counts
            let header_line = {
                use ratatui::style::Modifier;
                use ratatui::style::Style;
                use ratatui::text::Line as RtLine;
                use ratatui::text::Span as RtSpan;
                let mut spans: Vec<RtSpan<'static>> = Vec::new();
                spans.push(RtSpan::styled(
                    path.display().to_string(),
                    Style::default()
                        .fg(crate::colors::text())
                        .add_modifier(Modifier::BOLD),
                ));
                spans.push(RtSpan::raw(" "));
                spans.push(RtSpan::styled(
                    format!("+{}", total_added),
                    Style::default().fg(crate::colors::success()),
                ));
                spans.push(RtSpan::raw(" "));
                spans.push(RtSpan::styled(
                    format!("-{}", total_removed),
                    Style::default().fg(crate::colors::error()),
                ));
                RtLine::from(spans)
            };
            blocks.insert(
                0,
                DiffBlock {
                    lines: vec![header_line],
                },
            );

            // Tab title: file name only
            let title = path
                .file_name()
                .and_then(|s| s.to_str())
                .map(|s| s.to_string())
                .unwrap_or_else(|| path.display().to_string());
            tabs.push((title, blocks));
        }
        if tabs.is_empty() {
            // Nothing to show — surface a small notice so Ctrl+D feels responsive
            self.bottom_pane
                .flash_footer_notice("No diffs recorded this session".to_string());
            return;
        }
        self.diffs.overlay = Some(DiffOverlay::new(tabs));
        self.diffs.confirm = None;
        self.request_redraw();
    }

    pub(crate) fn toggle_diffs_popup(&mut self) {
        if self.diffs.overlay.is_some() {
            self.diffs.overlay = None;
            self.request_redraw();
        } else {
            self.show_diffs_popup();
        }
    }

    pub(crate) fn show_help_popup(&mut self) {
        let t_dim = Style::default().fg(crate::colors::text_dim());
        let t_fg = Style::default().fg(crate::colors::text());

        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Keyboard shortcuts",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        lines.push(RtLine::from(""));

        let kv = |k: &str, v: &str| -> RtLine<'static> {
            RtLine::from(vec![
                // Left-align the key column for improved readability
                RtSpan::styled(format!("{k:<12}"), t_fg),
                RtSpan::raw("  —  "),
                RtSpan::styled(v.to_string(), t_dim),
            ])
        };
        lines.push(RtLine::from(""));
        // Top quick action
        lines.push(kv(
            "Shift+Tab",
            "Rotate agent between Read Only / Write with Approval / Full Access",
        ));

        // Global
        lines.push(kv("Ctrl+H", "Help overlay"));
        lines.push(kv("Ctrl+R", "Toggle reasoning"));
        lines.push(kv("Ctrl+T", "Toggle screen"));
        lines.push(kv("Ctrl+D", "Diff viewer"));
        lines.push(kv("Esc", &format!("{} / close popups", Self::double_esc_hint_label())));
        // Task control shortcuts
        lines.push(kv("Esc", "End current task"));
        lines.push(kv("Ctrl+C", "End current task"));
        lines.push(kv("Ctrl+C twice", "Quit"));
        lines.push(RtLine::from(""));

        // Composer
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Compose field",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        lines.push(kv("Enter", "Send message"));
        lines.push(kv("Ctrl+J", "Insert newline"));
        lines.push(kv("Shift+Enter", "Insert newline"));
        // Split combined shortcuts into separate rows for readability
        lines.push(kv("Shift+Up", "Browse input history"));
        lines.push(kv("Shift+Down", "Browse input history"));
        lines.push(kv("Ctrl+B", "Move left"));
        lines.push(kv("Ctrl+F", "Move right"));
        lines.push(kv("Alt+Left", "Move by word"));
        lines.push(kv("Alt+Right", "Move by word"));
        // Simplify delete shortcuts; remove Alt+Backspace/Backspace/Delete variants
        lines.push(kv("Ctrl+W", "Delete previous word"));
        lines.push(kv("Ctrl+H", "Delete previous char"));
        lines.push(kv("Ctrl+D", "Delete next char"));
        lines.push(kv("Ctrl+Backspace", "Delete current line"));
        lines.push(kv("Ctrl+U", "Delete to line start"));
        lines.push(kv("Ctrl+K", "Delete to line end"));
        lines.push(kv(
            "Home/End",
            "Jump to line start/end (jump to history start/end when input is empty)",
        ));
        lines.push(RtLine::from(""));

        lines.push(RtLine::from(vec![RtSpan::styled(
            "Terminal",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        lines.push(kv("$", "Open shell terminal without a preset command"));
        lines.push(kv("$ <command>", "Run shell command immediately"));
        lines.push(kv("$$ <prompt>", "Request guided shell command help"));
        lines.push(RtLine::from(""));

        // Panels
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Panels",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        lines.push(kv("Ctrl+B", "Toggle Browser overlay"));
        lines.push(kv("Ctrl+A", "Open Agents terminal"));

        // Slash command reference
        lines.push(RtLine::from(""));
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Slash commands",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        for (cmd_str, cmd) in crate::slash_command::built_in_slash_commands() {
            // Hide internal test command from the Help panel
            if cmd_str == "test-approval" {
                continue;
            }
            // Prefer "Code" branding in the Help panel
            let desc = cmd.description().replace("Codex", "Code");
            // Render as "/command  —  description"
            lines.push(RtLine::from(vec![
                RtSpan::styled(format!("/{cmd_str:<12}"), t_fg),
                RtSpan::raw("  —  "),
                RtSpan::styled(desc.to_string(), t_dim),
            ]));
        }

        self.help.overlay = Some(HelpOverlay::new(lines));
        self.request_redraw();
    }

    pub(crate) fn toggle_help_popup(&mut self) {
        if self.help.overlay.is_some() {
            self.help.overlay = None;
        } else {
            self.show_help_popup();
        }
        self.request_redraw();
    }

    fn available_model_presets(&self) -> Vec<ModelPreset> {
        let auth_mode = if self.config.using_chatgpt_auth {
            Some(McpAuthMode::ChatGPT)
        } else {
            Some(McpAuthMode::ApiKey)
        };
        builtin_model_presets(auth_mode)
    }

    fn preset_effort_for_model(preset: &ModelPreset) -> ReasoningEffort {
        preset
            .effort
            .map(ReasoningEffort::from)
            .unwrap_or(ReasoningEffort::Medium)
    }

    fn find_model_preset(&self, input: &str, presets: &[ModelPreset]) -> Option<ModelPreset> {
        if presets.is_empty() {
            return None;
        }

        let input_lower = input.to_ascii_lowercase();
        let collapsed_input: String = input_lower
            .chars()
            .filter(|c| !c.is_ascii_whitespace() && *c != '-')
            .collect();

        let mut fallback_medium: Option<ModelPreset> = None;
        let mut fallback_none: Option<ModelPreset> = None;
        let mut fallback_first: Option<ModelPreset> = None;

        for &preset in presets.iter() {
            let preset_effort = Self::preset_effort_for_model(&preset);

            let id_lower = preset.id.to_ascii_lowercase();
            if Self::candidate_matches(&input_lower, &collapsed_input, &id_lower) {
                return Some(preset);
            }

            let label_lower = preset.label.to_ascii_lowercase();
            if Self::candidate_matches(&input_lower, &collapsed_input, &label_lower) {
                return Some(preset);
            }

            let effort_lower = preset_effort.to_string().to_ascii_lowercase();
            let model_lower = preset.model.to_ascii_lowercase();
            let spaced = format!("{model_lower} {effort_lower}");
            if Self::candidate_matches(&input_lower, &collapsed_input, &spaced) {
                return Some(preset);
            }
            let dashed = format!("{model_lower}-{effort_lower}");
            if Self::candidate_matches(&input_lower, &collapsed_input, &dashed) {
                return Some(preset);
            }

            if model_lower == input_lower
                || Self::candidate_matches(&input_lower, &collapsed_input, &model_lower)
            {
                if fallback_medium.is_none() && preset_effort == ReasoningEffort::Medium {
                    fallback_medium = Some(preset);
                }
                if fallback_none.is_none() && preset.effort.is_none() {
                    fallback_none = Some(preset);
                }
                if fallback_first.is_none() {
                    fallback_first = Some(preset);
                }
            }
        }

        fallback_medium.or(fallback_none).or(fallback_first)
    }

    fn candidate_matches(input: &str, collapsed_input: &str, candidate: &str) -> bool {
        let candidate_lower = candidate.to_ascii_lowercase();
        if candidate_lower == input {
            return true;
        }
        let candidate_collapsed: String = candidate_lower
            .chars()
            .filter(|c| !c.is_ascii_whitespace() && *c != '-')
            .collect();
        candidate_collapsed == collapsed_input
    }

    pub(crate) fn handle_model_command(&mut self, command_args: String) {
        if self.is_task_running() {
            let message = "'/model' is disabled while a task is in progress.".to_string();
            self.history_push_plain_state(history_cell::new_error_event(message));
            return;
        }

        let presets = self.available_model_presets();
        if presets.is_empty() {
            let message =
                "No model presets are available. Update your configuration to define models."
                    .to_string();
            self.history_push_plain_state(history_cell::new_error_event(message));
            return;
        }

        let trimmed = command_args.trim();
        if !trimmed.is_empty() {
            if let Some(preset) = self.find_model_preset(trimmed, &presets) {
                let effort = Self::preset_effort_for_model(&preset);
                self.apply_model_selection(preset.model.to_string(), Some(effort));
            } else {
                let message = format!(
                    "Unknown model preset: '{}'. Use /model with no arguments to open the selector.",
                    trimmed
                );
                self.history_push_plain_state(history_cell::new_error_event(message));
            }
            return;
        }

        self.bottom_pane.show_model_selection(
            presets,
            self.config.model.clone(),
            self.config.model_reasoning_effort,
        );
    }

    pub(crate) fn apply_model_selection(&mut self, model: String, effort: Option<ReasoningEffort>) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        let mut updated = false;
        if !self.config.model.eq_ignore_ascii_case(trimmed) {
            self.config.model = trimmed.to_string();
            let family = find_family_for_model(&self.config.model)
                .unwrap_or_else(|| derive_default_model_family(&self.config.model));
            self.config.model_family = family;
            updated = true;
        }

        if let Some(new_effort) = effort {
            if self.config.model_reasoning_effort != new_effort {
                self.config.model_reasoning_effort = new_effort;
                updated = true;
            }
        }

        if updated {
            let op = Op::ConfigureSession {
                provider: self.config.model_provider.clone(),
                model: self.config.model.clone(),
                model_reasoning_effort: self.config.model_reasoning_effort,
                model_reasoning_summary: self.config.model_reasoning_summary,
                model_text_verbosity: self.config.model_text_verbosity,
                user_instructions: self.config.user_instructions.clone(),
                base_instructions: self.config.base_instructions.clone(),
                approval_policy: self.config.approval_policy.clone(),
                sandbox_policy: self.config.sandbox_policy.clone(),
                disable_response_storage: self.config.disable_response_storage,
                notify: self.config.notify.clone(),
                cwd: self.config.cwd.clone(),
                resume_path: None,
            };
            self.submit_op(op);
            self.refresh_settings_overview_rows();
        }

        let placement = self.ui_placement_for_now();
        let state = history_cell::new_model_output(&self.config.model, self.config.model_reasoning_effort);
        let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
        self.push_system_cell(
            Box::new(cell),
            placement,
            Some("ui:model".to_string()),
            None,
            "system",
            Some(HistoryDomainRecord::Plain(state)),
        );

        self.request_redraw();
    }

    pub(crate) fn handle_reasoning_command(&mut self, command_args: String) {
        // command_args contains only the arguments after the command (e.g., "high" not "/reasoning high")
        let trimmed = command_args.trim();

        if !trimmed.is_empty() {
            // User specified a level: e.g., "high"
            let new_effort = match trimmed.to_lowercase().as_str() {
                "minimal" | "min" => ReasoningEffort::Minimal,
                "low" => ReasoningEffort::Low,
                "medium" | "med" => ReasoningEffort::Medium,
                "high" => ReasoningEffort::High,
                // Backwards compatibility: map legacy values to minimal.
                "none" | "off" => ReasoningEffort::Minimal,
                _ => {
                    // Invalid parameter, show error and return
                    let message = format!(
                        "Invalid reasoning level: '{}'. Use: minimal, low, medium, or high",
                        trimmed
                    );
                    self.history_push_plain_state(history_cell::new_error_event(message));
                    return;
                }
            };
            self.set_reasoning_effort(new_effort);
        } else {
            let presets = self.available_model_presets();
            if presets.is_empty() {
                let message =
                    "No model presets are available. Update your configuration to define models."
                        .to_string();
                self.history_push_plain_state(history_cell::new_error_event(message));
                return;
            }

            self.bottom_pane.show_model_selection(
                presets,
                self.config.model.clone(),
                self.config.model_reasoning_effort,
            );
            return;
        }
    }

    pub(crate) fn handle_verbosity_command(&mut self, command_args: String) {
        // Verbosity is not supported with ChatGPT auth
        if self.config.using_chatgpt_auth {
            let message =
                "Text verbosity is not available when using Sign in with ChatGPT".to_string();
            self.history_push_plain_state(history_cell::new_error_event(message));
            return;
        }

        // command_args contains only the arguments after the command (e.g., "high" not "/verbosity high")
        let trimmed = command_args.trim();

        if !trimmed.is_empty() {
            // User specified a level: e.g., "high"
            let new_verbosity = match trimmed.to_lowercase().as_str() {
                "low" => TextVerbosity::Low,
                "medium" | "med" => TextVerbosity::Medium,
                "high" => TextVerbosity::High,
                _ => {
                    // Invalid parameter, show error and return
                    let message = format!(
                        "Invalid verbosity level: '{}'. Use: low, medium, or high",
                        trimmed
                    );
                    self.history_push_plain_state(history_cell::new_error_event(message));
                    return;
                }
            };

            // Update the configuration
            self.config.model_text_verbosity = new_verbosity;

            // Display success message
            let message = format!("Text verbosity set to: {}", new_verbosity);
            self.push_background_tail(message);

            // Send the update to the backend
            let op = Op::ConfigureSession {
                provider: self.config.model_provider.clone(),
                model: self.config.model.clone(),
                model_reasoning_effort: self.config.model_reasoning_effort,
                model_reasoning_summary: self.config.model_reasoning_summary,
                model_text_verbosity: self.config.model_text_verbosity,
                user_instructions: self.config.user_instructions.clone(),
                base_instructions: self.config.base_instructions.clone(),
                approval_policy: self.config.approval_policy,
                sandbox_policy: self.config.sandbox_policy.clone(),
                disable_response_storage: self.config.disable_response_storage,
                notify: self.config.notify.clone(),
                cwd: self.config.cwd.clone(),
                resume_path: None,
            };
            let _ = self.code_op_tx.send(op);
        } else {
            // No parameter specified, show interactive UI
            self.bottom_pane
                .show_verbosity_selection(self.config.model_text_verbosity);
            return;
        }
    }

    pub(crate) fn prepare_agents(&mut self) {
        // Set the flag to show agents are ready to start
        self.agents_ready_to_start = true;
        self.agents_terminal.reset();
        if self.agents_terminal.active {
            // Reset scroll offset when a new batch starts to avoid stale positions
            self.layout.scroll_offset = 0;
        }

        // Initialize sparkline with some data so it shows immediately
        {
            let mut sparkline_data = self.sparkline_data.borrow_mut();
            if sparkline_data.is_empty() {
                // Add initial low activity data for preparing phase
                for _ in 0..10 {
                    sparkline_data.push((2, false));
                }
                tracing::info!(
                    "Initialized sparkline data with {} points for preparing phase",
                    sparkline_data.len()
                );
            }
        } // Drop the borrow here

        self.request_redraw();
    }

    /// Update sparkline data with randomized activity based on agent count
    fn update_sparkline_data(&self) {
        let now = std::time::Instant::now();

        // Update every 100ms for smooth animation
        if now
            .duration_since(*self.last_sparkline_update.borrow())
            .as_millis()
            < 100
        {
            return;
        }

        *self.last_sparkline_update.borrow_mut() = now;

        // Calculate base height based on number of agents and status
        let agent_count = self.active_agents.len();
        let is_planning = self.overall_task_status == "planning";
        let base_height = if agent_count == 0 && self.agents_ready_to_start {
            2 // Minimal activity when preparing
        } else if is_planning && agent_count > 0 {
            3 // Low activity during planning phase
        } else if agent_count == 1 {
            5 // Low activity for single agent
        } else if agent_count == 2 {
            10 // Medium activity for two agents
        } else if agent_count >= 3 {
            15 // High activity for multiple agents
        } else {
            0 // No activity when no agents
        };

        // Don't generate data if there's no activity
        if base_height == 0 {
            return;
        }

        // Generate random variation
        use std::collections::hash_map::DefaultHasher;
        use std::hash::Hash;
        use std::hash::Hasher;
        let mut hasher = DefaultHasher::new();
        now.elapsed().as_nanos().hash(&mut hasher);
        let random_seed = hasher.finish();

        // More variation during planning phase for visibility (+/- 50%)
        // Less variation during running for stability (+/- 30%)
        let variation_percent = if self.agents_ready_to_start && self.active_agents.is_empty() {
            50 // More variation during planning for visibility
        } else {
            30 // Standard variation during running
        };

        let variation_range = variation_percent * 2; // e.g., 100 for +/- 50%
        let variation = ((random_seed % variation_range) as i32 - variation_percent as i32)
            * base_height as i32
            / 100;
        let height = ((base_height as i32 + variation).max(1) as u64).min(20);

        // Check if any agents are completed
        let has_completed = self
            .active_agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Completed));

        // Keep a rolling window of 60 data points (about 6 seconds at 100ms intervals)
        let mut sparkline_data = self.sparkline_data.borrow_mut();
        sparkline_data.push((height, has_completed));
        if sparkline_data.len() > 60 {
            sparkline_data.remove(0);
        }
    }

    pub(crate) fn set_reasoning_effort(&mut self, new_effort: ReasoningEffort) {
        // Update the config
        self.config.model_reasoning_effort = new_effort;

        // Send ConfigureSession op to update the backend
        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_reasoning_effort: new_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: self.config.model_text_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
        };

        self.submit_op(op);

        // Add status message to history (replaceable system notice)
        let placement = self.ui_placement_for_now();
        let state = history_cell::new_reasoning_output(&new_effort);
        let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
        self.push_system_cell(
            Box::new(cell),
            placement,
            Some("ui:reasoning".to_string()),
            None,
            "system",
            Some(HistoryDomainRecord::Plain(state)),
        );
        self.refresh_settings_overview_rows();
    }

    pub(crate) fn set_text_verbosity(&mut self, new_verbosity: TextVerbosity) {
        // Update the config
        self.config.model_text_verbosity = new_verbosity;

        // Send ConfigureSession op to update the backend
        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_reasoning_effort: self.config.model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: new_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
        };

        self.submit_op(op);

        // Add status message to history
        let message = format!("Text verbosity set to: {}", new_verbosity);
        self.push_background_tail(message);
    }

    pub(crate) fn set_auto_upgrade_enabled(&mut self, enabled: bool) {
        if self.config.auto_upgrade_enabled == enabled {
            return;
        }
        self.config.auto_upgrade_enabled = enabled;

        let code_home = self.config.code_home.clone();
        let profile = self.config.active_profile.clone();
        tokio::spawn(async move {
            if let Err(err) = code_core::config_edit::persist_overrides(
                &code_home,
                profile.as_deref(),
                &[(&["auto_upgrade_enabled"], if enabled { "true" } else { "false" })],
            )
            .await
            {
                tracing::warn!("failed to persist auto-upgrade setting: {err}");
            }
        });

        let notice = if enabled {
            "Automatic upgrades enabled"
        } else {
            "Automatic upgrades disabled"
        };
        self.bottom_pane.flash_footer_notice(notice.to_string());

        let should_refresh_updates = matches!(
            self.settings
                .overlay
                .as_ref()
                .map(|overlay| overlay.active_section()),
            Some(SettingsSection::Updates)
        );

        if should_refresh_updates {
            if let Some(content) = self.build_updates_settings_content() {
                if let Some(overlay) = self.settings.overlay.as_mut() {
                    overlay.set_updates_content(content);
                }
            }
        }
        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    /// Forward file-search results to the bottom pane.
    pub(crate) fn apply_file_search_result(&mut self, query: String, matches: Vec<FileMatch>) {
        self.bottom_pane.on_file_search_result(query, matches);
    }

    #[allow(dead_code)]
    pub(crate) fn show_theme_selection(&mut self) {
        let tail_ticket = self.make_background_tail_ticket();
        let before_ticket = self.make_background_before_next_output_ticket();
        self.bottom_pane.show_theme_selection(
            crate::theme::current_theme_name(),
            tail_ticket,
            before_ticket,
        );
    }

    pub(crate) fn show_settings_overlay(&mut self, section: Option<SettingsSection>) {
        let initial_section = section
            .or_else(|| {
                self.settings
                    .overlay
                    .as_ref()
                    .map(|overlay| overlay.active_section())
            })
            .unwrap_or(SettingsSection::Model);

        let mut overlay = SettingsOverlayView::new(initial_section);
        overlay.set_model_content(self.build_model_settings_content());
        overlay.set_theme_content(self.build_theme_settings_content());
        if let Some(update_content) = self.build_updates_settings_content() {
            overlay.set_updates_content(update_content);
        }
        overlay.set_notifications_content(self.build_notifications_settings_content());
        if let Some(mcp_content) = self.build_mcp_settings_content() {
            overlay.set_mcp_content(mcp_content);
        }
        overlay.set_agents_content(self.build_agents_settings_content());
        overlay.set_auto_drive_content(self.build_auto_drive_settings_content());
        overlay.set_validation_content(self.build_validation_settings_content());
        overlay.set_github_content(self.build_github_settings_content());
        overlay.set_limits_content(self.build_limits_settings_content());
        overlay.set_chrome_content(self.build_chrome_settings_content(None));
        let overview_rows = self.build_settings_overview_rows();
        overlay.set_overview_rows(overview_rows);

        match section {
            Some(section) => overlay.set_mode_section(section),
            None => overlay.set_mode_menu(None),
        }

        self.settings.overlay = Some(overlay);
        self.request_redraw();
    }

    pub(crate) fn ensure_settings_overlay_section(&mut self, section: SettingsSection) {
        match self.settings.overlay.as_mut() {
            Some(overlay) => {
                let was_menu = overlay.is_menu_active();
                let changed_section = overlay.active_section() != section;
                overlay.set_mode_section(section);
                if was_menu || changed_section {
                    self.request_redraw();
                }
            }
            None => {
                self.show_settings_overlay(Some(section));
            }
        }
    }

    fn build_model_settings_content(&self) -> ModelSettingsContent {
        let presets = self.available_model_presets();
        let current_model = self.config.model.clone();
        let current_effort = self.config.model_reasoning_effort;
        let view = ModelSelectionView::new(
            presets,
            current_model,
            current_effort,
            self.app_event_tx.clone(),
        );
        ModelSettingsContent::new(view)
    }

    fn build_theme_settings_content(&mut self) -> ThemeSettingsContent {
        let tail_ticket = self.make_background_tail_ticket();
        let before_ticket = self.make_background_before_next_output_ticket();
        let view = ThemeSelectionView::new(
            crate::theme::current_theme_name(),
            self.app_event_tx.clone(),
            tail_ticket,
            before_ticket,
        );
        ThemeSettingsContent::new(view)
    }

    fn build_notifications_settings_view(&mut self) -> NotificationsSettingsView {
        let mode = match &self.config.tui.notifications {
            Notifications::Enabled(enabled) => NotificationsMode::Toggle { enabled: *enabled },
            Notifications::Custom(entries) => NotificationsMode::Custom { entries: entries.clone() },
        };
        let ticket = self.make_background_tail_ticket();
        NotificationsSettingsView::new(mode, self.app_event_tx.clone(), ticket)
    }

    fn build_notifications_settings_content(&mut self) -> NotificationsSettingsContent {
        NotificationsSettingsContent::new(self.build_notifications_settings_view())
    }

    fn build_chrome_settings_content(&self, port: Option<u16>) -> ChromeSettingsContent {
        ChromeSettingsContent::new(self.app_event_tx.clone(), port)
    }

    fn build_mcp_server_rows(&mut self) -> Option<McpServerRows> {
        let home = match code_core::config::find_code_home() {
            Ok(home) => home,
            Err(e) => {
                let msg = format!("Failed to locate CODE_HOME: {}", e);
                self.history_push_plain_state(history_cell::new_error_event(msg));
                return None;
            }
        };

        let (enabled, disabled) = match code_core::config::list_mcp_servers(&home) {
            Ok(result) => result,
            Err(e) => {
                let msg = format!("Failed to read MCP config: {}", e);
                self.history_push_plain_state(history_cell::new_error_event(msg));
                return None;
            }
        };

        let mut rows: McpServerRows = Vec::new();
        for (name, cfg) in enabled.into_iter() {
            rows.push(McpServerRow {
                name,
                enabled: true,
                summary: Self::format_mcp_summary(&cfg),
            });
        }
        for (name, cfg) in disabled.into_iter() {
            rows.push(McpServerRow {
                name,
                enabled: false,
                summary: Self::format_mcp_summary(&cfg),
            });
        }
        rows.sort_by(|a, b| a.name.cmp(&b.name));
        Some(rows)
    }

    fn build_mcp_settings_content(&mut self) -> Option<McpSettingsContent> {
        let rows = self.build_mcp_server_rows()?;
        let view = McpSettingsView::new(rows, self.app_event_tx.clone());
        Some(McpSettingsContent::new(view))
    }

    fn collect_agents_overview_rows(&self) -> (Vec<AgentOverviewRow>, Vec<String>) {
        fn command_exists(cmd: &str) -> bool {
            if cmd.contains(std::path::MAIN_SEPARATOR) || cmd.contains('/') || cmd.contains('\\') {
                return std::fs::metadata(cmd).map(|m| m.is_file()).unwrap_or(false);
            }
            #[cfg(target_os = "windows")]
            {
                which::which(cmd).map(|p| p.is_file()).unwrap_or(false)
            }
            #[cfg(not(target_os = "windows"))]
            {
                use std::os::unix::fs::PermissionsExt;
                let Some(path_os) = std::env::var_os("PATH") else {
                    return false;
                };
                for dir in std::env::split_paths(&path_os) {
                    if dir.as_os_str().is_empty() {
                        continue;
                    }
                    let candidate = dir.join(cmd);
                    if let Ok(meta) = std::fs::metadata(&candidate) {
                        if meta.is_file() && (meta.permissions().mode() & 0o111 != 0) {
                            return true;
                        }
                    }
                }
                false
            }
        }

        fn is_builtin_agent(name: &str, command: &str) -> bool {
            name.eq_ignore_ascii_case("code")
                || name.eq_ignore_ascii_case("codex")
                || name.eq_ignore_ascii_case("cloud")
                || command.eq_ignore_ascii_case("code")
                || command.eq_ignore_ascii_case("codex")
                || command.eq_ignore_ascii_case("cloud")
        }

        let mut agent_rows: Vec<AgentOverviewRow> = Vec::new();
        let mut ordered: Vec<String> = enabled_agent_model_specs()
            .into_iter()
            .map(|spec| spec.slug.to_string())
            .collect();
        let mut extras: Vec<String> = Vec::new();
        for agent in &self.config.agents {
            if !ordered.iter().any(|name| agent.name.eq_ignore_ascii_case(name)) {
                extras.push(agent.name.to_ascii_lowercase());
            }
        }
        extras.sort();
        for extra in extras {
            if !ordered.iter().any(|name| name.eq_ignore_ascii_case(&extra)) {
                ordered.push(extra);
            }
        }

        for name in ordered.iter() {
            if let Some(cfg) = self
                .config
                .agents
                .iter()
                .find(|a| a.name.eq_ignore_ascii_case(name))
            {
                let builtin = is_builtin_agent(&cfg.name, &cfg.command);
                let spec_cli = agent_model_spec(&cfg.name)
                    .or_else(|| agent_model_spec(&cfg.command))
                    .map(|spec| spec.cli);
                let installed = if builtin {
                    true
                } else if command_exists(&cfg.command) {
                    true
                } else if let Some(cli) = spec_cli {
                    command_exists(cli)
                } else {
                    false
                };
                agent_rows.push(AgentOverviewRow {
                    name: cfg.name.clone(),
                    enabled: cfg.enabled,
                    installed,
                });
            } else {
                let cmd = name.clone();
                let builtin = is_builtin_agent(name, &cmd);
                let spec_cli = agent_model_spec(name).map(|spec| spec.cli);
                let installed = if builtin {
                    true
                } else if let Some(cli) = spec_cli {
                    command_exists(cli)
                } else {
                    command_exists(&cmd)
                };
                agent_rows.push(AgentOverviewRow {
                    name: name.clone(),
                    enabled: true,
                    installed,
                });
            }
        }

        let mut commands: Vec<String> = vec!["plan".into(), "solve".into(), "code".into()];
        let custom: Vec<String> = self
            .config
            .subagent_commands
            .iter()
            .map(|c| c.name.clone())
            .filter(|name| !commands.iter().any(|builtin| builtin.eq_ignore_ascii_case(name)))
            .collect();
        commands.extend(custom);

        (agent_rows, commands)
    }

    fn build_agents_settings_content(&mut self) -> AgentsSettingsContent {
        let (rows, commands) = self.collect_agents_overview_rows();
        let total = rows.len().saturating_add(commands.len()).saturating_add(1);
        let selected = if total == 0 {
            0
        } else {
            self.agents_overview_selected_index.min(total.saturating_sub(1))
        };
        self.agents_overview_selected_index = selected;
        AgentsSettingsContent::new_overview(rows, commands, selected, self.app_event_tx.clone())
    }

    fn build_limits_settings_content(&mut self) -> LimitsSettingsContent {
        let snapshot = self.rate_limit_snapshot.clone();
        let needs_refresh = self.should_refresh_limits();

        let content = if self.rate_limit_fetch_inflight || needs_refresh {
            LimitsOverlayContent::Loading
        } else {
            let reset_info = self.rate_limit_reset_info();
            let tabs = self.build_limits_tabs(snapshot.clone(), reset_info);
            if tabs.is_empty() {
                LimitsOverlayContent::Placeholder
            } else {
                LimitsOverlayContent::Tabs(tabs)
            }
        };

        if needs_refresh {
            self.request_latest_rate_limits(snapshot.is_none());
        }

        LimitsSettingsContent::new(content)
    }

    fn build_settings_overview_rows(&mut self) -> Vec<SettingsOverviewRow> {
        SettingsSection::ALL
            .iter()
            .copied()
            .map(|section| {
                let summary = match section {
                    SettingsSection::Model => self.settings_summary_model(),
                    SettingsSection::Theme => self.settings_summary_theme(),
                    SettingsSection::Updates => self.settings_summary_updates(),
                    SettingsSection::Agents => self.settings_summary_agents(),
                    SettingsSection::AutoDrive => self.settings_summary_auto_drive(),
                    SettingsSection::Validation => self.settings_summary_validation(),
                    SettingsSection::Github => self.settings_summary_github(),
                    SettingsSection::Limits => self.settings_summary_limits(),
                    SettingsSection::Chrome => self.settings_summary_chrome(),
                    SettingsSection::Mcp => self.settings_summary_mcp(),
                    SettingsSection::Notifications => self.settings_summary_notifications(),
                };
                SettingsOverviewRow::new(section, summary)
            })
            .collect()
    }

    fn settings_summary_model(&self) -> Option<String> {
        let mut parts: Vec<String> = Vec::new();
        let model = self.config.model.trim();
        let model_display = if model.is_empty() { "—" } else { model };
        parts.push(format!("Model: {}", model_display));
        parts.push(format!(
            "Effort: {}",
            Self::format_reasoning_effort(self.config.model_reasoning_effort)
        ));
        if let Some(profile) = self
            .config
            .active_profile
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
        {
            parts.push(format!("Profile: {}", profile));
        }
        Some(parts.join(" · "))
    }

    fn settings_summary_theme(&self) -> Option<String> {
        let theme_label = Self::theme_display_name(self.config.tui.theme.name);
        let spinner_name = &self.config.tui.spinner.name;
        let spinner_label = spinner::spinner_label_for(spinner_name);
        Some(format!("Theme: {} · Spinner: {}", theme_label, spinner_label))
    }

    fn settings_summary_updates(&self) -> Option<String> {
        if !crate::updates::upgrade_ui_enabled() {
            return Some("Auto update: Disabled".to_string());
        }
        let status = if self.config.auto_upgrade_enabled {
            "Enabled"
        } else {
            "Disabled"
        };
        let mut parts = vec![format!("Auto update: {}", status)];
        if let Some(latest) = self
            .latest_upgrade_version
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
        {
            parts.push(format!("Latest available: {}", latest));
        }
        Some(parts.join(" · "))
    }

    fn settings_summary_agents(&self) -> Option<String> {
        let total = self.config.agents.len();
        let enabled = self
            .config
            .agents
            .iter()
            .filter(|agent| agent.enabled)
            .count();
        let commands = self.config.subagent_commands.len();
        let mut parts = vec![format!("Enabled: {}/{}", enabled, total)];
        if commands > 0 {
            parts.push(format!("Custom commands: {}", commands));
        }
        Some(parts.join(" · "))
    }

    fn settings_summary_auto_drive(&self) -> Option<String> {
        let diagnostics_enabled = self.auto_state.qa_automation_enabled
            && (self.auto_state.review_enabled || self.auto_state.cross_check_enabled);
        Some(format!(
            "Agents: {} · Diagnostics: {} · Continue: {}",
            Self::on_off_label(self.auto_state.subagents_enabled),
            Self::on_off_label(diagnostics_enabled),
            self.auto_state.continue_mode.label()
        ))
    }

    fn settings_summary_validation(&self) -> Option<String> {
        let groups = &self.config.validation.groups;
        Some(format!(
            "Functional: {} · Stylistic: {}",
            Self::on_off_label(groups.functional),
            Self::on_off_label(groups.stylistic)
        ))
    }

    fn settings_summary_github(&self) -> Option<String> {
        Some(format!(
            "Workflows on push: {}",
            if self.config.github.check_workflows_on_push { "On" } else { "Off" }
        ))
    }

    fn settings_summary_limits(&self) -> Option<String> {
        if let Some(snapshot) = &self.rate_limit_snapshot {
            let primary = snapshot.primary_used_percent.clamp(0.0, 100.0).round() as i64;
            let secondary = snapshot.secondary_used_percent.clamp(0.0, 100.0).round() as i64;
            Some(format!("Primary: {}% · Secondary: {}%", primary, secondary))
        } else if self.rate_limit_fetch_inflight {
            Some("Refreshing usage...".to_string())
        } else {
            Some("Usage data not loaded".to_string())
        }
    }

    fn settings_summary_chrome(&self) -> Option<String> {
        if self.browser_is_external {
            Some("Browser: external".to_string())
        } else {
            Some("Browser: available".to_string())
        }
    }

    fn settings_summary_mcp(&self) -> Option<String> {
        Some(format!(
            "Servers configured: {}",
            self.config.mcp_servers.len()
        ))
    }

    fn settings_summary_notifications(&self) -> Option<String> {
        match &self.config.tui.notifications {
            Notifications::Enabled(enabled) => {
                Some(format!("Desktop alerts: {}", Self::on_off_label(*enabled)))
            }
            Notifications::Custom(entries) => Some(format!("Custom rules: {}", entries.len())),
        }
    }

    fn refresh_settings_overview_rows(&mut self) {
        if self.settings.overlay.is_none() {
            return;
        }
        let rows = self.build_settings_overview_rows();
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_overview_rows(rows);
        }
        self.request_redraw();
    }

    fn format_reasoning_effort(effort: ReasoningEffort) -> &'static str {
        match effort {
            ReasoningEffort::Minimal | ReasoningEffort::None => "Minimal",
            ReasoningEffort::Low => "Low",
            ReasoningEffort::Medium => "Medium",
            ReasoningEffort::High => "High",
        }
    }

    fn on_off_label(value: bool) -> &'static str {
        if value { "On" } else { "Off" }
    }

    fn theme_display_name(theme: code_core::config_types::ThemeName) -> String {
        match theme {
            code_core::config_types::ThemeName::LightPhoton => "Light - Photon".to_string(),
            code_core::config_types::ThemeName::LightPhotonAnsi16 => {
                "Light - Photon (16-color)".to_string()
            }
            code_core::config_types::ThemeName::LightPrismRainbow => {
                "Light - Prism Rainbow".to_string()
            }
            code_core::config_types::ThemeName::LightVividTriad => {
                "Light - Vivid Triad".to_string()
            }
            code_core::config_types::ThemeName::LightPorcelain => "Light - Porcelain".to_string(),
            code_core::config_types::ThemeName::LightSandbar => "Light - Sandbar".to_string(),
            code_core::config_types::ThemeName::LightGlacier => "Light - Glacier".to_string(),
            code_core::config_types::ThemeName::DarkCarbonNight => {
                "Dark - Carbon Night".to_string()
            }
            code_core::config_types::ThemeName::DarkCarbonAnsi16 => {
                "Dark - Carbon (16-color)".to_string()
            }
            code_core::config_types::ThemeName::DarkShinobiDusk => {
                "Dark - Shinobi Dusk".to_string()
            }
            code_core::config_types::ThemeName::DarkOledBlackPro => {
                "Dark - OLED Black Pro".to_string()
            }
            code_core::config_types::ThemeName::DarkAmberTerminal => {
                "Dark - Amber Terminal".to_string()
            }
            code_core::config_types::ThemeName::DarkAuroraFlux => "Dark - Aurora Flux".to_string(),
            code_core::config_types::ThemeName::DarkCharcoalRainbow => {
                "Dark - Charcoal Rainbow".to_string()
            }
            code_core::config_types::ThemeName::DarkZenGarden => "Dark - Zen Garden".to_string(),
            code_core::config_types::ThemeName::DarkPaperLightPro => {
                "Dark - Paper Light Pro".to_string()
            }
            code_core::config_types::ThemeName::Custom => {
                let mut label =
                    crate::theme::custom_theme_label().unwrap_or_else(|| "Custom".to_string());
                for pref in ["Light - ", "Dark - ", "Light ", "Dark "] {
                    if label.starts_with(pref) {
                        label = label[pref.len()..].trim().to_string();
                        break;
                    }
                }
                if crate::theme::custom_theme_is_dark().unwrap_or(false) {
                    format!("Dark - {}", label)
                } else {
                    format!("Light - {}", label)
                }
            }
        }
    }

    pub(crate) fn close_settings_overlay(&mut self) {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.notify_close();
        }
        self.settings.overlay = None;
        self.request_redraw();
    }

    pub(crate) fn activate_current_settings_section(&mut self) -> bool {
        let section = match self
            .settings
            .overlay
            .as_ref()
            .map(|overlay| overlay.active_section())
        {
            Some(section) => section,
            None => return false,
        };

        let handled = match section {
            SettingsSection::Model
            | SettingsSection::Theme
            | SettingsSection::Updates
            | SettingsSection::Validation
            | SettingsSection::Github
            | SettingsSection::AutoDrive
            | SettingsSection::Mcp
            | SettingsSection::Notifications => false,
            SettingsSection::Agents => {
                self.show_agents_overview_ui();
                false
            }
            SettingsSection::Limits => {
                self.show_limits_settings_ui();
                false
            }
            SettingsSection::Chrome => {
                self.show_chrome_options(None);
                true
            }
        };

        if handled {
            self.close_settings_overlay();
        }

        handled
    }

    pub(crate) fn settings_section_from_hint(section: &str) -> Option<SettingsSection> {
        SettingsSection::from_hint(section)
    }

    // Ctrl+Y syntax cycling disabled intentionally.

    /// Show a brief debug notice in the footer.
    #[allow(dead_code)]
    pub(crate) fn debug_notice(&mut self, text: String) {
        self.bottom_pane.flash_footer_notice(text);
        self.request_redraw();
    }

    fn maybe_start_auto_upgrade_task(&mut self) {
        if !crate::updates::auto_upgrade_runtime_enabled() {
            return;
        }
        if !self.config.auto_upgrade_enabled {
            return;
        }

        let cfg = self.config.clone();
        let tx = self.app_event_tx.clone();
        let upgrade_ticket = self.make_background_tail_ticket();
        tokio::spawn(async move {
            match crate::updates::auto_upgrade_if_enabled(&cfg).await {
                Ok(outcome) => {
                    if let Some(version) = outcome.installed_version {
                        tx.send(AppEvent::AutoUpgradeCompleted { version });
                    }
                    if let Some(message) = outcome.user_notice {
                        tx.send_background_event_with_ticket(&upgrade_ticket, message);
                    }
                }
                Err(err) => {
                    tracing::warn!("auto-upgrade: background task failed: {err:?}");
                }
            }
        });
    }

    pub(crate) fn set_theme(&mut self, new_theme: code_core::config_types::ThemeName) {
        let custom_hint = if matches!(new_theme, code_core::config_types::ThemeName::Custom) {
            self.config
                .tui
                .theme
                .is_dark
                .or_else(|| crate::theme::custom_theme_is_dark())
        } else {
            None
        };
        let mapped_theme = crate::theme::map_theme_for_palette(new_theme, custom_hint);

        // Update the config
        self.config.tui.theme.name = mapped_theme;
        if matches!(new_theme, code_core::config_types::ThemeName::Custom) {
            self.config.tui.theme.is_dark = custom_hint;
        } else {
            self.config.tui.theme.is_dark = None;
        }

        // Save the theme to config file
        self.save_theme_to_config(mapped_theme);

        // Retint pre-rendered history cell lines to the new palette
        self.restyle_history_after_theme_change();

        // Add confirmation message to history (replaceable system notice)
        let theme_name = Self::theme_display_name(mapped_theme);
        let message = format!("Theme changed to {}", theme_name);
        let placement = self.ui_placement_for_now();
        let cell = history_cell::new_background_event(message);
        let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
        self.push_system_cell(
            Box::new(cell),
            placement,
            Some("ui:theme".to_string()),
            None,
            "background",
            Some(record),
        );
        self.refresh_settings_overview_rows();
    }

    pub(crate) fn set_spinner(&mut self, spinner_name: String) {
        // Update the config
        self.config.tui.spinner.name = spinner_name.clone();
        // Persist selection to config file
        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(e) = code_core::config::set_tui_spinner_name(&home, &spinner_name) {
                tracing::warn!("Failed to persist spinner to config.toml: {}", e);
            } else {
                tracing::info!("Persisted TUI spinner selection to config.toml");
            }
        } else {
            tracing::warn!("Could not locate Codex home to persist spinner selection");
        }

        // Confirmation message (replaceable system notice)
        let message = format!("Spinner changed to {}", spinner_name);
        let placement = self.ui_placement_for_now();
        let cell = history_cell::new_background_event(message);
        let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
        self.push_system_cell(
            Box::new(cell),
            placement,
            Some("ui:spinner".to_string()),
            None,
            "background",
            Some(record),
        );

        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    fn apply_access_mode_indicator_from_config(&mut self) {
        use code_core::protocol::AskForApproval;
        use code_core::protocol::SandboxPolicy;
        let label = match (&self.config.sandbox_policy, self.config.approval_policy) {
            (SandboxPolicy::ReadOnly, _) => Some("Read Only".to_string()),
            (
                SandboxPolicy::WorkspaceWrite {
                    network_access: false,
                    ..
                },
                AskForApproval::UnlessTrusted,
            ) => Some("Write with Approval".to_string()),
            _ => None,
        };
        self.bottom_pane.set_access_mode_label(label);
    }

    /// Rotate the access preset: Read Only (Plan Mode) → Write with Approval → Full Access
    pub(crate) fn cycle_access_mode(&mut self) {
        use code_core::config::set_project_access_mode;
        use code_core::protocol::AskForApproval;
        use code_core::protocol::SandboxPolicy;

        // Determine current index
        let idx = match (&self.config.sandbox_policy, self.config.approval_policy) {
            (SandboxPolicy::ReadOnly, _) => 0,
            (
                SandboxPolicy::WorkspaceWrite {
                    network_access: false,
                    ..
                },
                AskForApproval::UnlessTrusted,
            ) => 1,
            (SandboxPolicy::DangerFullAccess, AskForApproval::Never) => 2,
            _ => 0,
        };
        let next = (idx + 1) % 3;

        // Apply mapping
        let (label, approval, sandbox) = match next {
            0 => (
                "Read Only (Plan Mode)",
                AskForApproval::OnRequest,
                SandboxPolicy::ReadOnly,
            ),
            1 => (
                "Write with Approval",
                AskForApproval::UnlessTrusted,
                SandboxPolicy::new_workspace_write_policy(),
            ),
            _ => (
                "Full Access",
                AskForApproval::Never,
                SandboxPolicy::DangerFullAccess,
            ),
        };

        // Update local config
        self.config.approval_policy = approval;
        self.config.sandbox_policy = sandbox;

        // Send ConfigureSession op to backend
        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_reasoning_effort: self.config.model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: self.config.model_text_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
        };
        self.submit_op(op);

        // Persist selection into CODEX_HOME/config.toml for this project directory so it sticks.
        let _ = set_project_access_mode(
            &self.config.code_home,
            &self.config.cwd,
            self.config.approval_policy,
            match &self.config.sandbox_policy {
                SandboxPolicy::ReadOnly => code_protocol::config_types::SandboxMode::ReadOnly,
                SandboxPolicy::WorkspaceWrite { .. } => {
                    code_protocol::config_types::SandboxMode::WorkspaceWrite
                }
                SandboxPolicy::DangerFullAccess => {
                    code_protocol::config_types::SandboxMode::DangerFullAccess
                }
            },
        );

        // Footer indicator: persistent for RO/Approval; ephemeral for Full Access
        if next == 2 {
            self.bottom_pane.set_access_mode_label_ephemeral(
                "Full Access".to_string(),
                std::time::Duration::from_secs(4),
            );
        } else {
            let persistent = if next == 0 {
                "Read Only"
            } else {
                "Write with Approval"
            };
            self.bottom_pane
                .set_access_mode_label(Some(persistent.to_string()));
        }

        // Announce in history: replace the last access-mode status, inserting early
        // in the current request so it appears above upcoming commands.
        let msg = format!("Mode changed: {}", label);
        self.set_access_status_message(msg);
        // No footer notice: the indicator covers this; avoid duplicate texts.

        // Prepare a single consolidated note for the agent to see before the
        // next turn begins. Subsequent cycles will overwrite this note.
        let agent_note = match next {
            0 => {
                "System: access mode changed to Read Only. Do not attempt write operations or apply_patch."
            }
            1 => {
                "System: access mode changed to Write with Approval. Request approval before writes."
            }
            _ => "System: access mode changed to Full Access. Writes and network are allowed.",
        };
        self.queue_agent_note(agent_note);
    }

    pub(crate) fn cycle_auto_drive_variant(&mut self) {
        self.auto_drive_variant = self.auto_drive_variant.next();
        self
            .bottom_pane
            .set_auto_drive_variant(self.auto_drive_variant);
        let notice = format!(
            "Auto Drive style: {}",
            self.auto_drive_variant.name()
        );
        self.bottom_pane.flash_footer_notice(notice);
    }

    /// Insert or replace the access-mode status background event. Uses a near-time
    /// key so it appears above any imminent Exec/Tool cells in this request.
    fn set_access_status_message(&mut self, message: String) {
        let cell = crate::history_cell::new_background_event(message);
        if let Some(idx) = self.access_status_idx {
            if idx < self.history_cells.len()
                && matches!(
                    self.history_cells[idx].kind(),
                    crate::history_cell::HistoryCellType::BackgroundEvent
                )
            {
                self.history_replace_at(idx, Box::new(cell));
                self.request_redraw();
                return;
            }
        }
        // Insert new status near the top of this request window
        let key = self.near_time_key(None);
        let pos = self.history_insert_with_key_global_tagged(Box::new(cell), key, "background", None);
        self.access_status_idx = Some(pos);
    }

    fn restyle_history_after_theme_change(&mut self) {
        let old = self.last_theme.clone();
        let new = crate::theme::current_theme();
        if old == new {
            return;
        }

        for cell in &mut self.history_cells {
            if let Some(plain) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::PlainHistoryCell>()
            {
                plain.invalidate_layout_cache();
            } else if let Some(tool) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::ToolCallCell>()
            {
                tool.retint(&old, &new);
            } else if let Some(reason) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::CollapsibleReasoningCell>()
            {
                reason.retint(&old, &new);
            } else if let Some(stream) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::StreamingContentCell>()
            {
                stream.update_context(self.config.file_opener, &self.config.cwd);
            } else if let Some(wait) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::WaitStatusCell>()
            {
                wait.retint(&old, &new);
            } else if let Some(assist) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::AssistantMarkdownCell>()
            {
                // Fully rebuild from raw to apply new theme + syntax highlight
                let current = assist.state().clone();
                assist.update_state(current, &self.config);
            } else if let Some(merged) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::MergedExecCell>()
            {
                merged.rebuild_with_theme();
            } else if let Some(diff) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::DiffCell>()
            {
                diff.rebuild_with_theme();
            }
        }

        // Update snapshot and redraw; height caching can remain (colors don't affect wrap)
        self.last_theme = new;
        self.render_theme_epoch = self.render_theme_epoch.saturating_add(1);
        self.history_render.invalidate_all();
        self.app_event_tx.send(AppEvent::RequestRedraw);
    }

    /// Public-facing hook for preview mode to retint existing history lines
    /// without persisting the theme or adding history events.
    pub(crate) fn retint_history_for_preview(&mut self) {
        self.restyle_history_after_theme_change();
    }

    fn save_theme_to_config(&self, new_theme: code_core::config_types::ThemeName) {
        // Persist the theme selection to CODE_HOME/CODEX_HOME config.toml
        match code_core::config::find_code_home() {
            Ok(home) => {
                if let Err(e) = code_core::config::set_tui_theme_name(&home, new_theme) {
                    tracing::warn!("Failed to persist theme to config.toml: {}", e);
                } else {
                    tracing::info!("Persisted TUI theme selection to config.toml");
                }
            }
            Err(e) => {
                tracing::warn!("Could not locate Codex home to persist theme: {}", e);
            }
        }
    }

    #[allow(dead_code)]
    pub(crate) fn on_esc(&mut self) -> bool {
        if self.bottom_pane.is_task_running() {
            self.interrupt_running_task();
            return true;
        }
        false
    }

    /// Handle Ctrl-C key press.
    /// Returns CancellationEvent::Handled if the event was consumed by the UI, or
    /// CancellationEvent::Ignored if the caller should handle it (e.g. exit).
    pub(crate) fn on_ctrl_c(&mut self) -> CancellationEvent {
        if let Some(id) = self.terminal_overlay_id() {
            if self.terminal_is_running() {
                self.request_terminal_cancel(id);
            } else {
                self.close_terminal_overlay();
            }
            return CancellationEvent::Handled;
        }
        match self.bottom_pane.on_ctrl_c() {
            CancellationEvent::Handled => return CancellationEvent::Handled,
            CancellationEvent::Ignored => {}
        }
        let exec_related_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty();
        if self.bottom_pane.is_task_running() || exec_related_running {
            self.interrupt_running_task();
            CancellationEvent::Ignored
        } else if self.bottom_pane.ctrl_c_quit_hint_visible() {
            self.submit_op(Op::Shutdown);
            CancellationEvent::Handled
        } else {
            self.bottom_pane.show_ctrl_c_quit_hint();
            CancellationEvent::Ignored
        }
    }

    #[allow(dead_code)]
    pub(crate) fn composer_is_empty(&self) -> bool {
        self.bottom_pane.composer_is_empty()
    }

    // --- Double‑Escape helpers ---
    pub(crate) fn double_esc_hint_label() -> &'static str {
        DOUBLE_ESC_HINT
    }

    pub(crate) fn show_esc_undo_hint(&mut self) {
        self.bottom_pane
            .flash_footer_notice(format!("Esc {}", Self::double_esc_hint_label()));
    }

    fn show_auto_drive_exit_hint(&mut self) {
        self.bottom_pane
            .set_standard_terminal_hint(Some(AUTO_ESC_EXIT_HINT.to_string()));
    }

    fn auto_stop_via_escape(&mut self, message: Option<String>) {
        self.auto_stop(message);
        self.bottom_pane
            .update_status_text("Auto Drive stopped.".to_string());
        if self.auto_state.last_run_summary.is_some() {
            self.auto_clear_summary_panel();
        } else {
            self.bottom_pane.set_standard_terminal_hint(None);
            self.bottom_pane.ensure_input_focus();
            self.request_redraw();
        }
    }

    fn auto_clear_summary_panel(&mut self) {
        if self.auto_state.last_run_summary.is_none() {
            self.bottom_pane.set_standard_terminal_hint(None);
            self.bottom_pane.ensure_input_focus();
            self.request_redraw();
            return;
        }
        self.auto_state.last_run_summary = None;
        self.bottom_pane.clear_auto_coordinator_view(true);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_standard_terminal_hint(None);
        self.bottom_pane.ensure_input_focus();
        self.auto_rebuild_live_ring();
        self.request_redraw();
    }

    pub(crate) fn auto_manual_entry_active(&self) -> bool {
        self.auto_state.should_show_goal_entry()
            || (self.auto_state.is_active() && self.auto_state.awaiting_coordinator_submit())
    }

    pub(crate) fn describe_esc_context(&self) -> EscRoute {
        if self.diffs.confirm.is_some() {
            return EscRoute::new(EscIntent::DiffConfirm, true, false);
        }

        if self.settings.overlay.is_some() {
            return EscRoute::new(EscIntent::CloseSettings, true, false);
        }

        if self.has_active_modal_view() {
            return EscRoute::new(EscIntent::DismissModal, true, false);
        }

        if self.agents_terminal.active {
            return EscRoute::new(EscIntent::AgentsTerminal, true, false);
        }

        if self.bottom_pane.file_popup_visible() {
            return EscRoute::new(EscIntent::CloseFilePopup, false, false);
        }

        if self.auto_state.is_active() {
            let continue_mode = self.auto_state.continue_mode;
            let awaiting_continue_cta = self.auto_state.awaiting_coordinator_submit()
                && !self.auto_state.is_paused_manual()
                && continue_mode != AutoContinueMode::Manual;

            if awaiting_continue_cta {
                return EscRoute::new(EscIntent::AutoStopDuringApproval, true, false);
            }

            if self.auto_state.countdown_active()
                || (self.auto_state.awaiting_coordinator_submit()
                    && !self.auto_state.is_paused_manual())
            {
                return EscRoute::new(EscIntent::AutoPauseForEdit, true, false);
            }

            if self.has_cancelable_agents() {
                return EscRoute::new(EscIntent::CancelAgents, true, false);
            }

            if self.has_running_commands_or_tools() {
                return EscRoute::new(EscIntent::CancelTask, true, false);
            }

            if self.auto_state.awaiting_coordinator_submit() {
                return EscRoute::new(EscIntent::AutoStopDuringApproval, true, false);
            }

            return EscRoute::new(EscIntent::AutoStopActive, true, false);
        }

        if self.auto_state.should_show_goal_entry() {
            return EscRoute::new(
                match self.auto_goal_escape_state {
                    AutoGoalEscState::Inactive => EscIntent::AutoGoalExitPreserveDraft,
                    AutoGoalEscState::NeedsEnableEditing => EscIntent::AutoGoalEnableEdit,
                    AutoGoalEscState::ArmedForExit => EscIntent::AutoGoalExitPreserveDraft,
                },
                true,
                false,
            );
        }

        if self.has_cancelable_agents() {
            return EscRoute::new(EscIntent::CancelAgents, true, false);
        }

        if self.auto_state.last_run_summary.is_some() {
            return EscRoute::new(EscIntent::AutoDismissSummary, true, false);
        }

        if self.auto_manual_entry_active() && !self.composer_is_empty() {
            return EscRoute::new(EscIntent::ClearComposer, true, false);
        }

        if self.is_task_running() {
            return EscRoute::new(EscIntent::CancelTask, true, false);
        }

        if !self.composer_is_empty() {
            return EscRoute::new(EscIntent::ClearComposer, true, false);
        }

        EscRoute::new(EscIntent::ShowUndoHint, true, true)
    }

    pub(crate) fn execute_esc_intent(&mut self, intent: EscIntent, key_event: KeyEvent) -> bool {
        match intent {
            EscIntent::DismissModal => {
                self.handle_key_event(key_event);
                true
            }
            EscIntent::CloseSettings => {
                self.handle_key_event(key_event);
                true
            }
            EscIntent::CloseFilePopup => self.close_file_popup_if_active(),
            EscIntent::AutoPauseForEdit => {
                self.auto_pause_for_manual_edit(false);
                true
            }
            EscIntent::AutoStopDuringApproval => {
                self.bottom_pane
                    .update_status_text("Auto Drive stopped during approval.".to_string());
                self.auto_stop_via_escape(Some("Auto Drive stopped during approval.".to_string()));
                true
            }
            EscIntent::AutoStopActive => {
                self.bottom_pane
                    .update_status_text("Stopping Auto Drive…".to_string());
                self.auto_stop_via_escape(Some("Auto Drive stopped by user.".to_string()));
                true
            }
            EscIntent::AutoGoalEnableEdit => {
                self.auto_goal_escape_state = AutoGoalEscState::ArmedForExit;
                self.bottom_pane.ensure_input_focus();
                self.request_redraw();
                true
            }
            EscIntent::AutoGoalExitPreserveDraft => self.auto_exit_goal_entry_preserve_draft(),
            EscIntent::AutoDismissSummary => {
                self.auto_clear_summary_panel();
                true
            }
            EscIntent::DiffConfirm => {
                self.diffs.confirm = None;
                self.request_redraw();
                true
            }
            EscIntent::AgentsTerminal => {
                self.handle_key_event(key_event);
                true
            }
            EscIntent::CancelAgents => self.cancel_active_agents(),
            EscIntent::CancelTask => {
                let had_running = self.is_task_running();
                let auto_was_active = self.auto_state.is_active();
                let _ = self.on_ctrl_c();
                if had_running {
                    if auto_was_active {
                        self.bottom_pane
                            .update_status_text("Command cancelled. Esc stops Auto Drive.".to_string());
                        self.auto_stop_via_escape(Some("Auto Drive stopped by user.".to_string()));
                    } else {
                        self.bottom_pane
                            .update_status_text("Command cancelled.".to_string());
                    }
                }
                true
            }
            EscIntent::ClearComposer => {
                self.clear_composer();
                true
            }
            EscIntent::ShowUndoHint => {
                self.show_esc_undo_hint();
                true
            }
            EscIntent::OpenUndoTimeline => {
                self.handle_undo_command();
                true
            }
            EscIntent::None => false,
        }
    }

    fn has_running_commands_or_tools(&self) -> bool {
        self.terminal_is_running()
            || !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty()
    }

    pub(crate) fn is_task_running(&self) -> bool {
        self.bottom_pane.is_task_running()
            || self.terminal_is_running()
            || !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty()
    }

    /// Clear the composer text and any pending paste placeholders/history cursors.
    pub(crate) fn clear_composer(&mut self) {
        self.bottom_pane.clear_composer();
        if self.auto_state.should_show_goal_entry() {
            self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        }
        // Mark a height change so layout adjusts immediately if the composer shrinks.
        self.height_manager
            .borrow_mut()
            .record_event(crate::height_manager::HeightEvent::ComposerModeChange);
        self.request_redraw();
    }

    fn auto_sync_goal_escape_state_from_composer(&mut self) {
        if !self.auto_state.should_show_goal_entry() {
            return;
        }

        let has_content = !self.bottom_pane.composer_text().trim().is_empty();
        match self.auto_goal_escape_state {
            AutoGoalEscState::Inactive => {
                if has_content {
                    self.auto_goal_escape_state = AutoGoalEscState::NeedsEnableEditing;
                }
            }
            AutoGoalEscState::NeedsEnableEditing | AutoGoalEscState::ArmedForExit => {
                if !has_content {
                    self.auto_goal_escape_state = AutoGoalEscState::Inactive;
                }
            }
        }
    }

    pub(crate) fn close_file_popup_if_active(&mut self) -> bool {
        self.bottom_pane.close_file_popup_if_active()
    }

    pub(crate) fn has_active_modal_view(&self) -> bool {
        // Treat bottom‑pane views (approval, selection popups) and top‑level overlays
        // (diff viewer, help overlay) as "modals" for Esc routing. This ensures that
        // a single Esc keypress closes the visible overlay instead of engaging the
        // global Esc policy (clear input / backtrack).
        self.bottom_pane.has_active_modal_view()
            || self.settings.overlay.is_some()
            || self.diffs.overlay.is_some()
            || self.help.overlay.is_some()
            || self.terminal.overlay.is_some()
    }

    /// Forward an `Op` directly to codex.
    pub(crate) fn submit_op(&self, op: Op) {
        if let Err(e) = self.code_op_tx.send(op) {
            tracing::error!("failed to submit op: {e}");
        }
    }

    /// Cancel the current running task from a non-keyboard context (e.g. approval modal).
    /// This bypasses modal key handling and invokes the same immediate UI cleanup path
    /// as pressing Ctrl-C/Esc while a task is running.
    pub(crate) fn cancel_running_task_from_approval(&mut self) {
        self.interrupt_running_task();
    }

    pub(crate) fn register_approved_command(
        &self,
        command: Vec<String>,
        match_kind: ApprovedCommandMatchKind,
        semantic_prefix: Option<Vec<String>>,
    ) {
        if command.is_empty() {
            return;
        }
        let op = Op::RegisterApprovedCommand {
            command,
            match_kind,
            semantic_prefix,
        };
        self.submit_op(op);
    }

    /// Clear transient spinner/status after a denial without interrupting core
    /// execution. Only hide the spinner when there is no remaining activity so
    /// we avoid masking in-flight work (e.g. follow-up reasoning).
    pub(crate) fn mark_task_idle_after_denied(&mut self) {
        let any_tools_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty();
        let any_streaming = self.stream.is_write_cycle_active();
        let any_agents_active = self.agents_are_actively_running();
        let any_tasks_active = !self.active_task_ids.is_empty();

        if !(any_tools_running || any_streaming || any_agents_active || any_tasks_active) {
            self.bottom_pane.set_task_running(false);
            self.bottom_pane.update_status_text(String::new());
            self.bottom_pane.clear_ctrl_c_quit_hint();
            self.mark_needs_redraw();
        }
    }

    pub(crate) fn insert_history_lines(&mut self, lines: Vec<ratatui::text::Line<'static>>) {
        let kind = self.stream_state.current_kind.unwrap_or(StreamKind::Answer);
        self.insert_history_lines_with_kind(kind, None, lines);
    }

    pub(crate) fn insert_history_lines_with_kind(
        &mut self,
        kind: StreamKind,
        id: Option<String>,
        lines: Vec<ratatui::text::Line<'static>>,
    ) {
        // No debug logging: we rely on preserving span modifiers end-to-end.
        // Insert all lines as a single streaming content cell to preserve spacing
        if lines.is_empty() {
            return;
        }

        if let Some(first_line) = lines.first() {
            let first_line_text: String = first_line
                .spans
                .iter()
                .map(|s| s.content.to_string())
                .collect();
            tracing::debug!("First line content: {:?}", first_line_text);
        }

        match kind {
            StreamKind::Reasoning => {
                // This reasoning block is the bottom-most; show progress indicator here only
                self.clear_reasoning_in_progress();
                // Ensure footer shows Ctrl+R hint when reasoning content is present
                self.bottom_pane.set_reasoning_hint(true);
                // Update footer label to reflect current visibility state
                self.bottom_pane
                    .set_reasoning_state(self.is_reasoning_shown());
                // Route by id when provided to avoid splitting reasoning across cells.
                // Be defensive: the cached index may be stale after inserts/removals; validate it.
                if let Some(ref rid) = id {
                    if let Some(&idx) = self.reasoning_index.get(rid) {
                        if idx < self.history_cells.len() {
                            if let Some(reasoning_cell) = self.history_cells[idx]
                                .as_any_mut()
                                .downcast_mut::<history_cell::CollapsibleReasoningCell>(
                            ) {
                                tracing::debug!(
                                    "Appending {} lines to Reasoning(id={})",
                                    lines.len(),
                                    rid
                                );
                                reasoning_cell.append_lines_dedup(lines);
                                reasoning_cell.set_in_progress(true);
                                self.invalidate_height_cache();
                                self.autoscroll_if_near_bottom();
                                self.request_redraw();
                                self.refresh_reasoning_collapsed_visibility();
                                return;
                            }
                        }
                        // Cached index was stale or wrong type — try to locate by scanning.
                        if let Some(found_idx) = self.history_cells.iter().rposition(|c| {
                            c.as_any()
                                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                                .map(|rc| rc.matches_id(rid))
                                .unwrap_or(false)
                        }) {
                            if let Some(reasoning_cell) = self.history_cells[found_idx]
                                .as_any_mut()
                                .downcast_mut::<history_cell::CollapsibleReasoningCell>()
                            {
                                // Refresh the cache with the corrected index
                                self.reasoning_index.insert(rid.clone(), found_idx);
                                tracing::debug!(
                                    "Recovered stale reasoning index; appending at {} for id={}",
                                    found_idx,
                                    rid
                                );
                                reasoning_cell.append_lines_dedup(lines);
                                reasoning_cell.set_in_progress(true);
                                self.invalidate_height_cache();
                                self.autoscroll_if_near_bottom();
                                self.request_redraw();
                                self.refresh_reasoning_collapsed_visibility();
                                return;
                            }
                        } else {
                            // No matching cell remains; drop the stale cache entry.
                            self.reasoning_index.remove(rid);
                        }
                    }
                }

                tracing::debug!("Creating new CollapsibleReasoningCell id={:?}", id);
                let cell = history_cell::CollapsibleReasoningCell::new_with_id(lines, id.clone());
                if self.config.tui.show_reasoning {
                    cell.set_collapsed(false);
                } else {
                    cell.set_collapsed(true);
                }
                cell.set_in_progress(true);

                // Use pre-seeded key for this stream id when present; otherwise synthesize.
                let key = match id.as_deref() {
                    Some(rid) => self.try_stream_order_key(kind, rid).unwrap_or_else(|| {
                        tracing::warn!(
                            "missing stream order key for Reasoning id={}; using synthetic key",
                            rid
                        );
                        self.next_internal_key()
                    }),
                    None => {
                        tracing::warn!("missing stream id for Reasoning; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tracing::info!(
                    "[order] insert Reasoning new id={:?} {}",
                    id,
                    Self::debug_fmt_order_key(key)
                );
                let idx = self.history_insert_with_key_global(Box::new(cell), key);
                if let Some(rid) = id {
                    self.reasoning_index.insert(rid, idx);
                }
                // Auto Drive status updates are handled via coordinator decisions.
            }
            StreamKind::Answer => {
                tracing::debug!(
                    "history.insert Answer id={:?} incoming_lines={}",
                    id,
                    lines.len()
                );
                self.clear_reasoning_in_progress();

                let explicit_id = id.clone();
                let stream_identifier = explicit_id.clone().unwrap_or_else(|| {
                    self.stream
                        .current_stream_id()
                        .map(|s| s.to_string())
                        .unwrap_or_else(|| "stream-preview".to_string())
                });

                let fallback_preview = self
                    .synthesize_stream_state_from_lines(Some(&stream_identifier), &lines, true)
                    .preview_markdown;
                let preview_markdown = self
                    .stream
                    .preview_source_for_kind(StreamKind::Answer)
                    .unwrap_or(fallback_preview);

                let mutation = self.history_state.apply_domain_event(
                    HistoryDomainEvent::UpsertAssistantStream {
                        stream_id: stream_identifier.clone(),
                        preview_markdown,
                        delta: None,
                        metadata: None,
                    },
                );

                match mutation {
                    HistoryMutation::Inserted { id: history_id, record, .. } => {
                        let insert_key = match explicit_id.as_deref() {
                            Some(rid) => self.try_stream_order_key(kind, rid).unwrap_or_else(|| {
                                tracing::warn!(
                                    "missing stream order key for Answer id={}; using synthetic key",
                                    rid
                                );
                                self.next_internal_key()
                            }),
                            None => {
                                tracing::warn!(
                                    "missing stream id for Answer; using synthetic key"
                                );
                                self.next_internal_key()
                            }
                        };

                        let mut cell = self
                            .build_cell_from_record(&record)
                            .expect("assistant stream record should build cell");
                        self.assign_history_id(&mut cell, history_id);
                        let new_idx = self.history_insert_existing_record(
                            cell,
                            insert_key,
                            "stream-begin",
                            history_id,
                        );
                        tracing::debug!(
                            "history.new StreamingContentCell at idx={} id={:?}",
                            new_idx,
                            explicit_id
                        );
                    }
                    HistoryMutation::Replaced { id: history_id, record, .. } => {
                        self.update_cell_from_record(history_id, record);
                        self.mark_history_dirty();
                    }
                    HistoryMutation::Noop => {}
                    other => tracing::debug!(
                        "unexpected streaming mutation {:?} for id={:?}",
                        other,
                        explicit_id
                    ),
                }
            }
        }

        // Auto-follow if near bottom so new inserts are visible
        self.autoscroll_if_near_bottom();
        self.request_redraw();
        self.flush_history_snapshot_if_needed(false);
    }

    fn synthesize_stream_state_from_lines(
        &self,
        stream_id: Option<&String>,
        lines: &[ratatui::text::Line<'static>],
        in_progress: bool,
    ) -> AssistantStreamState {
        let mut preview = String::new();
        for (idx, line) in lines.iter().enumerate() {
            let flat: String = line
                .spans
                .iter()
                .map(|s| s.content.as_ref())
                .collect();
            if idx == 0 && flat.trim().eq_ignore_ascii_case("codex") {
                continue;
            }
            if !preview.is_empty() {
                preview.push('\n');
            }
            preview.push_str(&flat);
        }
        if !preview.is_empty() && !preview.ends_with('\n') {
            preview.push('\n');
        }
        let mut stream_id_string = stream_id
            .cloned()
            .unwrap_or_else(|| "stream-preview".to_string());
        if stream_id_string.is_empty() {
            stream_id_string = "stream-preview".to_string();
        }
        AssistantStreamState {
            id: HistoryId::ZERO,
            stream_id: stream_id_string,
            preview_markdown: preview,
            deltas: Vec::new(),
            citations: Vec::new(),
            metadata: None,
            in_progress,
            last_updated_at: SystemTime::now(),
            truncated_prefix_bytes: 0,
        }
    }

    fn refresh_streaming_cell_for_stream_id(
        &mut self,
        stream_id: &str,
        state: AssistantStreamState,
    ) {
        if state.id != HistoryId::ZERO {
            self.update_cell_from_record(
                state.id,
                HistoryRecord::AssistantStream(state.clone()),
            );
            self.autoscroll_if_near_bottom();
            return;
        }

        if let Some(existing) = self
            .history_state
            .assistant_stream_state(stream_id)
            .cloned()
        {
            if existing.id != HistoryId::ZERO {
                self.update_cell_from_record(
                    existing.id,
                    HistoryRecord::AssistantStream(existing),
                );
                self.autoscroll_if_near_bottom();
            }
        }
    }

    fn update_stream_token_usage_metadata(&mut self) {
        let Some(stream_id) = self.stream.current_stream_id().cloned() else {
            return;
        };
        let Some(preview) = self
            .stream
            .preview_source_for_kind(StreamKind::Answer)
        else {
            return;
        };
        let metadata = MessageMetadata {
            citations: Vec::new(),
            token_usage: Some(self.last_token_usage.clone()),
        };
        self
            .history_state
            .upsert_assistant_stream_state(&stream_id, preview, None, Some(&metadata));
        if let Some(state) = self
            .history_state
            .assistant_stream_state(&stream_id)
            .cloned()
        {
            self.refresh_streaming_cell_for_stream_id(&stream_id, state);
        }
    }

    fn track_answer_stream_delta(&mut self, stream_id: &str, delta: &str, seq: Option<u64>) {
        let preview = self
            .stream
            .preview_source_for_kind(StreamKind::Answer)
            .unwrap_or_default();
        let delta = if delta.is_empty() {
            None
        } else {
            Some(AssistantStreamDelta {
                delta: delta.to_string(),
                sequence: seq,
                received_at: SystemTime::now(),
            })
        };
        let mutation = self.history_state.apply_domain_event(
            HistoryDomainEvent::UpsertAssistantStream {
                stream_id: stream_id.to_string(),
                preview_markdown: preview,
                delta,
                metadata: None,
            },
        );

        match mutation {
            HistoryMutation::Inserted { record, .. } => {
                if let HistoryRecord::AssistantStream(state) = record {
                    self.refresh_streaming_cell_for_stream_id(stream_id, state);
                    self.mark_history_dirty();
                }
            }
            HistoryMutation::Replaced { id, record, .. } => {
                if matches!(record, HistoryRecord::AssistantStream(_)) {
                    self.update_cell_from_record(id, record);
                    self.mark_history_dirty();
                }
            }
            _ => {}
        }
    }

    fn finalize_answer_stream_state(
        &mut self,
        stream_id: Option<&str>,
        source: &str,
    ) -> AssistantMessageState {
        let mut metadata = stream_id.and_then(|sid| {
            self.history_state
                .assistant_stream_state(sid)
                .and_then(|state| state.metadata.clone())
        });

        let should_attach_token_usage = self.last_token_usage.total_tokens > 0;
        if should_attach_token_usage {
            if let Some(meta) = metadata.as_mut() {
                if meta.token_usage.is_none() {
                    meta.token_usage = Some(self.last_token_usage.clone());
                }
            } else {
                metadata = Some(MessageMetadata {
                    citations: Vec::new(),
                    token_usage: Some(self.last_token_usage.clone()),
                });
            }
        }

        let token_usage = if should_attach_token_usage {
            Some(self.last_token_usage.clone())
        } else {
            None
        };

        let state = self.history_state.finalize_assistant_stream_state(
            stream_id,
            source.to_string(),
            metadata.as_ref(),
            token_usage.as_ref(),
        );
        state
    }

    /// Replace the in-progress streaming assistant cell with a final markdown cell that
    /// stores raw markdown for future re-rendering.
    pub(crate) fn insert_final_answer_with_id(
        &mut self,
        id: Option<String>,
        lines: Vec<ratatui::text::Line<'static>>,
        source: String,
    ) {
        tracing::debug!(
            "insert_final_answer_with_id id={:?} source_len={} lines={}",
            id,
            source.len(),
            lines.len()
        );
        tracing::info!("[order] final Answer id={:?}", id);
        let final_source = source.clone();

        if self.auto_state.pending_stop_message.is_some() {
            match serde_json::from_str::<code_auto_drive_diagnostics::CompletionCheck>(&final_source)
            {
                Ok(check) => {
                    if check.complete {
                        let pending = self.auto_state.pending_stop_message.take();
                        if let Some(idx) = self.history_cells.iter().rposition(|c| {
                            c.as_any()
                                .downcast_ref::<history_cell::StreamingContentCell>()
                                .and_then(|sc| sc.id.as_ref())
                                .map(|existing| Some(existing.as_str()) == id.as_deref())
                                .unwrap_or(false)
                        }) {
                            self.history_remove_at(idx);
                        }
                        if let Some(ref stream_id) = id {
                            let _ = self.history_state.finalize_assistant_stream_state(
                                Some(stream_id.as_str()),
                                String::new(),
                                None,
                                None,
                            );
                            self.stream_state
                                .closed_answer_ids
                                .insert(StreamId(stream_id.clone()));
                        }
                        self.auto_stop(pending);
                        return;
                    } else {
                        let goal = self
                            .auto_state
                            .goal
                            .as_deref()
                            .unwrap_or("(goal unavailable)");
                    let follow_up = format!(
                        "The primary goal has not been met. Please continue working on this.\nPrimary Goal: {goal}\nExplanation: {explanation}",
                        explanation = check.explanation
                    );
                    let conversation = self.rebuild_auto_history();
                    self.auto_state.pending_stop_message = None;
                    let dispatched = self.auto_send_user_prompt_to_coordinator(follow_up, conversation);
                    self.auto_state.pending_stop_message = None;
                    if !dispatched {
                        self.auto_stop(Some(
                            "Coordinator stopped unexpectedly while scheduling diagnostics follow-up.".to_string(),
                        ));
                    }
                    return;
                }
                }
                Err(err) => {
                    tracing::warn!(
                        "failed to parse diagnostics completion check: {}",
                        err
                    );
                    let pending = self.auto_state.pending_stop_message.take();
                    self.auto_stop(pending);
                }
            }
        }
        if self.is_review_flow_active() {
            if let Some(ref want) = id {
                if !self
                    .stream_state
                    .closed_answer_ids
                    .insert(StreamId(want.clone()))
                {
                    tracing::debug!(
                        "InsertFinalAnswer(review): dropping duplicate final for id={}",
                        want
                    );
                    self.last_assistant_message = Some(final_source.clone());
                    return;
                }
                if let Some(idx) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::StreamingContentCell>()
                        .and_then(|sc| sc.id.as_ref())
                        .map(|existing| existing == want)
                        .unwrap_or(false)
                }) {
                    self.history_remove_at(idx);
                }
            } else if let Some(idx) = self.history_cells.iter().rposition(|c| {
                c.as_any()
                    .downcast_ref::<history_cell::StreamingContentCell>()
                    .is_some()
            }) {
                self.history_remove_at(idx);
            }
            self.last_assistant_message = Some(final_source.clone());
            let state = self.finalize_answer_stream_state(id.as_deref(), &final_source);
            let history_id = state.id;
            let mut key = match id.as_deref() {
                Some(rid) => self.try_stream_order_key(StreamKind::Answer, rid).unwrap_or_else(|| {
                    tracing::warn!(
                        "missing stream order key for final Answer id={}; using synthetic key",
                        rid
                    );
                    self.next_internal_key()
                }),
                None => {
                    tracing::warn!("missing stream id for final Answer; using synthetic key");
                    self.next_internal_key()
                }
            };

            if let Some(last) = self.last_assigned_order {
                if key <= last {
                    key = Self::order_key_successor(last);
                    if let Some(ref want) = id {
                        self.stream_order_seq
                            .insert((StreamKind::Answer, want.clone()), key);
                    }
                }
            }

            let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
            self.history_insert_existing_record(Box::new(cell), key, "answer-review", history_id);
            // Advance Auto Drive after the assistant message has been finalized.
            self.auto_on_assistant_final();
            return;
        }
        // Debug: list last few history cell kinds so we can see what's present
        let tail_kinds: String = self
            .history_cells
            .iter()
            .rev()
            .take(5)
            .map(|c| {
                if c.as_any()
                    .downcast_ref::<history_cell::StreamingContentCell>()
                    .is_some()
                {
                    "Streaming".to_string()
                } else if c
                    .as_any()
                    .downcast_ref::<history_cell::AssistantMarkdownCell>()
                    .is_some()
                {
                    "AssistantFinal".to_string()
                } else if c
                    .as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    .is_some()
                {
                    "Reasoning".to_string()
                } else {
                    format!("{:?}", c.kind())
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        tracing::debug!("history.tail kinds(last5) = [{}]", tail_kinds);

        // When we have an id but could not find a streaming cell by id, dump ids
        if id.is_some() {
            let ids: Vec<String> = self
                .history_cells
                .iter()
                .enumerate()
                .filter_map(|(i, c)| {
                    c.as_any()
                        .downcast_ref::<history_cell::StreamingContentCell>()
                        .and_then(|sc| sc.id.as_ref().map(|s| format!("{}:{}", i, s)))
                })
                .collect();
            tracing::debug!("history.streaming ids={}", ids.join(" | "));
        }
        // If we already finalized this id in the current turn with identical content,
        // drop this event to avoid duplicates (belt-and-suspenders against upstream repeats).
        if let Some(ref want) = id {
            if self
                .stream_state
                .closed_answer_ids
                .contains(&StreamId(want.clone()))
            {
                if let Some(existing_idx) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::AssistantMarkdownCell>()
                        .map(|amc| amc.stream_id() == Some(want.as_str()))
                        .unwrap_or(false)
                }) {
                    if let Some(amc) = self.history_cells[existing_idx]
                        .as_any()
                        .downcast_ref::<history_cell::AssistantMarkdownCell>()
                    {
                        let prev = Self::normalize_text(amc.markdown());
                        let newn = Self::normalize_text(&source);
                        if prev == newn {
                            tracing::debug!(
                                "InsertFinalAnswer: dropping duplicate final for id={}",
                                want
                            );
                            return;
                        }
                    }
                }
            }
        }
        // Ensure a hidden 'codex' header is present
        let has_header = lines
            .first()
            .map(|l| {
                l.spans
                    .iter()
                    .map(|s| s.content.as_ref())
                    .collect::<String>()
                    .trim()
                    .eq_ignore_ascii_case("codex")
            })
            .unwrap_or(false);
        if !has_header {
            // No need to mutate `lines` further since we rebuild from `source` below.
        }

        // Replace the matching StreamingContentCell if one exists for this id; else fallback to most recent.
        // NOTE (dup‑guard): This relies on `StreamingContentCell::as_any()` returning `self`.
        // If that impl is removed, downcast_ref will fail and we won't find the streaming cell,
        // causing the final to append a new Assistant cell (duplicate).
        let streaming_idx = if let Some(ref want) = id {
            // Only replace a streaming cell if its id matches this final.
            self.history_cells.iter().rposition(|c| {
                if let Some(sc) = c
                    .as_any()
                    .downcast_ref::<history_cell::StreamingContentCell>()
                {
                    sc.id.as_ref() == Some(want)
                } else {
                    false
                }
            })
        } else {
            None
        };
        if let Some(idx) = streaming_idx {
            tracing::debug!(
                "final-answer: replacing StreamingContentCell at idx={} by id match",
                idx
            );
            let state = self.finalize_answer_stream_state(id.as_deref(), &final_source);
            let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
            self.history_replace_at(idx, Box::new(cell));
            if let Some(ref want) = id {
                self.stream_state
                    .closed_answer_ids
                    .insert(StreamId(want.clone()));
            }
            self.autoscroll_if_near_bottom();
            // Final cell committed via replacement; now advance Auto Drive.
            self.auto_on_assistant_final();
            return;
        }

        // No streaming cell found. First, try to replace a finalized assistant cell
        // that was created for the same stream id (e.g., we already finalized due to
        // a lifecycle event and this InsertFinalAnswer arrived slightly later).
        if let Some(ref want) = id {
            if let Some(idx) = self.history_cells.iter().rposition(|c| {
                if let Some(amc) = c
                    .as_any()
                    .downcast_ref::<history_cell::AssistantMarkdownCell>()
                {
                    amc.stream_id() == Some(want.as_str())
                } else {
                    false
                }
            }) {
                tracing::debug!(
                    "final-answer: replacing existing AssistantMarkdownCell at idx={} by id match",
                    idx
                );
                let state =
                    self.finalize_answer_stream_state(id.as_deref(), &final_source);
                let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
                self.history_replace_at(idx, Box::new(cell));
                self.stream_state
                    .closed_answer_ids
                    .insert(StreamId(want.clone()));
                self.autoscroll_if_near_bottom();
                // Final cell replaced in-place; advance Auto Drive now.
                self.auto_on_assistant_final();
                return;
            }
        }

        // Otherwise, if a finalized assistant cell exists at the tail,
        // replace it in place to avoid duplicate assistant messages when a second
        // InsertFinalAnswer (e.g., from an AgentMessage event) arrives after we already
        // finalized due to a side event.
        if let Some(idx) = self.history_cells.iter().rposition(|c| {
            c.as_any()
                .downcast_ref::<history_cell::AssistantMarkdownCell>()
                .is_some()
        }) {
            // Replace the tail finalized assistant cell if the new content is identical OR
            // a small revision that merely adds leading/trailing context. Otherwise append a
            // new assistant message so distinct replies remain separate.
            let should_replace = self.history_cells[idx]
                .as_any()
                .downcast_ref::<history_cell::AssistantMarkdownCell>()
                .map(|amc| {
                    let prev = Self::normalize_text(amc.markdown());
                    let newn = Self::normalize_text(&source);
                    let identical = prev == newn;
                    if identical || prev.is_empty() {
                        return identical;
                    }
                    let is_prefix_expansion = newn.starts_with(&prev);
                    let is_suffix_expansion = newn.ends_with(&prev);
                    let is_large_superset = prev.len() >= 80 && newn.contains(&prev);
                    identical || is_prefix_expansion || is_suffix_expansion || is_large_superset
                })
                .unwrap_or(false);
            if should_replace {
                tracing::debug!(
                    "final-answer: replacing tail AssistantMarkdownCell via heuristic identical/expansion"
                );
                let state =
                    self.finalize_answer_stream_state(id.as_deref(), &final_source);
                let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
                self.history_replace_at(idx, Box::new(cell));
                self.autoscroll_if_near_bottom();
                // Final assistant content revised; advance Auto Drive now.
                self.auto_on_assistant_final();
                return;
            }
        }

        // Fallback: no prior assistant cell found; insert at stable sequence position.
        tracing::debug!(
            "final-answer: ordered insert new AssistantMarkdownCell id={:?}",
            id
        );
        let mut key = match id.as_deref() {
            Some(rid) => self
                .try_stream_order_key(StreamKind::Answer, rid)
                .unwrap_or_else(|| {
                    tracing::warn!(
                        "missing stream order key for final Answer id={}; using synthetic key",
                        rid
                    );
                    self.next_internal_key()
                }),
            None => {
                tracing::warn!("missing stream id for final Answer; using synthetic key");
                self.next_internal_key()
            }
        };
        if let Some(last) = self.last_assigned_order {
            if key <= last {
                // Background notices anchor themselves at out = i32::MAX. If a final answer arrives
                // after those notices we still want it to appear at the bottom, so bump the key
                // just past the most-recently assigned slot.
                key = Self::order_key_successor(last);
                if let Some(ref want) = id {
                    self.stream_order_seq
                        .insert((StreamKind::Answer, want.clone()), key);
                }
            }
        }
        tracing::info!(
            "[order] final Answer ordered insert id={:?} {}",
            id,
            Self::debug_fmt_order_key(key)
        );
        let state = self.finalize_answer_stream_state(id.as_deref(), &final_source);
        let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
        let _ = self.history_insert_with_key_global(Box::new(cell), key);
        if let Some(ref want) = id {
            self.stream_state
                .closed_answer_ids
                .insert(StreamId(want.clone()));
        }
        // Ordered insert completed; advance Auto Drive now that the assistant
        // message is present in history.
        self.auto_on_assistant_final();
    }

    // Assign or fetch a stable sequence for a stream kind+id within its originating turn
    // removed legacy ensure_stream_order_key; strict variant is used instead

    /// Normalize text for duplicate detection (trim trailing whitespace and normalize newlines)
    fn normalize_text(s: &str) -> String {
        // 1) Normalize newlines
        let s = s.replace("\r\n", "\n");
        // 2) Trim trailing whitespace per line; collapse repeated blank lines
        let mut out: Vec<String> = Vec::new();
        let mut saw_blank = false;
        for line in s.lines() {
            // Replace common Unicode bullets with ASCII to stabilize equality checks
            let line = line
                .replace('\u{2022}', "-") // •
                .replace('\u{25E6}', "-") // ◦
                .replace('\u{2219}', "-"); // ∙
            let trimmed = line.trim_end();
            if trimmed.chars().all(|c| c.is_whitespace()) {
                if !saw_blank {
                    out.push(String::new());
                }
                saw_blank = true;
            } else {
                out.push(trimmed.to_string());
                saw_blank = false;
            }
        }
        // 3) Remove trailing blank lines
        while out.last().is_some_and(|l| l.is_empty()) {
            out.pop();
        }
        out.join("\n")
    }

    pub(crate) fn toggle_reasoning_visibility(&mut self) {
        // Track whether any reasoning cells are found and their new state
        let mut has_reasoning_cells = false;
        let mut new_collapsed_state = false;

        // Toggle all CollapsibleReasoningCell instances in history
        for cell in &self.history_cells {
            // Try to downcast to CollapsibleReasoningCell
            if let Some(reasoning_cell) = cell
                .as_any()
                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            {
                reasoning_cell.toggle_collapsed();
                has_reasoning_cells = true;
                new_collapsed_state = reasoning_cell.is_collapsed();
            }
        }

        // Update the config to reflect the current state (inverted because collapsed means hidden)
        if has_reasoning_cells {
            self.config.tui.show_reasoning = !new_collapsed_state;
            // Brief status to confirm the toggle to the user
            let status = if self.config.tui.show_reasoning {
                "Reasoning shown"
            } else {
                "Reasoning hidden"
            };
            self.bottom_pane.update_status_text(status.to_string());
            // Update footer label to reflect current state
            self.bottom_pane
                .set_reasoning_state(self.config.tui.show_reasoning);
        } else {
            // No reasoning cells exist; inform the user
            self.bottom_pane
                .update_status_text("No reasoning to toggle".to_string());
        }
        self.refresh_reasoning_collapsed_visibility();
        // Collapsed state changes affect heights; clear cache
        self.invalidate_height_cache();
        self.request_redraw();
        // In standard terminal mode, re-mirror the transcript so scrollback reflects
        // the new collapsed/expanded state. We cannot edit prior lines in scrollback,
        // so append a fresh view.
        if self.standard_terminal_mode {
            let mut lines = Vec::new();
            lines.push(ratatui::text::Line::from(""));
            lines.extend(self.export_transcript_lines_for_buffer());
            self.app_event_tx
                .send(crate::app_event::AppEvent::InsertHistory(lines));
        }
    }

    fn refresh_standard_terminal_hint(&mut self) {
        if self.standard_terminal_mode {
            let message = "Standard terminal mode active. Press Ctrl+T to return to full UI.";
            self.bottom_pane
                .set_standard_terminal_hint(Some(message.to_string()));
        } else {
            self.bottom_pane.set_standard_terminal_hint(None);
        }
    }

    pub(crate) fn set_standard_terminal_mode(&mut self, enabled: bool) {
        self.standard_terminal_mode = enabled;
        self.refresh_standard_terminal_hint();
    }

    pub(crate) fn is_reasoning_shown(&self) -> bool {
        // Check if any reasoning cell exists and if it's expanded
        for cell in &self.history_cells {
            if let Some(reasoning_cell) = cell
                .as_any()
                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            {
                return !reasoning_cell.is_collapsed();
            }
        }
        // If no reasoning cells exist, return the config default
        self.config.tui.show_reasoning
    }

    pub(crate) fn show_chrome_options(&mut self, port: Option<u16>) {
        self.ensure_settings_overlay_section(SettingsSection::Chrome);
        let content = self.build_chrome_settings_content(port);
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_chrome_content(content);
        }
        self.request_redraw();
    }

    pub(crate) fn handle_chrome_launch_option(
        &mut self,
        option: ChromeLaunchOption,
        port: Option<u16>,
    ) {
        let launch_port = port.unwrap_or(9222);
        let ticket = self.make_background_tail_ticket();

        match option {
            ChromeLaunchOption::CloseAndUseProfile => {
                // Kill existing Chrome and launch with user profile
                #[cfg(target_os = "macos")]
                {
                    let _ = std::process::Command::new("pkill")
                        .arg("-f")
                        .arg("Google Chrome")
                        .output();
                    std::thread::sleep(std::time::Duration::from_millis(500));
                }
                #[cfg(target_os = "linux")]
                {
                    let _ = std::process::Command::new("pkill")
                        .arg("-f")
                        .arg("chrome")
                        .output();
                    std::thread::sleep(std::time::Duration::from_millis(500));
                }
                #[cfg(target_os = "windows")]
                {
                    let _ = std::process::Command::new("taskkill")
                        .arg("/F")
                        .arg("/IM")
                        .arg("chrome.exe")
                        .output();
                    std::thread::sleep(std::time::Duration::from_millis(500));
                }
                self.launch_chrome_with_profile(launch_port);
                // Connect to Chrome after launching
                self.connect_to_chrome_after_launch(launch_port, ticket.clone());
            }
            ChromeLaunchOption::UseTempProfile => {
                // Launch with temporary profile
                self.launch_chrome_with_temp_profile(launch_port);
                // Connect to Chrome after launching
                self.connect_to_chrome_after_launch(launch_port, ticket.clone());
            }
            ChromeLaunchOption::UseInternalBrowser => {
                // Redirect to internal browser command
                self.handle_browser_command(String::new());
            }
            ChromeLaunchOption::Cancel => {
                // Do nothing, just close the dialog
            }
        }
    }

    fn launch_chrome_with_profile(&mut self, port: u16) {
        use std::process::Stdio;

        #[cfg(target_os = "macos")]
        {
            let log_path = format!("{}/code-chrome.log", std::env::temp_dir().display());
            let mut cmd = std::process::Command::new(
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
            );
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .arg("--enable-logging")
                .arg("--log-level=1")
                .arg(format!("--log-file={}", log_path))
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            let _ = cmd.spawn();
        }

        #[cfg(target_os = "linux")]
        {
            let log_path = format!("{}/code-chrome.log", std::env::temp_dir().display());
            let mut cmd = std::process::Command::new("google-chrome");
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .arg("--enable-logging")
                .arg("--log-level=1")
                .arg(format!("--log-file={}", log_path))
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            let _ = cmd.spawn();
        }

        #[cfg(target_os = "windows")]
        {
            let log_path = format!("{}\\code-chrome.log", std::env::temp_dir().display());
            let chrome_paths = vec![
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                format!(
                    "{}\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe",
                    std::env::var("USERPROFILE").unwrap_or_default()
                ),
            ];

            for chrome_path in chrome_paths {
                if std::path::Path::new(&chrome_path).exists() {
                    let mut cmd = std::process::Command::new(&chrome_path);
                    cmd.arg(format!("--remote-debugging-port={}", port))
                        .arg("--no-first-run")
                        .arg("--no-default-browser-check")
                        .arg("--disable-component-extensions-with-background-pages")
                        .arg("--disable-background-networking")
                        .arg("--silent-debugger-extension-api")
                        .arg("--remote-allow-origins=*")
                        .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                        .arg("--disable-hang-monitor")
                        .arg("--disable-background-timer-throttling")
                        .arg("--enable-logging")
                        .arg("--log-level=1")
                        .arg(format!("--log-file={}", log_path))
                        .stdout(Stdio::null())
                        .stderr(Stdio::null())
                        .stdin(Stdio::null());
                    let _ = cmd.spawn();
                    break;
                }
            }
        }

        // Add status message
        self.history_push_plain_paragraphs(
            PlainMessageKind::Background,
            vec!["✅ Chrome launched with user profile".to_string()],
        );
        // Show browsing state in input border after launch
        self.bottom_pane
            .update_status_text("using browser".to_string());
    }

    fn connect_to_chrome_after_launch(
        &mut self,
        port: u16,
        ticket: BackgroundOrderTicket,
    ) {
        // Wait a moment for Chrome to start, then reuse the existing connection logic
        let app_event_tx = self.app_event_tx.clone();
        let latest_screenshot = self.latest_browser_screenshot.clone();

        tokio::spawn(async move {
            // Wait for Chrome to fully start
            tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

            // Now try to connect using the shared CDP connection logic
            ChatWidget::connect_to_cdp_chrome(
                None,
                Some(port),
                latest_screenshot,
                app_event_tx,
                ticket,
            )
            .await;
        });
    }

    /// Shared CDP connection logic used by both /chrome command and Chrome launch options
    async fn connect_to_cdp_chrome(
        host: Option<String>,
        port: Option<u16>,
        latest_screenshot: Arc<Mutex<Option<(PathBuf, String)>>>,
        app_event_tx: AppEventSender,
        ticket: BackgroundOrderTicket,
    ) {
        tracing::info!(
            "[cdp] connect_to_cdp_chrome() begin, host={:?}, port={:?}",
            host,
            port
        );
        let browser_manager = ChatWidget::get_browser_manager().await;
        browser_manager.set_enabled_sync(true);

        // Configure for CDP connection (prefer cached ws/port on auto-detect)
        // Track whether we're attempting via cached WS and retain a cached port for fallback.
        let mut attempted_via_cached_ws = false;
        let mut cached_port_for_fallback: Option<u16> = None;
        {
            let mut config = browser_manager.config.write().await;
            config.headless = false;
            config.persist_profile = true;
            config.enabled = true;

            if let Some(p) = port {
                config.connect_ws = None;
                config.connect_host = host.clone();
                config.connect_port = Some(p);
            } else {
                // Load persisted cache from disk (if any), then fall back to in-memory
                let (cached_port, cached_ws) = match read_cached_connection().await {
                    Some(v) => v,
                    None => code_browser::global::get_last_connection().await,
                };
                cached_port_for_fallback = cached_port;
                if let Some(ws) = cached_ws {
                    tracing::info!("[cdp] using cached Chrome WS endpoint");
                    attempted_via_cached_ws = true;
                    config.connect_ws = Some(ws);
                    config.connect_port = None;
                } else if let Some(p) = cached_port_for_fallback {
                    tracing::info!("[cdp] using cached Chrome debug port: {}", p);
                    config.connect_ws = None;
                    config.connect_host = host.clone();
                    config.connect_port = Some(p);
                } else {
                    config.connect_ws = None;
                    config.connect_host = host.clone();
                    config.connect_port = Some(0); // auto-detect
                }
            }
        }

        // Try to connect to existing Chrome (no fallback to internal browser) with timeout
        tracing::info!("[cdp] calling BrowserManager::connect_to_chrome_only()…");
        // Allow 15s for WS discovery + 5s for connect
        let connect_deadline = tokio::time::Duration::from_secs(20);
        let connect_result =
            tokio::time::timeout(connect_deadline, browser_manager.connect_to_chrome_only()).await;
        match connect_result {
            Err(_) => {
                tracing::error!(
                    "[cdp] connect_to_chrome_only timed out after {:?}",
                    connect_deadline
                );
                app_event_tx.send_background_event_with_ticket(
                    &ticket,
                    format!(
                        "❌ CDP connect timed out after {}s. Ensure Chrome is running with --remote-debugging-port={} and http://127.0.0.1:{}/json/version is reachable",
                        connect_deadline.as_secs(),
                        port.unwrap_or(0),
                        port.unwrap_or(0)
                    ),
                );
                // Offer launch options popup to help recover quickly
                app_event_tx.send(AppEvent::ShowChromeOptions(port));
                return;
            }
            Ok(result) => match result {
                Ok(_) => {
                    tracing::info!("[cdp] Connected to Chrome via CDP");

                    // Build a detailed success message including CDP port and current URL when available
                    let (detected_port, detected_ws) =
                        code_browser::global::get_last_connection().await;
                    // Prefer explicit port; otherwise try to parse from ws URL
                    let mut port_num: Option<u16> = detected_port;
                    if port_num.is_none() {
                        if let Some(ws) = &detected_ws {
                            // crude parse: ws://host:port/...
                            if let Some(after_scheme) = ws.split("//").nth(1) {
                                if let Some(hostport) = after_scheme.split('/').next() {
                                    if let Some(pstr) = hostport.split(':').nth(1) {
                                        if let Ok(p) = pstr.parse::<u16>() {
                                            port_num = Some(p);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Try to capture current page URL (best-effort)
                    let current_url = browser_manager.get_current_url().await;

                    let success_msg = match (port_num, current_url) {
                        (Some(p), Some(url)) if !url.is_empty() => {
                            format!("✅ Connected to Chrome via CDP (port {}) to {}", p, url)
                        }
                        (Some(p), _) => format!("✅ Connected to Chrome via CDP (port {})", p),
                        (None, Some(url)) if !url.is_empty() => {
                            format!("✅ Connected to Chrome via CDP to {}", url)
                        }
                        _ => "✅ Connected to Chrome via CDP".to_string(),
                    };

                    // Immediately notify success (do not block on screenshots)
                    app_event_tx
                        .send_background_event_with_ticket(&ticket, success_msg.clone());

                    // Persist last connection cache to disk (best-effort)
                    tokio::spawn(async move {
                        let (p, ws) = code_browser::global::get_last_connection().await;
                        let _ = write_cached_connection(p, ws).await;
                    });

                    // Set up navigation callback
                    let latest_screenshot_callback = latest_screenshot.clone();
                    let app_event_tx_callback = app_event_tx.clone();

                    browser_manager
                        .set_navigation_callback(move |url| {
                            tracing::info!("CDP Navigation callback triggered for URL: {}", url);
                            let latest_screenshot_inner = latest_screenshot_callback.clone();
                            let app_event_tx_inner = app_event_tx_callback.clone();
                            let url_inner = url.clone();

                            tokio::spawn(async move {
                                tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                                let browser_manager_inner = ChatWidget::get_browser_manager().await;
                                let mut attempt = 0;
                                let max_attempts = 2;
                                loop {
                                    attempt += 1;
                                    match browser_manager_inner.capture_screenshot_with_url().await
                                    {
                                        Ok((paths, _)) => {
                                            if let Some(first_path) = paths.first() {
                                                tracing::info!(
                                                    "[cdp] auto-captured screenshot: {}",
                                                    first_path.display()
                                                );

                                                if let Ok(mut latest) =
                                                    latest_screenshot_inner.lock()
                                                {
                                                    *latest = Some((
                                                        first_path.clone(),
                                                        url_inner.clone(),
                                                    ));
                                                }

                                                use code_core::protocol::{
                                                    BrowserScreenshotUpdateEvent, Event, EventMsg,
                                                };
                                                let _ = app_event_tx_inner.send(
                                                    AppEvent::CodexEvent(Event {
                                                        id: uuid::Uuid::new_v4().to_string(),
                                                        event_seq: 0,
                                                        msg: EventMsg::BrowserScreenshotUpdate(
                                                            BrowserScreenshotUpdateEvent {
                                                                screenshot_path: first_path.clone(),
                                                                url: url_inner,
                                                            },
                                                        ),
                                                        order: None,
                                                    }),
                                                );
                                                break;
                                            }
                                        }
                                        Err(e) => {
                                            tracing::warn!(
                                                "[cdp] auto-capture failed (attempt {}): {}",
                                                attempt,
                                                e
                                            );
                                            if attempt >= max_attempts {
                                                break;
                                            }
                                            tokio::time::sleep(tokio::time::Duration::from_millis(
                                                250,
                                            ))
                                            .await;
                                            continue;
                                        }
                                    }
                                    // end match
                                }
                                // end loop
                            });
                        })
                        .await;

                    // Set as global manager
                    code_browser::global::set_global_browser_manager(browser_manager.clone())
                        .await;

                    // Capture initial screenshot in background (don't block connect feedback)
                    {
                        let latest_screenshot_bg = latest_screenshot.clone();
                        let app_event_tx_bg = app_event_tx.clone();
                        tokio::spawn(async move {
                            tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                            let browser_manager = ChatWidget::get_browser_manager().await;
                            let mut attempt = 0;
                            let max_attempts = 2;
                            loop {
                                attempt += 1;
                                match browser_manager.capture_screenshot_with_url().await {
                                    Ok((paths, url)) => {
                                        if let Some(first_path) = paths.first() {
                                            tracing::info!(
                                                "Initial CDP screenshot captured: {}",
                                                first_path.display()
                                            );
                                            if let Ok(mut latest) = latest_screenshot_bg.lock() {
                                                *latest = Some((
                                                    first_path.clone(),
                                                    url.clone()
                                                        .unwrap_or_else(|| "Chrome".to_string()),
                                                ));
                                            }
                                            use code_core::protocol::BrowserScreenshotUpdateEvent;
                                            use code_core::protocol::Event;
                                            use code_core::protocol::EventMsg;
                                            let _ =
                                                app_event_tx_bg.send(AppEvent::CodexEvent(Event {
                                                    id: uuid::Uuid::new_v4().to_string(),
                                                    event_seq: 0,
                                                    msg: EventMsg::BrowserScreenshotUpdate(
                                                        BrowserScreenshotUpdateEvent {
                                                            screenshot_path: first_path.clone(),
                                                            url: url.unwrap_or_else(|| {
                                                                "Chrome".to_string()
                                                            }),
                                                        },
                                                    ),
                                                    order: None,
                                                }));
                                            break;
                                        }
                                    }
                                    Err(e) => {
                                        tracing::warn!(
                                            "Failed to capture initial CDP screenshot (attempt {}): {}",
                                            attempt,
                                            e
                                        );
                                        if attempt >= max_attempts {
                                            break;
                                        }
                                        tokio::time::sleep(tokio::time::Duration::from_millis(250))
                                            .await;
                                    }
                                }
                            }
                        });
                    }
                }
                Err(e) => {
                    let err_msg = format!("{}", e);
                    // If we attempted via a cached WS, clear it and fallback to port-based discovery once.
                    if attempted_via_cached_ws {
                        tracing::warn!(
                            "[cdp] cached WS connect failed: {} — clearing WS cache and retrying via port discovery",
                            err_msg
                        );
                        let port_to_keep = cached_port_for_fallback;
                        // Clear WS in-memory and on-disk
                        code_browser::global::set_last_connection(port_to_keep, None).await;
                        let _ = write_cached_connection(port_to_keep, None).await;

                        // Reconfigure to use port (prefer cached port, else auto-detect)
                        {
                            let mut cfg = browser_manager.config.write().await;
                            cfg.connect_ws = None;
                            cfg.connect_port = Some(port_to_keep.unwrap_or(0));
                        }

                        tracing::info!(
                            "[cdp] retrying connect via port discovery after WS failure…"
                        );
                        let retry_deadline = tokio::time::Duration::from_secs(20);
                        let retry = tokio::time::timeout(
                            retry_deadline,
                            browser_manager.connect_to_chrome_only(),
                        )
                        .await;
                        match retry {
                            Ok(Ok(_)) => {
                                tracing::info!(
                                    "[cdp] Fallback connect succeeded after clearing cached WS"
                                );
                                // Emit success event and set up callbacks, mirroring the success path above
                                let (detected_port, detected_ws) =
                                    code_browser::global::get_last_connection().await;
                                let mut port_num: Option<u16> = detected_port;
                                if port_num.is_none() {
                                    if let Some(ws) = &detected_ws {
                                        if let Some(after_scheme) = ws.split("//").nth(1) {
                                            if let Some(hostport) = after_scheme.split('/').next() {
                                                if let Some(pstr) = hostport.split(':').nth(1) {
                                                    if let Ok(p) = pstr.parse::<u16>() {
                                                        port_num = Some(p);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                let current_url = browser_manager.get_current_url().await;
                                let success_msg = match (port_num, current_url) {
                                    (Some(p), Some(url)) if !url.is_empty() => {
                                        format!(
                                            "✅ Connected to Chrome via CDP (port {}) to {}",
                                            p, url
                                        )
                                    }
                                    (Some(p), _) => {
                                        format!("✅ Connected to Chrome via CDP (port {})", p)
                                    }
                                    (None, Some(url)) if !url.is_empty() => {
                                        format!("✅ Connected to Chrome via CDP to {}", url)
                                    }
                                    _ => "✅ Connected to Chrome via CDP".to_string(),
                                };
                                app_event_tx
                                    .send_background_event_with_ticket(&ticket, success_msg);

                                // Persist last connection cache
                                tokio::spawn(async move {
                                    let (p, ws) =
                                        code_browser::global::get_last_connection().await;
                                    let _ = write_cached_connection(p, ws).await;
                                });

                                // Navigation callback
                                let latest_screenshot_callback = latest_screenshot.clone();
                                let app_event_tx_callback = app_event_tx.clone();
                                browser_manager
                                    .set_navigation_callback(move |url| {
                                        tracing::info!("CDP Navigation callback triggered for URL: {}", url);
                                        let latest_screenshot_inner = latest_screenshot_callback.clone();
                                        let app_event_tx_inner = app_event_tx_callback.clone();
                                        let url_inner = url.clone();
                                        tokio::spawn(async move {
                                            tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                                            let browser_manager_inner = ChatWidget::get_browser_manager().await;
                                            let mut attempt = 0;
                                            let max_attempts = 2;
                                            loop {
                                                attempt += 1;
                                                match browser_manager_inner.capture_screenshot_with_url().await {
                                                    Ok((paths, _)) => {
                                                        if let Some(first_path) = paths.first() {
                                                            tracing::info!("[cdp] auto-captured screenshot: {}", first_path.display());
                                                            if let Ok(mut latest) = latest_screenshot_inner.lock() {
                                                                *latest = Some((first_path.clone(), url_inner.clone()));
                                                            }
                                                            use code_core::protocol::{BrowserScreenshotUpdateEvent, Event, EventMsg};
                                                            let _ = app_event_tx_inner.send(AppEvent::CodexEvent(Event {
                                                                id: uuid::Uuid::new_v4().to_string(),
                                                                event_seq: 0,
                                                                msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                                                    screenshot_path: first_path.clone(),
                                                                    url: url_inner,
                                                                }),
                                                                order: None,
                                                            }));
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        tracing::warn!("[cdp] auto-capture failed (attempt {}): {}", attempt, e);
                                                        if attempt >= max_attempts { break; }
                                                        tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                                                    }
                                                }
                                            }
                                        });
                                    })
                                    .await;
                                // Set as global manager like success path
                                code_browser::global::set_global_browser_manager(
                                    browser_manager.clone(),
                                )
                                .await;

                                // Initial screenshot in background (best-effort)
                                {
                                    let latest_screenshot_bg = latest_screenshot.clone();
                                    let app_event_tx_bg = app_event_tx.clone();
                                    tokio::spawn(async move {
                                        tokio::time::sleep(tokio::time::Duration::from_millis(250))
                                            .await;
                                        let browser_manager =
                                            ChatWidget::get_browser_manager().await;
                                        let mut attempt = 0;
                                        let max_attempts = 2;
                                        loop {
                                            attempt += 1;
                                            match browser_manager
                                                .capture_screenshot_with_url()
                                                .await
                                            {
                                                Ok((paths, url)) => {
                                                    if let Some(first_path) = paths.first() {
                                                        tracing::info!(
                                                            "Initial CDP screenshot captured: {}",
                                                            first_path.display()
                                                        );
                                                        if let Ok(mut latest) =
                                                            latest_screenshot_bg.lock()
                                                        {
                                                            *latest = Some((
                                                                first_path.clone(),
                                                                url.clone().unwrap_or_else(|| {
                                                                    "Chrome".to_string()
                                                                }),
                                                            ));
                                                        }
                                                        use code_core::protocol::BrowserScreenshotUpdateEvent;
                                                        use code_core::protocol::Event;
                                                        use code_core::protocol::EventMsg;
                                                        let _ = app_event_tx_bg.send(AppEvent::CodexEvent(Event {
                                                            id: uuid::Uuid::new_v4().to_string(),
                                                            event_seq: 0,
                                                            msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                                                screenshot_path: first_path.clone(),
                                                                url: url.unwrap_or_else(|| "Chrome".to_string()),
                                                            }),
                                                            order: None,
                                                        }));
                                                        break;
                                                    }
                                                }
                                                Err(e) => {
                                                    tracing::warn!(
                                                        "Failed to capture initial CDP screenshot (attempt {}): {}",
                                                        attempt,
                                                        e
                                                    );
                                                    if attempt >= max_attempts {
                                                        break;
                                                    }
                                                    tokio::time::sleep(
                                                        tokio::time::Duration::from_millis(250),
                                                    )
                                                    .await;
                                                }
                                            }
                                        }
                                    });
                                }
                                return;
                            }
                            Ok(Err(e2)) => {
                                tracing::error!("[cdp] Fallback connect failed: {}", e2);
                                app_event_tx.send_background_event_with_ticket(
                                    &ticket,
                                    format!(
                                        "❌ Failed to connect to Chrome after WS fallback: {} (original: {})",
                                        e2, err_msg
                                    ),
                                );
                                // Also surface the Chrome launch options UI to assist the user
                                app_event_tx.send(AppEvent::ShowChromeOptions(port));
                                return;
                            }
                            Err(_) => {
                                tracing::error!(
                                    "[cdp] Fallback connect timed out after {:?}",
                                    retry_deadline
                                );
                                app_event_tx.send_background_event_with_ticket(
                                    &ticket,
                                    format!(
                                        "❌ CDP connect timed out after {}s during fallback. Ensure Chrome is running with --remote-debugging-port and /json/version is reachable",
                                        retry_deadline.as_secs()
                                    ),
                                );
                                // Also surface the Chrome launch options UI to assist the user
                                app_event_tx.send(AppEvent::ShowChromeOptions(port));
                                return;
                            }
                        }
                    } else {
                        tracing::error!(
                            "[cdp] connect_to_chrome_only failed immediately: {}",
                            err_msg
                        );
                        app_event_tx.send_background_event_with_ticket(
                            &ticket,
                            format!("❌ Failed to connect to Chrome: {}", err_msg),
                        );
                        // Offer launch options popup to help recover quickly
                        app_event_tx.send(AppEvent::ShowChromeOptions(port));
                        return;
                    }
                }
            },
        }
    }

    fn launch_chrome_with_temp_profile(&mut self, port: u16) {
        use std::process::Stdio;

        let temp_dir = std::env::temp_dir();
        let profile_dir = temp_dir.join(format!("code-chrome-temp-{}", port));

        #[cfg(target_os = "macos")]
        {
            let log_path = format!("{}/code-chrome.log", std::env::temp_dir().display());
            let mut cmd = std::process::Command::new(
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
            );
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg(format!("--user-data-dir={}", profile_dir.display()))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .arg("--enable-logging")
                .arg("--log-level=1")
                .arg(format!("--log-file={}", log_path))
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            let _ = cmd.spawn();
        }

        #[cfg(target_os = "linux")]
        {
            let log_path = format!("{}/code-chrome.log", std::env::temp_dir().display());
            let mut cmd = std::process::Command::new("google-chrome");
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg(format!("--user-data-dir={}", profile_dir.display()))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .arg("--enable-logging")
                .arg("--log-level=1")
                .arg(format!("--log-file={}", log_path))
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            let _ = cmd.spawn();
        }

        #[cfg(target_os = "windows")]
        {
            let log_path = format!("{}\\code-chrome.log", std::env::temp_dir().display());
            let chrome_paths = vec![
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                format!(
                    "{}\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe",
                    std::env::var("USERPROFILE").unwrap_or_default()
                ),
            ];

            for chrome_path in chrome_paths {
                if std::path::Path::new(&chrome_path).exists() {
                    let mut cmd = std::process::Command::new(&chrome_path);
                    cmd.arg(format!("--remote-debugging-port={}", port))
                        .arg(format!("--user-data-dir={}", profile_dir.display()))
                        .arg("--no-first-run")
                        .arg("--no-default-browser-check")
                        .arg("--disable-component-extensions-with-background-pages")
                        .arg("--disable-background-networking")
                        .arg("--silent-debugger-extension-api")
                        .arg("--remote-allow-origins=*")
                        .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                        .arg("--disable-hang-monitor")
                        .arg("--disable-background-timer-throttling")
                        .arg("--enable-logging")
                        .arg("--log-level=1")
                        .arg(format!("--log-file={}", log_path))
                        .stdout(Stdio::null())
                        .stderr(Stdio::null())
                        .stdin(Stdio::null());
                    let _ = cmd.spawn();
                    break;
                }
            }
        }

        // Add status message
        self.history_push_plain_paragraphs(
            PlainMessageKind::Background,
            vec![format!(
                "✅ Chrome launched with temporary profile at {}",
                profile_dir.display()
            )],
        );
    }

    fn schedule_browser_autofix(
        app_event_tx: AppEventSender,
        ticket: BackgroundOrderTicket,
        autofix_state: Arc<AtomicBool>,
        failure_context: &str,
        raw_error: String,
    ) {
        if autofix_state
            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
            .is_err()
        {
            tracing::info!(
                "[/browser] auto-handoff already requested; skipping duplicate dispatch"
            );
            return;
        }

        let sanitized = raw_error.replace('\n', " ").replace('\r', " ");
        let trimmed = sanitized.trim();
        let truncated = if trimmed.len() > 220 {
            let mut shortened = trimmed.chars().take(220).collect::<String>();
            shortened.push('…');
            shortened
        } else {
            trimmed.to_string()
        };

        tracing::info!(
            "[/browser] scheduling Code autofix for context='{}', error='{}'",
            failure_context,
            truncated
        );

        let visible_message = format!(
            "🤖 Handing /browser failure ({}) to Code. Error: {}",
            failure_context,
            truncated
        );
        app_event_tx.send_background_event_with_ticket(&ticket, visible_message);

        let command_text = format!(
            "/code The /browser command failed to {context}. Recent error: {error}. Please diagnose and fix the environment (for example, install or configure Chrome) so /browser works in this workspace.",
            context = failure_context,
            error = truncated
        );
        app_event_tx.send(AppEvent::DispatchCommand(
            SlashCommand::Code,
            command_text,
        ));
    }

    pub(crate) fn handle_browser_command(&mut self, command_text: String) {
        // Parse the browser subcommand
        let trimmed = command_text.trim();
        let browser_ticket = self.make_background_tail_ticket();
        self.consume_pending_prompt_for_ui_only_turn();

        // Handle the case where just "/browser" was typed
        if trimmed.is_empty() {
            tracing::info!("[/browser] toggling internal browser on/off");

            // Optimistically reflect browsing activity in the input border if we end up enabling
            // (safe even if we later disable; UI will update on event messages)
            self.bottom_pane
                .update_status_text("using browser".to_string());

            // Toggle asynchronously: if internal browser is active, disable it; otherwise enable and open about:blank
            let app_event_tx = self.app_event_tx.clone();
            let browser_autofix_flag = self.browser_autofix_requested.clone();
            let ticket = browser_ticket.clone();
            tokio::spawn(async move {
                let browser_manager = ChatWidget::get_browser_manager().await;
                // Determine if internal browser is currently active
                let (is_external, status) = {
                    let cfg = browser_manager.config.read().await;
                    let is_external = cfg.connect_port.is_some() || cfg.connect_ws.is_some();
                    drop(cfg);
                    (is_external, browser_manager.get_status().await)
                };

                if !is_external && status.browser_active {
                    // Internal browser active → disable it
                    if let Err(e) = browser_manager.set_enabled(false).await {
                        tracing::warn!("[/browser] failed to disable internal browser: {}", e);
                    }
                    app_event_tx
                        .send_background_event_with_ticket(&ticket, "🔌 Browser disabled".to_string());
                } else {
                    // Not in internal mode → enable internal and open about:blank
                    // Reuse existing helper (ensures config + start + global manager + screenshot)
                    // Then explicitly navigate to about:blank
                    // We fire-and-forget errors to avoid blocking UI
                    {
                        // Configure cleanly for internal mode
                        let mut cfg = browser_manager.config.write().await;
                        cfg.connect_port = None;
                        cfg.connect_ws = None;
                        cfg.enabled = true;
                        cfg.persist_profile = false;
                        cfg.headless = true;
                    }

                    if let Err(e) = browser_manager.start().await {
                        let error_text = e.to_string();
                        tracing::error!(
                            "[/browser] failed to start internal browser: {}",
                            error_text
                        );
                        app_event_tx.send_background_event_with_ticket(
                            &ticket,
                            format!("❌ Failed to start internal browser: {}", error_text),
                        );
                        ChatWidget::schedule_browser_autofix(
                            app_event_tx.clone(),
                            ticket.clone(),
                            browser_autofix_flag.clone(),
                            "start the internal browser",
                            error_text,
                        );
                        return;
                    }

                    browser_autofix_flag.store(false, Ordering::SeqCst);

                    // Set as global manager so core/session share the same instance
                    code_browser::global::set_global_browser_manager(browser_manager.clone())
                        .await;

                    // Navigate to about:blank explicitly
                    if let Err(e) = browser_manager.goto("about:blank").await {
                        tracing::warn!("[/browser] failed to open about:blank: {}", e);
                    }

                    // Emit confirmation
                    app_event_tx
                        .send_background_event_with_ticket(
                            &ticket,
                            "✅ Browser enabled (about:blank)".to_string(),
                        );
                }
            });
            return;
        }

        let parts: Vec<&str> = trimmed.split_whitespace().collect();
        let response = if !parts.is_empty() {
            let first_arg = parts[0];

            // Check if the first argument looks like a URL (has a dot or protocol)
            let is_url = first_arg.contains("://") || first_arg.contains(".");

            if is_url {
                // It's a URL - enable browser mode and navigate to it
                let url = parts.join(" ");

                // Ensure URL has protocol
                let full_url = if !url.contains("://") {
                    format!("https://{}", url)
                } else {
                    url.clone()
                };

                // We are navigating with the internal browser
                self.browser_is_external = false;

                // Navigate to URL and wait for it to load
                let latest_screenshot = self.latest_browser_screenshot.clone();
                let app_event_tx = self.app_event_tx.clone();
                let browser_autofix_flag = self.browser_autofix_requested.clone();
                let url_for_goto = full_url.clone();
                let ticket = browser_ticket.clone();

                // Add status message
                let status_msg = format!("🌐 Opening internal browser: {}", full_url);
                self.history_push_plain_paragraphs(
                    PlainMessageKind::Background,
                    vec![status_msg],
                );
                // Also reflect browsing activity in the input border
                self.bottom_pane
                    .update_status_text("using browser".to_string());

                // Connect immediately, don't wait for message send
                tokio::spawn(async move {
                    // Get the global browser manager
                    let browser_manager = ChatWidget::get_browser_manager().await;

                    // Enable browser mode and ensure it's using internal browser (not CDP)
                    browser_manager.set_enabled_sync(true);
                    {
                        let mut config = browser_manager.config.write().await;
                        config.headless = false; // Ensure browser is visible when navigating to URL
                        config.connect_port = None; // Ensure we're not trying to connect to CDP
                        config.connect_ws = None; // Ensure we're not trying to connect via WebSocket
                    }

                    // IMPORTANT: Start the browser manager first before navigating
                    if let Err(e) = browser_manager.start().await {
                        let error_text = e.to_string();
                        tracing::error!(
                            "Failed to start TUI browser manager: {}",
                            error_text
                        );
                        app_event_tx.send_background_event_with_ticket(
                            &ticket,
                            format!("❌ Failed to start internal browser: {}", error_text),
                        );
                        ChatWidget::schedule_browser_autofix(
                            app_event_tx.clone(),
                            ticket.clone(),
                            browser_autofix_flag.clone(),
                            "launch the internal browser",
                            error_text,
                        );
                        return;
                    }

                    browser_autofix_flag.store(false, Ordering::SeqCst);

                    // Set up navigation callback to auto-capture screenshots
                    {
                        let latest_screenshot_callback = latest_screenshot.clone();
                        let app_event_tx_callback = app_event_tx.clone();

                        browser_manager
                            .set_navigation_callback(move |url| {
                                tracing::info!("Navigation callback triggered for URL: {}", url);
                                let latest_screenshot_inner = latest_screenshot_callback.clone();
                                let app_event_tx_inner = app_event_tx_callback.clone();
                                let url_inner = url.clone();

                                tokio::spawn(async move {
                                    // Get browser manager in the inner async block
                                    let browser_manager_inner =
                                        ChatWidget::get_browser_manager().await;
                                    // Capture screenshot after navigation
                                    match browser_manager_inner.capture_screenshot_with_url().await
                                    {
                                        Ok((paths, _)) => {
                                            if let Some(first_path) = paths.first() {
                                                tracing::info!(
                                                    "Auto-captured screenshot after navigation: {}",
                                                    first_path.display()
                                                );

                                                // Update the latest screenshot
                                                if let Ok(mut latest) =
                                                    latest_screenshot_inner.lock()
                                                {
                                                    *latest = Some((
                                                        first_path.clone(),
                                                        url_inner.clone(),
                                                    ));
                                                }

                                                // Send update event
                                                use code_core::protocol::{
                                                    BrowserScreenshotUpdateEvent, EventMsg,
                                                };
                                                let _ = app_event_tx_inner.send(
                                                    AppEvent::CodexEvent(Event {
                                                        id: uuid::Uuid::new_v4().to_string(),
                                                        event_seq: 0,
                                                        msg: EventMsg::BrowserScreenshotUpdate(
                                                            BrowserScreenshotUpdateEvent {
                                                                screenshot_path: first_path.clone(),
                                                                url: url_inner,
                                                            },
                                                        ),
                                                        order: None,
                                                    }),
                                                );
                                            }
                                        }
                                        Err(e) => {
                                            tracing::error!(
                                                "Failed to auto-capture screenshot: {}",
                                                e
                                            );
                                        }
                                    }
                                });
                            })
                            .await;
                    }

                    // Set the browser manager as the global manager so both TUI and Session use the same instance
                    code_browser::global::set_global_browser_manager(browser_manager.clone())
                        .await;

                    // Ensure the navigation callback is also set on the global manager
                    let global_manager = code_browser::global::get_browser_manager().await;
                    if let Some(global_manager) = global_manager {
                        let latest_screenshot_global = latest_screenshot.clone();
                        let app_event_tx_global = app_event_tx.clone();

                        global_manager.set_navigation_callback(move |url| {
                            tracing::info!("Global manager navigation callback triggered for URL: {}", url);
                            let latest_screenshot_inner = latest_screenshot_global.clone();
                            let app_event_tx_inner = app_event_tx_global.clone();
                            let url_inner = url.clone();

                            tokio::spawn(async move {
                                // Wait a moment for the navigation to complete
                                tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;

                                // Capture screenshot after navigation
                                let browser_manager = code_browser::global::get_browser_manager().await;
                                if let Some(browser_manager) = browser_manager {
                                    match browser_manager.capture_screenshot_with_url().await {
                                        Ok((paths, _url)) => {
                                            if let Some(first_path) = paths.first() {
                                                tracing::info!("Auto-captured screenshot after global navigation: {}", first_path.display());

                                                // Update the latest screenshot
                                                if let Ok(mut latest) = latest_screenshot_inner.lock() {
                                                    *latest = Some((first_path.clone(), url_inner.clone()));
                                                }

                                                // Send update event
                                                use code_core::protocol::{BrowserScreenshotUpdateEvent, EventMsg};
                                                let _ = app_event_tx_inner.send(AppEvent::CodexEvent(Event { id: uuid::Uuid::new_v4().to_string(), event_seq: 0, msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                                        screenshot_path: first_path.clone(),
                                                        url: url_inner,
                                                    }), order: None }));
                                            }
                                        }
                                        Err(e) => {
                                            tracing::error!("Failed to auto-capture screenshot after global navigation: {}", e);
                                        }
                                    }
                                }
                            });
                        }).await;
                    }

                    // Navigate using global manager
                    match browser_manager.goto(&url_for_goto).await {
                        Ok(result) => {
                            tracing::info!(
                                "Browser opened to: {} (title: {:?})",
                                result.url,
                                result.title
                            );

                            // Send success message to chat
                            app_event_tx.send_background_event_with_ticket(
                                &ticket,
                                format!("✅ Internal browser opened: {}", result.url),
                            );

                            // Capture initial screenshot
                            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
                            match browser_manager.capture_screenshot_with_url().await {
                                Ok((paths, url)) => {
                                    if let Some(first_path) = paths.first() {
                                        tracing::info!(
                                            "Initial screenshot captured: {}",
                                            first_path.display()
                                        );

                                        // Update the latest screenshot
                                        if let Ok(mut latest) = latest_screenshot.lock() {
                                            *latest = Some((
                                                first_path.clone(),
                                                url.clone().unwrap_or_else(|| result.url.clone()),
                                            ));
                                        }

                                        // Send update event
                                        use code_core::protocol::BrowserScreenshotUpdateEvent;
                                        use code_core::protocol::EventMsg;
                                        let _ = app_event_tx.send(AppEvent::CodexEvent(Event {
                                            id: uuid::Uuid::new_v4().to_string(),
                                            event_seq: 0,
                                            msg: EventMsg::BrowserScreenshotUpdate(
                                                BrowserScreenshotUpdateEvent {
                                                    screenshot_path: first_path.clone(),
                                                    url: url.unwrap_or_else(|| result.url.clone()),
                                                },
                                            ),
                                            order: None,
                                        }));
                                    }
                                }
                                Err(e) => {
                                    tracing::error!("Failed to capture initial screenshot: {}", e);
                                }
                            }
                        }
                        Err(e) => {
                            tracing::error!("Failed to open browser: {}", e);
                        }
                    }
                });

                format!("Browser mode enabled: {}\n", full_url)
            } else {
                // It's a subcommand
                match first_arg {
                    "off" => {
                        // Disable browser mode
                        // Clear the screenshot popup
                        if let Ok(mut screenshot_lock) = self.latest_browser_screenshot.lock() {
                            *screenshot_lock = None;
                        }
                        // Close any open browser
                        tokio::spawn(async move {
                            let browser_manager = ChatWidget::get_browser_manager().await;
                            browser_manager.set_enabled_sync(false);
                            if let Err(e) = browser_manager.close().await {
                                tracing::error!("Failed to close browser: {}", e);
                            }
                        });
                        self.app_event_tx.send(AppEvent::RequestRedraw);
                        "Browser mode disabled.".to_string()
                    }
                    "status" => {
                        // Get status from BrowserManager
                        // Use a channel to get status from async context
                        let (status_tx, status_rx) = std::sync::mpsc::channel();
                        tokio::spawn(async move {
                            let browser_manager = ChatWidget::get_browser_manager().await;
                            let status = browser_manager.get_status_sync();
                            let _ = status_tx.send(status);
                        });
                        status_rx
                            .recv()
                            .unwrap_or_else(|_| "Failed to get browser status.".to_string())
                    }
                    "fullpage" => {
                        if parts.len() > 2 {
                            match parts[2] {
                                "on" => {
                                    // Enable full-page mode
                                    tokio::spawn(async move {
                                        let browser_manager =
                                            ChatWidget::get_browser_manager().await;
                                        browser_manager.set_fullpage_sync(true);
                                    });
                                    "Full-page screenshot mode enabled (max 8 segments)."
                                        .to_string()
                                }
                                "off" => {
                                    // Disable full-page mode
                                    tokio::spawn(async move {
                                        let browser_manager =
                                            ChatWidget::get_browser_manager().await;
                                        browser_manager.set_fullpage_sync(false);
                                    });
                                    "Full-page screenshot mode disabled.".to_string()
                                }
                                _ => "Usage: /browser fullpage [on|off]".to_string(),
                            }
                        } else {
                            "Usage: /browser fullpage [on|off]".to_string()
                        }
                    }
                    "config" => {
                        if parts.len() > 3 {
                            let key = parts[2];
                            let value = parts[3..].join(" ");
                            // Update browser config
                            match key {
                                "viewport" => {
                                    // Parse viewport dimensions like "1920x1080"
                                    if let Some((width_str, height_str)) = value.split_once('x') {
                                        if let (Ok(width), Ok(height)) =
                                            (width_str.parse::<u32>(), height_str.parse::<u32>())
                                        {
                                            tokio::spawn(async move {
                                                let browser_manager =
                                                    ChatWidget::get_browser_manager().await;
                                                browser_manager.set_viewport_sync(width, height);
                                            });
                                            format!(
                                                "Browser viewport updated: {}x{}",
                                                width, height
                                            )
                                        } else {
                                            "Invalid viewport format. Use: /browser config viewport 1920x1080".to_string()
                                        }
                                    } else {
                                        "Invalid viewport format. Use: /browser config viewport 1920x1080".to_string()
                                    }
                                }
                                "segments_max" => {
                                    if let Ok(max) = value.parse::<usize>() {
                                        tokio::spawn(async move {
                                            let browser_manager =
                                                ChatWidget::get_browser_manager().await;
                                            browser_manager.set_segments_max_sync(max);
                                        });
                                        format!("Browser segments_max updated: {}", max)
                                    } else {
                                        "Invalid segments_max value. Use a number.".to_string()
                                    }
                                }
                                _ => format!(
                                    "Unknown config key: {}. Available: viewport, segments_max",
                                    key
                                ),
                            }
                        } else {
                            "Usage: /browser config <key> <value>\nAvailable keys: viewport, segments_max".to_string()
                        }
                    }
                    _ => {
                        format!(
                            "Unknown browser command: '{}'\nUsage: /browser <url> | off | status | fullpage | config",
                            first_arg
                        )
                    }
                }
            }
        } else {
            "Browser commands:\n• /browser <url> - Open URL in internal browser\n• /browser off - Disable browser mode\n• /browser status - Show current status\n• /browser fullpage [on|off] - Toggle full-page mode\n• /browser config <key> <value> - Update configuration\n\nUse /chrome [port] to connect to external Chrome browser".to_string()
        };

        // Add the response to the UI as a ticketed background event so it stays with
        // the originating slash command turn.
        self.app_event_tx
            .send_background_event_with_ticket(&browser_ticket, response);
    }

    pub(crate) fn handle_github_command(&mut self, command_text: String) {
        let trimmed = command_text.trim();
        self.consume_pending_prompt_for_ui_only_turn();
        // If no args or 'status', show interactive settings in the footer
        if trimmed.is_empty() || trimmed.eq_ignore_ascii_case("status") {
            self.ensure_github_settings_overlay();
            return;
        }

        let response = if trimmed.eq_ignore_ascii_case("on") {
            self.config.github.check_workflows_on_push = true;
            match find_code_home() {
                Ok(home) => {
                    if let Err(e) = set_github_check_on_push(&home, true) {
                        tracing::warn!("Failed to persist /github on: {}", e);
                        "✅ Enabled GitHub watcher (persist failed; see logs)".to_string()
                    } else {
                        "✅ Enabled GitHub watcher (persisted)".to_string()
                    }
                }
                Err(_) => {
                    "✅ Enabled GitHub watcher (not persisted: CODE_HOME/CODEX_HOME not found)"
                        .to_string()
                }
            }
        } else if trimmed.eq_ignore_ascii_case("off") {
            self.config.github.check_workflows_on_push = false;
            match find_code_home() {
                Ok(home) => {
                    if let Err(e) = set_github_check_on_push(&home, false) {
                        tracing::warn!("Failed to persist /github off: {}", e);
                        "✅ Disabled GitHub watcher (persist failed; see logs)".to_string()
                    } else {
                        "✅ Disabled GitHub watcher (persisted)".to_string()
                    }
                }
                Err(_) => {
                    "✅ Disabled GitHub watcher (not persisted: CODE_HOME/CODEX_HOME not found)"
                        .to_string()
                }
            }
        } else {
            "Usage: /github [status|on|off]".to_string()
        };

        let lines: Vec<String> = response.lines().map(|line| line.to_string()).collect();
        self.history_push_plain_paragraphs(PlainMessageKind::Background, lines);

        self.ensure_github_settings_overlay();
    }

    fn validation_tool_flag_mut(
        &mut self,
        name: &str,
    ) -> Option<&mut Option<bool>> {
        let tools = &mut self.config.validation.tools;
        match name {
            "shellcheck" => Some(&mut tools.shellcheck),
            "markdownlint" => Some(&mut tools.markdownlint),
            "hadolint" => Some(&mut tools.hadolint),
            "yamllint" => Some(&mut tools.yamllint),
            "cargo-check" => Some(&mut tools.cargo_check),
            "shfmt" => Some(&mut tools.shfmt),
            "prettier" => Some(&mut tools.prettier),
            "tsc" => Some(&mut tools.tsc),
            "eslint" => Some(&mut tools.eslint),
            "phpstan" => Some(&mut tools.phpstan),
            "psalm" => Some(&mut tools.psalm),
            "mypy" => Some(&mut tools.mypy),
            "pyright" => Some(&mut tools.pyright),
            "golangci-lint" => Some(&mut tools.golangci_lint),
            _ => None,
        }
    }

    fn validation_group_label(group: ValidationGroup) -> &'static str {
        match group {
            ValidationGroup::Functional => "Functional checks",
            ValidationGroup::Stylistic => "Stylistic checks",
        }
    }

    fn validation_group_enabled(&self, group: ValidationGroup) -> bool {
        match group {
            ValidationGroup::Functional => self.config.validation.groups.functional,
            ValidationGroup::Stylistic => self.config.validation.groups.stylistic,
        }
    }

    fn validation_tool_requested(&self, name: &str) -> bool {
        let tools = &self.config.validation.tools;
        match name {
            "actionlint" => self.config.github.actionlint_on_patch,
            "shellcheck" => tools.shellcheck.unwrap_or(true),
            "markdownlint" => tools.markdownlint.unwrap_or(true),
            "hadolint" => tools.hadolint.unwrap_or(true),
            "yamllint" => tools.yamllint.unwrap_or(true),
            "cargo-check" => tools.cargo_check.unwrap_or(true),
            "shfmt" => tools.shfmt.unwrap_or(true),
            "prettier" => tools.prettier.unwrap_or(true),
            "tsc" => tools.tsc.unwrap_or(true),
            "eslint" => tools.eslint.unwrap_or(true),
            "phpstan" => tools.phpstan.unwrap_or(true),
            "psalm" => tools.psalm.unwrap_or(true),
            "mypy" => tools.mypy.unwrap_or(true),
            "pyright" => tools.pyright.unwrap_or(true),
            "golangci-lint" => tools.golangci_lint.unwrap_or(true),
            _ => true,
        }
    }

    fn validation_tool_enabled(&self, name: &str) -> bool {
        let requested = self.validation_tool_requested(name);
        let category = validation_tool_category(name);
        let group_enabled = match category {
            ValidationCategory::Functional => self.config.validation.groups.functional,
            ValidationCategory::Stylistic => self.config.validation.groups.stylistic,
        };
        requested && group_enabled
    }

    fn apply_validation_group_toggle(&mut self, group: ValidationGroup, enable: bool) {
        if self.validation_group_enabled(group) == enable {
            return;
        }

        match group {
            ValidationGroup::Functional => self.config.validation.groups.functional = enable,
            ValidationGroup::Stylistic => self.config.validation.groups.stylistic = enable,
        }

        if let Err(err) = self
            .code_op_tx
            .send(Op::UpdateValidationGroup { group, enable })
        {
            tracing::warn!("failed to send validation group update: {err}");
        }

        let result = match find_code_home() {
            Ok(home) => {
                let key = match group {
                    ValidationGroup::Functional => "functional",
                    ValidationGroup::Stylistic => "stylistic",
                };
                set_validation_group_enabled(&home, key, enable).map_err(|e| e.to_string())
            }
            Err(err) => Err(err.to_string()),
        };

        let label = Self::validation_group_label(group);
        if let Err(err) = result {
            self.push_background_tail(format!(
                "⚠️ {} {} (persist failed: {err})",
                label,
                if enable { "enabled" } else { "disabled" }
            ));
        }

        self.refresh_settings_overview_rows();
    }

    fn apply_validation_tool_toggle(&mut self, name: &str, enable: bool) {
        if name == "actionlint" {
            if self.config.github.actionlint_on_patch == enable {
                return;
            }
            self.config.github.actionlint_on_patch = enable;
            if let Err(err) = self
                .code_op_tx
                .send(Op::UpdateValidationTool { name: name.to_string(), enable })
            {
                tracing::warn!("failed to send validation tool update: {err}");
            }
            let persist_result = match find_code_home() {
                Ok(home) => set_github_actionlint_on_patch(&home, enable)
                    .map_err(|e| e.to_string()),
                Err(err) => Err(err.to_string()),
            };
            if let Err(err) = persist_result {
                self.push_background_tail(format!(
                    "⚠️ {}: {} (persist failed: {err})",
                    name,
                    if enable { "enabled" } else { "disabled" }
                ));
            }
            return;
        }

        let Some(flag) = self.validation_tool_flag_mut(name) else {
            self.push_background_tail(format!(
                "⚠️ Unknown validation tool '{name}'"
            ));
            return;
        };

        if flag.unwrap_or(true) == enable {
            return;
        }

        *flag = Some(enable);
        if let Err(err) = self
            .code_op_tx
            .send(Op::UpdateValidationTool { name: name.to_string(), enable })
        {
            tracing::warn!("failed to send validation tool update: {err}");
        }
        let persist_result = match find_code_home() {
            Ok(home) => set_validation_tool_enabled(&home, name, enable)
                .map_err(|e| e.to_string()),
            Err(err) => Err(err.to_string()),
        };
        if let Err(err) = persist_result {
            self.push_background_tail(format!(
                "⚠️ {}: {} (persist failed: {err})",
                name,
                if enable { "enabled" } else { "disabled" }
            ));
        }

        self.refresh_settings_overview_rows();
    }

    fn build_validation_status_message(&self) -> String {
        let mut lines = Vec::new();
        lines.push("Validation groups:".to_string());
        for group in [ValidationGroup::Functional, ValidationGroup::Stylistic] {
            let enabled = self.validation_group_enabled(group);
            lines.push(format!(
                "• {} — {}",
                Self::validation_group_label(group),
                if enabled { "enabled" } else { "disabled" }
            ));
        }
        lines.push("".to_string());
        lines.push("Tools:".to_string());
        for status in validation_settings_view::detect_tools() {
            let requested = self.validation_tool_requested(status.name);
            let effective = self.validation_tool_enabled(status.name);
            let mut state = if requested {
                if effective { "enabled".to_string() } else { "disabled (group off)".to_string() }
            } else {
                "disabled".to_string()
            };
            if !status.installed {
                state.push_str(" (not installed)");
            }
            lines.push(format!("• {} — {}", status.name, state));
        }
        lines.join("\n")
    }

    pub(crate) fn toggle_validation_tool(&mut self, name: &str, enable: bool) {
        self.apply_validation_tool_toggle(name, enable);
    }

    pub(crate) fn toggle_validation_group(&mut self, group: ValidationGroup, enable: bool) {
        self.apply_validation_group_toggle(group, enable);
    }

    pub(crate) fn handle_validation_command(&mut self, command_text: String) {
        let trimmed = command_text.trim();
        if trimmed.is_empty() {
            self.ensure_validation_settings_overlay();
            return;
        }

        let mut parts = trimmed.split_whitespace();
        match parts.next().unwrap_or("") {
            "status" => {
                let message = self.build_validation_status_message();
                self.push_background_tail(message);
            }
            "on" => {
                if !self.validation_group_enabled(ValidationGroup::Functional) {
                    self.apply_validation_group_toggle(ValidationGroup::Functional, true);
                }
            }
            "off" => {
                if self.validation_group_enabled(ValidationGroup::Functional) {
                    self.apply_validation_group_toggle(ValidationGroup::Functional, false);
                }
                if self.validation_group_enabled(ValidationGroup::Stylistic) {
                    self.apply_validation_group_toggle(ValidationGroup::Stylistic, false);
                }
            }
            group @ ("functional" | "stylistic") => {
                let Some(state) = parts.next() else {
                    self.push_background_tail("Usage: /validation <tool|group> on|off".to_string());
                    return;
                };
                let group = if group == "functional" {
                    ValidationGroup::Functional
                } else {
                    ValidationGroup::Stylistic
                };
                match state {
                    "on" | "enable" => self.apply_validation_group_toggle(group, true),
                    "off" | "disable" => self.apply_validation_group_toggle(group, false),
                    _ => self.push_background_tail(format!(
                        "⚠️ Unknown validation command '{}'. Use on|off.",
                        state
                    )),
                }
            }
            tool => {
                let Some(state) = parts.next() else {
                    self.push_background_tail("Usage: /validation <tool|group> on|off".to_string());
                    return;
                };
                match state {
                    "on" | "enable" => self.apply_validation_tool_toggle(tool, true),
                    "off" | "disable" => self.apply_validation_tool_toggle(tool, false),
                    _ => self.push_background_tail(format!(
                        "⚠️ Unknown validation command '{}'. Use on|off.",
                        state
                    )),
                }
            }
        }

        self.ensure_validation_settings_overlay();
    }

    fn format_mcp_summary(cfg: &code_core::config_types::McpServerConfig) -> String {
        use code_core::config_types::McpServerTransportConfig;

        match &cfg.transport {
            McpServerTransportConfig::Stdio { command, args, .. } => {
                if args.is_empty() {
                    command.clone()
                } else {
                    format!("{} {}", command, args.join(" "))
                }
            }
            McpServerTransportConfig::StreamableHttp { url, .. } => format!("HTTP {}", url),
        }
    }

    /// Handle `/mcp` command: manage MCP servers (status/on/off/add).
    pub(crate) fn handle_mcp_command(&mut self, command_text: String) {
        let trimmed = command_text.trim();
        if trimmed.is_empty() {
            self.show_settings_overlay(Some(SettingsSection::Mcp));
            return;
        }

        let mut parts = trimmed.split_whitespace();
        let sub = parts.next().unwrap_or("");

        match sub {
            "status" => match find_code_home() {
                Ok(home) => match code_core::config::list_mcp_servers(&home) {
                    Ok((enabled, disabled)) => {
                        let mut lines = String::new();
                        if enabled.is_empty() && disabled.is_empty() {
                            lines.push_str("No MCP servers configured. Use /mcp add … to add one.");
                        } else {
                            lines.push_str(&format!("Enabled ({}):\n", enabled.len()));
                            for (name, cfg) in enabled {
                                lines.push_str(&format!(
                                    "• {} — {}\n",
                                    name,
                                    Self::format_mcp_summary(&cfg)
                                ));
                            }
                            lines.push_str(&format!("\nDisabled ({}):\n", disabled.len()));
                            for (name, cfg) in disabled {
                                lines.push_str(&format!(
                                    "• {} — {}\n",
                                    name,
                                    Self::format_mcp_summary(&cfg)
                                ));
                            }
                        }
                        self.push_background_tail(lines);
                    }
                    Err(e) => {
                        let msg = format!("Failed to read MCP config: {}", e);
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                },
                Err(e) => {
                    let msg = format!("Failed to locate CODEX_HOME: {}", e);
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                }
            },
            "on" | "off" => {
                let name = parts.next().unwrap_or("");
                if name.is_empty() {
                    let msg = format!("Usage: /mcp {} <name>", sub);
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                    return;
                }
                match find_code_home() {
                    Ok(home) => {
                        match code_core::config::set_mcp_server_enabled(&home, name, sub == "on") {
                            Ok(changed) => {
                                if changed {
                                    // Keep ChatWidget's in-memory config roughly in sync for new sessions.
                                    if sub == "off" {
                                        self.config.mcp_servers.remove(name);
                                    }
                                    if sub == "on" {
                                        // If enabling, try to load its config from disk and add to in-memory map.
                                        if let Ok((enabled, _)) =
                                            code_core::config::list_mcp_servers(&home)
                                        {
                                            if let Some((_, cfg)) =
                                                enabled.into_iter().find(|(n, _)| n == name)
                                            {
                                                self.config
                                                    .mcp_servers
                                                    .insert(name.to_string(), cfg);
                                            }
                                        }
                                    }
                                    let msg = format!(
                                        "{} MCP server '{}'",
                                        if sub == "on" { "Enabled" } else { "Disabled" },
                                        name
                                    );
                                    self.push_background_tail(msg);
                                } else {
                                    let msg = format!(
                                        "No change: server '{}' was already {}",
                                        name,
                                        if sub == "on" { "enabled" } else { "disabled" }
                                    );
                                    self.push_background_tail(msg);
                                }
                            }
                            Err(e) => {
                                let msg = format!("Failed to update MCP server '{}': {}", name, e);
                                self.history_push_plain_state(history_cell::new_error_event(msg));
                            }
                        }
                    }
                    Err(e) => {
                        let msg = format!("Failed to locate CODEX_HOME: {}", e);
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                }
            }
            "add" => {
                // Support two forms:
                //   1) /mcp add <name> <command> [args…] [ENV=VAL…]
                //   2) /mcp add <command> [args…] [ENV=VAL…]   (name derived)
                let tail_tokens: Vec<String> = parts.map(|s| s.to_string()).collect();
                if tail_tokens.is_empty() {
                    let msg = "Usage: /mcp add <name> <command> [args…] [ENV=VAL…]\n       or: /mcp add <command> [args…] [ENV=VAL…]".to_string();
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                    return;
                }

                // Helper: derive a reasonable server name from command/args.
                fn derive_server_name(command: &str, tokens: &[String]) -> String {
                    // Prefer an npm-style package token if present.
                    let candidate = tokens
                        .iter()
                        .find(|t| {
                            !t.starts_with('-')
                                && !t.contains('=')
                                && (t.contains('/') || t.starts_with('@'))
                        })
                        .cloned();

                    let mut raw = match candidate {
                        Some(pkg) => {
                            // Strip scope, take the last path segment
                            let after_slash = pkg.rsplit('/').next().unwrap_or(pkg.as_str());
                            // Common convention: server-<name>
                            after_slash
                                .strip_prefix("server-")
                                .unwrap_or(after_slash)
                                .to_string()
                        }
                        None => command.to_string(),
                    };

                    // Sanitize: keep [a-zA-Z0-9_-], map others to '-'
                    raw = raw
                        .chars()
                        .map(|c| {
                            if c.is_ascii_alphanumeric() || c == '_' || c == '-' {
                                c
                            } else {
                                '-'
                            }
                        })
                        .collect();
                    // Collapse multiple '-'
                    let mut out = String::with_capacity(raw.len());
                    let mut prev_dash = false;
                    for ch in raw.chars() {
                        if ch == '-' && prev_dash {
                            continue;
                        }
                        prev_dash = ch == '-';
                        out.push(ch);
                    }
                    // Ensure non-empty; fall back to "server"
                    if out.trim_matches('-').is_empty() {
                        "server".to_string()
                    } else {
                        out.trim_matches('-').to_string()
                    }
                }

                // Parse the two accepted forms
                let (name, command, rest_tokens) = if tail_tokens.len() >= 2 {
                    let first = &tail_tokens[0];
                    let second = &tail_tokens[1];
                    // If the presumed command looks like a flag, assume name was omitted.
                    if second.starts_with('-') {
                        let cmd = first.clone();
                        let name = derive_server_name(&cmd, &tail_tokens[1..].to_vec());
                        (name, cmd, tail_tokens[1..].to_vec())
                    } else {
                        (first.clone(), second.clone(), tail_tokens[2..].to_vec())
                    }
                } else {
                    // Only one token provided — treat it as a command and derive a name.
                    let cmd = tail_tokens[0].clone();
                    let name = derive_server_name(&cmd, &[]);
                    (name, cmd, Vec::new())
                };

                if command.is_empty() {
                    let msg = "Usage: /mcp add <name> <command> [args…] [ENV=VAL…]".to_string();
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                    return;
                }

                // Separate args from ENV=VAL pairs
                let mut args: Vec<String> = Vec::new();
                let mut env: std::collections::HashMap<String, String> =
                    std::collections::HashMap::new();
                for tok in rest_tokens.into_iter() {
                    if let Some((k, v)) = tok.split_once('=') {
                        if !k.is_empty() {
                            env.insert(k.to_string(), v.to_string());
                        }
                    } else {
                        args.push(tok);
                    }
                }
                match find_code_home() {
                    Ok(home) => {
                        let transport = code_core::config_types::McpServerTransportConfig::Stdio {
                            command: command.to_string(),
                            args: args.clone(),
                            env: if env.is_empty() { None } else { Some(env.clone()) },
                        };
                        let cfg = code_core::config_types::McpServerConfig {
                            transport,
                            startup_timeout_sec: None,
                            tool_timeout_sec: None,
                        };
                        match code_core::config::add_mcp_server(&home, &name, cfg.clone()) {
                            Ok(()) => {
                                let summary = Self::format_mcp_summary(&cfg);
                                // Update in-memory config for future sessions
                                self.config.mcp_servers.insert(name.clone(), cfg);
                                let msg = format!("Added MCP server '{}': {}", name, summary);
                                self.push_background_tail(msg);
                            }
                            Err(e) => {
                                let msg = format!("Failed to add MCP server '{}': {}", name, e);
                                self.history_push_plain_state(history_cell::new_error_event(msg));
                            }
                        }
                    }
                    Err(e) => {
                        let msg = format!("Failed to locate CODEX_HOME: {}", e);
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                }
            }
            _ => {
                let msg = format!(
                    "Unknown MCP command: '{}'\nUsage:\n  /mcp status\n  /mcp on <name>\n  /mcp off <name>\n  /mcp add <name> <command> [args…] [ENV=VAL…]",
                    sub
                );
                self.history_push_plain_state(history_cell::new_error_event(msg));
            }
        }
    }

    #[allow(dead_code)]
    fn switch_to_internal_browser(&mut self) {
        // Switch to internal browser mode
        self.browser_is_external = false;
        let latest_screenshot = self.latest_browser_screenshot.clone();
        let app_event_tx = self.app_event_tx.clone();
        let ticket = self.make_background_tail_ticket();

        tokio::spawn(async move {
            let ticket = ticket;
            let browser_manager = ChatWidget::get_browser_manager().await;

            // First, close any existing Chrome connection
            if browser_manager.is_enabled().await {
                let _ = browser_manager.close().await;
            }

            // Configure for internal browser
            {
                let mut config = browser_manager.config.write().await;
                config.connect_port = None;
                config.connect_ws = None;
                config.headless = true;
                config.persist_profile = false;
                config.enabled = true;
            }

            // Enable internal browser
            browser_manager.set_enabled_sync(true);

            // Explicitly (re)start the internal browser session now
            if let Err(e) = browser_manager.start().await {
                tracing::error!("Failed to start internal browser: {}", e);
                app_event_tx
                    .send_background_event_with_ticket(
                        &ticket,
                        format!("❌ Failed to start internal browser: {}", e),
                    );
                return;
            }

            // Set as global manager so core/session share the same instance
            code_browser::global::set_global_browser_manager(browser_manager.clone()).await;

            // Notify about successful switch/reconnect
            app_event_tx.send_background_event_with_ticket(
                &ticket,
                "✅ Switched to internal browser mode (reconnected)".to_string(),
            );

            // Clear any existing screenshot
            if let Ok(mut screenshot) = latest_screenshot.lock() {
                *screenshot = None;
            }

            // Proactively navigate to about:blank, then capture a first screenshot to populate HUD
            let _ = browser_manager.goto("about:blank").await;
            // Capture an initial screenshot to populate HUD
            tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
            match browser_manager.capture_screenshot_with_url().await {
                Ok((paths, url)) => {
                    if let Some(first_path) = paths.first() {
                        if let Ok(mut latest) = latest_screenshot.lock() {
                            *latest = Some((
                                first_path.clone(),
                                url.clone().unwrap_or_else(|| "Browser".to_string()),
                            ));
                        }
                        use code_core::protocol::BrowserScreenshotUpdateEvent;
                        use code_core::protocol::EventMsg;
                        let _ = app_event_tx.send(AppEvent::CodexEvent(Event {
                            id: uuid::Uuid::new_v4().to_string(),
                            event_seq: 0,
                            msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                screenshot_path: first_path.clone(),
                                url: url.unwrap_or_else(|| "Browser".to_string()),
                            }),
                            order: None,
                        }));
                    }
                }
                Err(e) => {
                    tracing::warn!(
                        "Failed to capture initial internal browser screenshot: {}",
                        e
                    );
                }
            }
        });
    }

    fn handle_chrome_connection(
        &mut self,
        host: Option<String>,
        port: Option<u16>,
        ticket: BackgroundOrderTicket,
    ) {
        tracing::info!(
            "[cdp] handle_chrome_connection begin, host={:?}, port={:?}",
            host,
            port
        );
        self.browser_is_external = true;
        let latest_screenshot = self.latest_browser_screenshot.clone();
        let app_event_tx = self.app_event_tx.clone();
        let port_display = port.map_or("auto-detect".to_string(), |p| p.to_string());
        let host_display = host.clone().unwrap_or_else(|| "127.0.0.1".to_string());

        // Add status message to chat (use BackgroundEvent with header so it renders reliably)
        let status_msg = format!(
            "🔗 Connecting to Chrome DevTools Protocol ({}:{})...",
            host_display, port_display
        );
        self.push_background_before_next_output(status_msg);

        // Connect in background with a single, unified flow (no double-connect)
        tokio::spawn(async move {
            tracing::info!(
                "[cdp] connect task spawned, host={:?}, port={:?}",
                host,
                port
            );
            // Unified connect flow; emits success/failure messages internally
            ChatWidget::connect_to_cdp_chrome(
                host,
                port,
                latest_screenshot.clone(),
                app_event_tx.clone(),
                ticket,
            )
            .await;
        });
    }

    pub(crate) fn handle_chrome_command(&mut self, command_text: String) {
        tracing::info!("[cdp] handle_chrome_command start: '{}'", command_text);
        // Parse the chrome command arguments
        let parts: Vec<&str> = command_text.trim().split_whitespace().collect();
        let chrome_ticket = self.make_background_tail_ticket();
        self.consume_pending_prompt_for_ui_only_turn();

        // Handle empty command - just "/chrome"
        if parts.is_empty() || command_text.trim().is_empty() {
            tracing::info!("[cdp] no args provided; toggle connect/disconnect");

            // Toggle behavior: if an external Chrome connection is active, disconnect it.
            // Otherwise, start a connection (auto-detect).
            let (tx, rx) = std::sync::mpsc::channel();
            let app_event_tx = self.app_event_tx.clone();
            let ticket = chrome_ticket.clone();
            tokio::spawn(async move {
                let browser_manager = ChatWidget::get_browser_manager().await;
                // Check if we're currently connected to an external Chrome
                let (is_external, browser_active) = {
                    let cfg = browser_manager.config.read().await;
                    let is_external = cfg.connect_port.is_some() || cfg.connect_ws.is_some();
                    drop(cfg);
                    let status = browser_manager.get_status().await;
                    (is_external, status.browser_active)
                };

                if is_external && browser_active {
                    // Disconnect from external Chrome (do not close Chrome itself)
                    if let Err(e) = browser_manager.stop().await {
                        tracing::warn!("[cdp] failed to stop external Chrome connection: {}", e);
                    }
                    // Notify UI
                    app_event_tx.send_background_event_with_ticket(
                        &ticket,
                        "🔌 Disconnected from Chrome".to_string(),
                    );
                    let _ = tx.send(true);
                } else {
                    // Not connected externally; proceed to connect
                    let _ = tx.send(false);
                }
            });

            // If the async task handled a disconnect, stop here; otherwise connect.
            let handled_disconnect = rx.recv().unwrap_or(false);
            if !handled_disconnect {
                // Switch to external Chrome mode with default/auto-detected port
                self.handle_chrome_connection(None, None, chrome_ticket.clone());
            } else {
                // We just disconnected; reflect in title immediately
                self.browser_is_external = false;
                self.request_redraw();
            }
            return;
        }

        // Check if it's a status command
        if parts[0] == "status" {
            // Get status from BrowserManager - same as /browser status
            let (status_tx, status_rx) = std::sync::mpsc::channel();
            tokio::spawn(async move {
                let browser_manager = ChatWidget::get_browser_manager().await;
                let status = browser_manager.get_status_sync();
                let _ = status_tx.send(status);
            });
            let status = status_rx
                .recv()
                .unwrap_or_else(|_| "Failed to get browser status.".to_string());

            // Add the response to the UI
            let lines: Vec<String> = status.lines().map(|line| line.to_string()).collect();
            self.history_push_plain_paragraphs(PlainMessageKind::Background, lines);
            return;
        }

        // Accept several forms:
        //   /chrome 9222
        //   /chrome host:9222
        //   /chrome host 9222
        //   /chrome ws://host:9222/devtools/browser/<id>
        let mut host: Option<String> = None;
        let mut port: Option<u16> = None;
        let first = parts[0];

        if let Some(ws) = first
            .strip_prefix("ws://")
            .or_else(|| first.strip_prefix("wss://"))
        {
            // Full WS URL provided: set directly via config and return
            let ws_url = if first.starts_with("ws") {
                first.to_string()
            } else {
                format!("wss://{}", ws)
            };
            tracing::info!("[cdp] /chrome provided WS endpoint: {}", ws_url);
            // Configure and connect using WS
            self.browser_is_external = true;
            let latest_screenshot = self.latest_browser_screenshot.clone();
            let app_event_tx = self.app_event_tx.clone();
            tokio::spawn(async move {
                let bm = ChatWidget::get_browser_manager().await;
                {
                    let mut cfg = bm.config.write().await;
                    cfg.enabled = true;
                    cfg.headless = false;
                    cfg.persist_profile = true;
                    cfg.connect_ws = Some(ws_url);
                    cfg.connect_port = None;
                    cfg.connect_host = None;
                }
                let _ = bm.connect_to_chrome_only().await;
                // Capture a first screenshot if possible
                tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
                match bm.capture_screenshot_with_url().await {
                    Ok((paths, url)) => {
                        if let Some(first_path) = paths.first() {
                            if let Ok(mut latest) = latest_screenshot.lock() {
                                *latest = Some((
                                    first_path.clone(),
                                    url.clone().unwrap_or_else(|| "Browser".to_string()),
                                ));
                            }
                            use code_core::protocol::BrowserScreenshotUpdateEvent;
                            use code_core::protocol::EventMsg;
                            let _ = app_event_tx.send(AppEvent::CodexEvent(Event {
                                id: uuid::Uuid::new_v4().to_string(),
                                event_seq: 0,
                                msg: EventMsg::BrowserScreenshotUpdate(
                                    BrowserScreenshotUpdateEvent {
                                        screenshot_path: first_path.clone(),
                                        url: url.unwrap_or_else(|| "Browser".to_string()),
                                    },
                                ),
                                order: None,
                            }));
                        }
                    }
                    Err(e) => {
                        tracing::warn!(
                            "Failed to capture initial external Chrome screenshot: {}",
                            e
                        );
                    }
                }
            });
            return;
        }

        if let Some((h, p)) = first.rsplit_once(':') {
            if let Ok(pn) = p.parse::<u16>() {
                host = Some(h.to_string());
                port = Some(pn);
            }
        }
        if host.is_none() && port.is_none() {
            if let Ok(pn) = first.parse::<u16>() {
                port = Some(pn);
            } else if parts.len() >= 2 {
                if let Ok(pn) = parts[1].parse::<u16>() {
                    host = Some(first.to_string());
                    port = Some(pn);
                }
            }
        }
        tracing::info!("[cdp] parsed host={:?}, port={:?}", host, port);
        self.handle_chrome_connection(host, port, chrome_ticket);
    }

    /// Programmatically submit a user text message as if typed in the
    /// composer. The text will be added to conversation history and sent to
    /// the agent. This also handles slash command expansion.
    pub(crate) fn submit_text_message(&mut self, text: String) {
        if text.is_empty() {
            return;
        }
        self.submit_user_message(text.into());
    }

    /// Submit a message where the user sees `display` in history, but the
    /// model receives only `prompt`. This is used for prompt-expanding
    /// slash commands selected via the popup where expansion happens before
    /// reaching the normal composer pipeline.
    pub(crate) fn submit_prompt_with_display(&mut self, display: String, prompt: String) {
        if display.is_empty() && prompt.is_empty() {
            return;
        }
        use crate::chatwidget::message::UserMessage;
        use code_core::protocol::InputItem;
        let mut ordered = Vec::new();
        if !prompt.trim().is_empty() {
            ordered.push(InputItem::Text { text: prompt });
        }
        let msg = UserMessage {
            display_text: display,
            ordered_items: ordered,
            suppress_persistence: false,
        };
        self.submit_user_message(msg);
    }

    /// Submit a visible text message, but prepend a hidden instruction that is
    /// sent to the agent in the same turn. The hidden text is not added to the
    /// chat history; only `visible` appears to the user.
    pub(crate) fn submit_text_message_with_preface(&mut self, visible: String, preface: String) {
        if visible.is_empty() {
            return;
        }
        use crate::chatwidget::message::UserMessage;
        use code_core::protocol::InputItem;
        let mut ordered = Vec::new();
        if !preface.trim().is_empty() {
            ordered.push(InputItem::Text { text: preface });
        }
        ordered.push(InputItem::Text {
            text: visible.clone(),
        });
        let msg = UserMessage {
            display_text: visible,
            ordered_items: ordered,
            suppress_persistence: false,
        };
        self.submit_user_message(msg);
    }

    fn submit_hidden_text_message_with_preface(&mut self, agent_text: String, preface: String) {
        if agent_text.trim().is_empty() && preface.trim().is_empty() {
            return;
        }
        use crate::chatwidget::message::UserMessage;
        use code_core::protocol::InputItem;

        let mut ordered = Vec::new();
        if !preface.trim().is_empty() {
            ordered.push(InputItem::Text { text: preface });
        }
        if !agent_text.trim().is_empty() {
            ordered.push(InputItem::Text { text: agent_text });
        }

        if ordered.is_empty() {
            return;
        }

        let msg = UserMessage {
            display_text: String::new(),
            ordered_items: ordered,
            suppress_persistence: false,
        };
        self.submit_user_message(msg);
    }

    /// Queue a note that will be delivered to the agent as a hidden system
    /// message immediately before the next user input is sent. Notes are
    /// drained in FIFO order so multiple updates retain their sequencing.
    pub(crate) fn queue_agent_note<S: Into<String>>(&mut self, note: S) {
        let note = note.into();
        if note.trim().is_empty() {
            return;
        }
        self.pending_agent_notes.push(note);
    }

    pub(crate) fn token_usage(&self) -> &TokenUsage {
        &self.total_token_usage
    }

    pub(crate) fn session_id(&self) -> Option<uuid::Uuid> {
        self.session_id
    }

    fn insert_resume_placeholder(&mut self) {
        if self.resume_placeholder_visible {
            return;
        }
        let key = self.next_req_key_top();
        let cell = history_cell::new_background_event(RESUME_PLACEHOLDER_MESSAGE.to_string());
        let _ = self.history_insert_with_key_global_tagged(Box::new(cell), key, "background", None);
        self.resume_placeholder_visible = true;
    }

    fn clear_resume_placeholder(&mut self) {
        if !self.resume_placeholder_visible {
            return;
        }
        if let Some(idx) = self.history_cells.iter().position(|cell| {
            cell.as_any()
                .downcast_ref::<crate::history_cell::BackgroundEventCell>()
                .map(|c| c.state().description.trim() == RESUME_PLACEHOLDER_MESSAGE)
                .unwrap_or(false)
        }) {
            self.history_remove_at(idx);
        }
        self.resume_placeholder_visible = false;
    }

    fn replace_resume_placeholder_with_notice(&mut self, message: &str) {
        if !self.resume_placeholder_visible {
            return;
        }
        self.clear_resume_placeholder();
        self.push_background_tail(message.to_string());
    }

    pub(crate) fn clear_token_usage(&mut self) {
        self.total_token_usage = TokenUsage::default();
        self.rate_limit_snapshot = None;
        self.rate_limit_warnings.reset();
        self.rate_limit_last_fetch_at = None;
        self.bottom_pane.set_token_usage(
            self.total_token_usage.clone(),
            self.last_token_usage.clone(),
            self.config.model_context_window,
        );
    }

    fn log_and_should_display_warning(&self, warning: &RateLimitWarning) -> bool {
        let reset_at = match warning.scope {
            RateLimitWarningScope::Primary => self.rate_limit_primary_next_reset_at,
            RateLimitWarningScope::Secondary => self.rate_limit_secondary_next_reset_at,
        };

        let account_id = auth_accounts::get_active_account_id(&self.config.code_home)
            .ok()
            .flatten()
            .unwrap_or_else(|| "_default".to_string());

        let plan = if account_id == "_default" {
            None
        } else {
            match account_usage::list_rate_limit_snapshots(&self.config.code_home) {
                Ok(records) => records
                    .into_iter()
                    .find(|record| record.account_id == account_id)
                    .and_then(|record| record.plan.clone()),
                Err(err) => {
                    tracing::warn!(?err, "failed to load rate limit snapshots while logging warning");
                    None
                }
            }
        };

        match account_usage::record_rate_limit_warning(
            &self.config.code_home,
            &account_id,
            plan.as_deref(),
            warning.scope,
            warning.threshold,
            reset_at,
            Utc::now(),
            &warning.message,
        ) {
            Ok(result) => result,
            Err(err) => {
                tracing::warn!(?err, "failed to persist rate limit warning log");
                true
            }
        }
    }

    /// Export transcript for buffer-mode mirroring: omit internal sentinels
    /// and include gutter icons and a blank line between items for readability.
    pub(crate) fn export_transcript_lines_for_buffer(&self) -> Vec<ratatui::text::Line<'static>> {
        let mut out: Vec<ratatui::text::Line<'static>> = Vec::new();
        for cell in &self.history_cells {
            out.extend(self.render_lines_for_terminal(cell.as_ref()));
        }
        // Include streaming preview if present (treat like assistant output)
        let mut streaming_lines = self
            .live_builder
            .display_rows()
            .into_iter()
            .map(|r| ratatui::text::Line::from(r.text))
            .collect::<Vec<_>>();
        if !streaming_lines.is_empty() {
            // Apply gutter to streaming preview (first line gets " • ", continuations get 3 spaces)
            if let Some(first) = streaming_lines.first_mut() {
                first.spans.insert(0, ratatui::text::Span::raw(" • "));
            }
            for line in streaming_lines.iter_mut().skip(1) {
                line.spans.insert(0, ratatui::text::Span::raw("   "));
            }
            out.extend(streaming_lines);
            out.push(ratatui::text::Line::from(""));
        }
        out
    }

    /// Render a single history cell into terminal-friendly lines:
    /// - Prepend a gutter icon (symbol + space) to the first line when defined.
    /// - Add a single blank line after the cell as a separator.
    fn render_lines_for_terminal(
        &self,
        cell: &dyn crate::history_cell::HistoryCell,
    ) -> Vec<ratatui::text::Line<'static>> {
        let mut lines = cell.display_lines();
        let _has_icon = cell.gutter_symbol().is_some();
        let first_prefix = if let Some(sym) = cell.gutter_symbol() {
            format!(" {} ", sym) // one space, icon, one space
        } else {
            "   ".to_string() // three spaces when no icon
        };
        if let Some(first) = lines.first_mut() {
            first
                .spans
                .insert(0, ratatui::text::Span::raw(first_prefix));
        }
        // For wrapped/subsequent lines, use a 3-space gutter to maintain alignment
        if lines.len() > 1 {
            for (_idx, line) in lines.iter_mut().enumerate().skip(1) {
                // Always 3 spaces for continuation lines
                line.spans.insert(0, ratatui::text::Span::raw("   "));
            }
        }
        lines.push(ratatui::text::Line::from(""));
        lines
    }

    /// Desired bottom pane height (in rows) for a given terminal width.
    pub(crate) fn desired_bottom_height(&self, width: u16) -> u16 {
        self.bottom_pane.desired_height(width)
    }

    /// The last bottom pane height (rows) that the layout actually used.
    /// If not yet set, fall back to a conservative estimate from BottomPane.

    // (Removed) Legacy in-place reset method. The /new command now creates a fresh
    // ChatWidget (new core session) to ensure the agent context is fully reset.

    pub fn cursor_pos(&self, area: Rect) -> Option<(u16, u16)> {
        // Hide the terminal cursor whenever a top‑level overlay is active so the
        // caret does not show inside the input while a modal (help/diff) is open.
        if self.diffs.overlay.is_some()
            || self.help.overlay.is_some()
            || self.settings.overlay.is_some()
            || self.terminal.overlay().is_some()
            || self.browser_overlay_visible
            || self.agents_terminal.active
        {
            return None;
        }
        let layout_areas = self.layout_areas(area);
        let bottom_pane_area = if layout_areas.len() == 4 {
            layout_areas[3]
        } else {
            layout_areas[2]
        };
        self.bottom_pane.cursor_pos(bottom_pane_area)
    }

    fn measured_font_size(&self) -> (u16, u16) {
        *self.cached_cell_size.get_or_init(|| {
            let size = self.terminal_info.font_size;

            // HACK: On macOS Retina displays, terminals often report physical pixels
            // but ratatui-image expects logical pixels. If we detect suspiciously
            // large cell sizes (likely 2x scaled), divide by 2.
            #[cfg(target_os = "macos")]
            {
                if size.0 >= 14 && size.1 >= 28 {
                    // Likely Retina display reporting physical pixels
                    tracing::info!(
                        "Detected likely Retina display, adjusting cell size from {:?} to {:?}",
                        size,
                        (size.0 / 2, size.1 / 2)
                    );
                    return (size.0 / 2, size.1 / 2);
                }
            }

            size
        })
    }

    fn get_git_branch(&self) -> Option<String> {
        use std::fs;
        use std::path::Path;

        let head_path = self.config.cwd.join(".git/HEAD");
        let mut cache = self.git_branch_cache.borrow_mut();
        let now = Instant::now();

        let needs_refresh = match cache.last_refresh {
            Some(last) => now.duration_since(last) >= Duration::from_millis(500),
            None => true,
        };

        if needs_refresh {
            let modified = fs::metadata(&head_path)
                .and_then(|meta| meta.modified())
                .ok();

            let metadata_changed = cache.last_head_mtime != modified || cache.last_refresh.is_none();

            if metadata_changed {
                cache.value = fs::read_to_string(&head_path)
                    .ok()
                    .and_then(|head_contents| {
                        let head = head_contents.trim();

                        if let Some(rest) = head.strip_prefix("ref: ") {
                            return Path::new(rest)
                                .file_name()
                                .and_then(|s| s.to_str())
                                .filter(|s| !s.is_empty())
                                .map(|name| name.to_string());
                        }

                        if head.len() >= 7
                            && head.as_bytes().iter().all(|byte| byte.is_ascii_hexdigit())
                        {
                            return Some(format!("detached: {}", &head[..7]));
                        }

                        None
                    });
                cache.last_head_mtime = modified;
            }

            cache.last_refresh = Some(now);
        }

        cache.value.clone()
    }

    fn render_status_bar(&self, area: Rect, buf: &mut Buffer) {
        use crate::exec_command::relativize_to_home;
        use ratatui::layout::Margin;
        use ratatui::style::Modifier;
        use ratatui::style::Style;
        use ratatui::text::Line;
        use ratatui::text::Span;
        use ratatui::widgets::Block;
        use ratatui::widgets::Borders;
        use ratatui::widgets::Paragraph;

        // Add same horizontal padding as the Message input (2 chars on each side)
        let horizontal_padding = 1u16;
        let padded_area = Rect {
            x: area.x + horizontal_padding,
            y: area.y,
            width: area.width.saturating_sub(horizontal_padding * 2),
            height: area.height,
        };

        // Get current working directory string
        let cwd_str = match relativize_to_home(&self.config.cwd) {
            Some(rel) if !rel.as_os_str().is_empty() => format!("~/{}", rel.display()),
            Some(_) => "~".to_string(),
            None => self.config.cwd.display().to_string(),
        };

        // Build status line spans with dynamic elision based on width.
        // Removal priority when space is tight:
        //   1) Reasoning level
        //   2) Model
        //   3) Branch
        //   4) Directory
        let branch_opt = self.get_git_branch();

        // Helper to assemble spans based on include flags
        let build_spans = |include_reasoning: bool,
                           include_model: bool,
                           include_branch: bool,
                           include_dir: bool| {
            let mut spans: Vec<Span> = Vec::new();
            // Title follows theme text color
            spans.push(Span::styled(
                "Code",
                Style::default()
                    .fg(crate::colors::text())
                    .add_modifier(Modifier::BOLD),
            ));

            if include_model {
                spans.push(Span::styled(
                    "  •  ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    "Model: ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    self.format_model_name(&self.config.model),
                    Style::default().fg(crate::colors::info()),
                ));
            }

            if include_reasoning {
                spans.push(Span::styled(
                    "  •  ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    "Reasoning: ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    format!("{}", self.config.model_reasoning_effort),
                    Style::default().fg(crate::colors::info()),
                ));
            }

            if include_dir {
                spans.push(Span::styled(
                    "  •  ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    "Directory: ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    cwd_str.clone(),
                    Style::default().fg(crate::colors::info()),
                ));
            }

            if include_branch {
                if let Some(branch) = &branch_opt {
                    spans.push(Span::styled(
                        "  •  ",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                    spans.push(Span::styled(
                        "Branch: ",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                    spans.push(Span::styled(
                        branch.clone(),
                        Style::default().fg(crate::colors::success_green()),
                    ));
                }
            }

            // Footer already shows the Ctrl+R hint; avoid duplicating it here.

            spans
        };

        // Start with all items in production; tests can opt-in to a minimal header via env flag.
        let minimal_header = std::env::var_os("CODEX_TUI_FORCE_MINIMAL_HEADER").is_some();
        let mut include_reasoning = !minimal_header;
        let mut include_model = !minimal_header;
        let mut include_branch = !minimal_header && branch_opt.is_some();
        let mut include_dir = !minimal_header;
        let mut status_spans = build_spans(
            include_reasoning,
            include_model,
            include_branch,
            include_dir,
        );

        // Now recompute exact available width inside the border + padding before measuring
        // Render a bordered status block and explicitly fill its background.
        // Without a background fill, some terminals blend with prior frame
        // contents, which is especially noticeable on dark themes as dark
        // "caps" at the edges. Match the app background for consistency.
        let status_block = Block::default()
            .borders(Borders::ALL)
            .border_style(Style::default().fg(crate::colors::border()))
            .style(Style::default().bg(crate::colors::background()));
        let inner_area = status_block.inner(padded_area);
        let padded_inner = inner_area.inner(Margin::new(1, 0));
        let inner_width = padded_inner.width as usize;

        // Helper to measure current spans width
        let measure =
            |spans: &Vec<Span>| -> usize { spans.iter().map(|s| s.content.chars().count()).sum() };

        // Elide items in priority order until content fits
        while measure(&status_spans) > inner_width {
            if include_reasoning {
                include_reasoning = false;
            } else if include_model {
                include_model = false;
            } else if include_branch {
                include_branch = false;
            } else if include_dir {
                include_dir = false;
            } else {
                break;
            }
            status_spans = build_spans(
                include_reasoning,
                include_model,
                include_branch,
                include_dir,
            );
        }

        // Note: The reasoning visibility hint is appended inside `build_spans`
        // so it participates in width measurement and elision. Do not append
        // it again here to avoid overflow that caused corrupted glyph boxes on
        // some terminals.

        let status_line = Line::from(status_spans);

        let now = Instant::now();
        let mut frame_needed = false;
        if ENABLE_WARP_STRIPES && self.header_wave.schedule_if_needed(now) {
            frame_needed = true;
        }
        if frame_needed {
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(HeaderWaveEffect::FRAME_INTERVAL));
        }

        // Render the block first
        status_block.render(padded_area, buf);
        let wave_enabled = self.header_wave.is_enabled();
        if wave_enabled {
            self.header_wave.render(padded_area, buf, now);
        }

        // Then render the text inside with padding, centered
        let effect_enabled = wave_enabled;
        let status_style = if effect_enabled {
            Style::default().fg(crate::colors::text())
        } else {
            Style::default()
                .bg(crate::colors::background())
                .fg(crate::colors::text())
        };

        let status_widget = Paragraph::new(vec![status_line])
            .alignment(ratatui::layout::Alignment::Center)
            .style(status_style);
        ratatui::widgets::Widget::render(status_widget, padded_inner, buf);
    }

    fn render_screenshot_highlevel(&self, path: &PathBuf, area: Rect, buf: &mut Buffer) {
        use ratatui::widgets::Widget;
        use ratatui_image::Image;
        use ratatui_image::Resize;
        use ratatui_image::picker::Picker;
        use ratatui_image::picker::ProtocolType;

        // First, cheaply read image dimensions without decoding the full image
        let (img_w, img_h) = match image::image_dimensions(path) {
            Ok(dim) => dim,
            Err(_) => {
                self.render_screenshot_placeholder(path, area, buf);
                return;
            }
        };

        // picker (Retina 2x workaround preserved)
        let mut cached_picker = self.cached_picker.borrow_mut();
        if cached_picker.is_none() {
            // If we didn't get a picker from terminal query at startup, create one from font size
            let (fw, fh) = self.measured_font_size();
            let p = Picker::from_fontsize((fw, fh));

            *cached_picker = Some(p);
        }
        let picker = cached_picker.as_ref().unwrap();

        // quantize step by protocol to avoid rounding bias
        let (_qx, _qy): (u16, u16) = match picker.protocol_type() {
            ProtocolType::Halfblocks => (1, 2), // half-block cell = 1 col x 2 half-rows
            _ => (1, 1),                        // pixel protocols (Kitty/iTerm2/Sixel)
        };

        // terminal cell aspect
        let (cw, ch) = self.measured_font_size();
        let cols = area.width as u32;
        let rows = area.height as u32;
        let cw = cw as u32;
        let ch = ch as u32;

        // fit (floor), then choose limiting dimension
        let mut rows_by_w = (cols * cw * img_h) / (img_w * ch);
        if rows_by_w == 0 {
            rows_by_w = 1;
        }
        let mut cols_by_h = (rows * ch * img_w) / (img_h * cw);
        if cols_by_h == 0 {
            cols_by_h = 1;
        }

        let (_used_cols, _used_rows) = if rows_by_w <= rows {
            (cols, rows_by_w)
        } else {
            (cols_by_h, rows)
        };

        // Compute a centered target rect based on image aspect and font cell size
        let (cell_w, cell_h) = self.measured_font_size();
        let area_px_w = (area.width as u32) * (cell_w as u32);
        let area_px_h = (area.height as u32) * (cell_h as u32);
        // If either dimension is zero, bail to placeholder
        if area.width == 0 || area.height == 0 || area_px_w == 0 || area_px_h == 0 {
            self.render_screenshot_placeholder(path, area, buf);
            return;
        }
        let (img_w, img_h) = match image::image_dimensions(path) {
            Ok(dim) => dim,
            Err(_) => {
                self.render_screenshot_placeholder(path, area, buf);
                return;
            }
        };
        let scale_num_w = area_px_w;
        let scale_num_h = area_px_h;
        let scale_w = scale_num_w as f64 / img_w as f64;
        let scale_h = scale_num_h as f64 / img_h as f64;
        let scale = scale_w.min(scale_h).max(0.0);
        // Compute target size in cells
        let target_w_cells = ((img_w as f64 * scale) / (cell_w as f64)).floor() as u16;
        let target_h_cells = ((img_h as f64 * scale) / (cell_h as f64)).floor() as u16;
        let target_w = target_w_cells.clamp(1, area.width);
        let target_h = target_h_cells.clamp(1, area.height);
        let target_x = area.x + (area.width.saturating_sub(target_w)) / 2;
        let target_y = area.y + (area.height.saturating_sub(target_h)) / 2;
        let target = Rect {
            x: target_x,
            y: target_y,
            width: target_w,
            height: target_h,
        };

        // cache by (path, target)
        let needs_recreate = {
            let cached = self.cached_image_protocol.borrow();
            match cached.as_ref() {
                Some((cached_path, cached_rect, _)) => {
                    cached_path != path || *cached_rect != target
                }
                None => true,
            }
        };
        if needs_recreate {
            // Only decode when we actually need to (path/target changed)
            let dyn_img = match image::ImageReader::open(path) {
                Ok(r) => match r.decode() {
                    Ok(img) => img,
                    Err(_) => {
                        self.render_screenshot_placeholder(path, area, buf);
                        return;
                    }
                },
                Err(_) => {
                    self.render_screenshot_placeholder(path, area, buf);
                    return;
                }
            };
            match picker.new_protocol(dyn_img, target, Resize::Fit(Some(FilterType::Lanczos3))) {
                Ok(protocol) => {
                    *self.cached_image_protocol.borrow_mut() =
                        Some((path.clone(), target, protocol))
                }
                Err(_) => {
                    self.render_screenshot_placeholder(path, area, buf);
                    return;
                }
            }
        }

        if let Some((_, rect, protocol)) = &*self.cached_image_protocol.borrow() {
            let image = Image::new(protocol);
            Widget::render(image, *rect, buf);
        } else {
            self.render_screenshot_placeholder(path, area, buf);
        }
    }

    fn render_screenshot_placeholder(&self, path: &PathBuf, area: Rect, buf: &mut Buffer) {
        use ratatui::style::Modifier;
        use ratatui::style::Style;
        use ratatui::widgets::Block;
        use ratatui::widgets::Borders;
        use ratatui::widgets::Paragraph;

        // Show a placeholder box with screenshot info
        let filename = path
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("screenshot");

        let placeholder_text = format!("[Screenshot]\n{}", filename);
        let placeholder_widget = Paragraph::new(placeholder_text)
            .block(
                Block::default()
                    .borders(Borders::ALL)
                    .border_style(Style::default().fg(crate::colors::info()))
                    .title("Browser"),
            )
            .style(
                Style::default()
                    .fg(crate::colors::text_dim())
                    .add_modifier(Modifier::ITALIC),
            )
            .wrap(ratatui::widgets::Wrap { trim: true });

        placeholder_widget.render(area, buf);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::{
        CAPTURE_AUTO_TURN_COMMIT_STUB,
        GIT_DIFF_NAME_ONLY_BETWEEN_STUB,
    };
    use crate::bottom_pane::AutoCoordinatorViewModel;
    use crate::chatwidget::message::UserMessage;
    use crate::chatwidget::smoke_helpers::ChatWidgetHarness;
    use crate::history_cell::{self, ExploreAggregationCell, HistoryCellType};
    use code_auto_drive_core::{
        AutoContinueMode,
        AutoRunPhase,
        AutoRunSummary,
        TurnComplexity,
        TurnMode,
        AUTO_RESOLVE_MAX_REVIEW_ATTEMPTS,
    };
    use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
    use code_core::history::state::{
        AssistantStreamDelta,
        AssistantStreamState,
        HistoryId,
        HistoryRecord,
        HistorySnapshot,
        HistoryState,
        InlineSpan,
        MessageLine,
        MessageLineKind,
        OrderKeySnapshot,
        PlainMessageKind,
        PlainMessageRole,
        PlainMessageState,
        TextEmphasis,
        TextTone,
    };
    use code_core::parse_command::ParsedCommand;
    use code_core::protocol::OrderMeta;
    use code_core::protocol::{
        AskForApproval,
        AgentMessageEvent,
        AgentStatusUpdateEvent,
        Event,
        EventMsg,
        ExecCommandBeginEvent,
        TaskCompleteEvent,
    };
    use code_core::protocol::AgentInfo as CoreAgentInfo;
    use ratatui::backend::TestBackend;
    use ratatui::text::Line;
    use ratatui::Terminal;
    use std::collections::HashMap;
    use std::time::{Duration, SystemTime};
    use std::path::PathBuf;

    use code_core::protocol::{ReviewFinding, ReviewCodeLocation, ReviewLineRange};

    struct CaptureCommitStubGuard;

    impl CaptureCommitStubGuard {
        fn install<F>(stub: F) -> Self
        where
            F: Fn(&'static str, Option<String>) -> Result<GhostCommit, GitToolingError>
                + Send
                + Sync
                + 'static,
        {
            let mut slot = match CAPTURE_AUTO_TURN_COMMIT_STUB.lock() {
                Ok(guard) => guard,
                Err(poisoned) => poisoned.into_inner(),
            };
            assert!(slot.is_none(), "capture stub already installed");
            *slot = Some(Box::new(stub));
            Self
        }
    }

    impl Drop for CaptureCommitStubGuard {
        fn drop(&mut self) {
            match CAPTURE_AUTO_TURN_COMMIT_STUB.lock() {
                Ok(mut slot) => *slot = None,
                Err(poisoned) => {
                    let mut slot = poisoned.into_inner();
                    *slot = None;
                }
            }
        }
    }

    struct GitDiffStubGuard;

    impl GitDiffStubGuard {
        fn install<F>(stub: F) -> Self
        where
            F: Fn(String, String) -> Result<Vec<String>, String> + Send + Sync + 'static,
        {
            let mut slot = match GIT_DIFF_NAME_ONLY_BETWEEN_STUB.lock() {
                Ok(guard) => guard,
                Err(poisoned) => poisoned.into_inner(),
            };
            assert!(slot.is_none(), "git diff stub already installed");
            *slot = Some(Box::new(stub));
            Self
        }
    }

    impl Drop for GitDiffStubGuard {
        fn drop(&mut self) {
            match GIT_DIFF_NAME_ONLY_BETWEEN_STUB.lock() {
                Ok(mut slot) => *slot = None,
                Err(poisoned) => {
                    let mut slot = poisoned.into_inner();
                    *slot = None;
                }
            }
        }
    }

    fn reset_history(chat: &mut ChatWidget<'_>) {
        chat.history_cells.clear();
        chat.history_cell_ids.clear();
        chat.history_state = HistoryState::new();
        chat.history_render.invalidate_all();
        chat.cell_order_seq.clear();
        chat.cell_order_dbg.clear();
        chat.ui_background_seq_counters.clear();
        chat.last_assigned_order = None;
        chat.last_seen_request_index = 0;
        chat.current_request_index = 0;
        chat.internal_seq = 0;
        chat.order_request_bias = 0;
        chat.resume_expected_next_request = None;
        chat.resume_provider_baseline = None;
        chat.synthetic_system_req = None;
        chat.layout.scroll_offset = 0;
        chat.layout.last_max_scroll.set(0);
        chat.layout.last_history_viewport_height.set(0);
    }

    fn insert_plain_cell(chat: &mut ChatWidget<'_>, lines: &[&str]) {
        use code_core::history::state::{
            InlineSpan,
            MessageLine,
            MessageLineKind,
            PlainMessageKind,
            PlainMessageRole,
            PlainMessageState,
            TextEmphasis,
            TextTone,
        };

        let state = PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::System,
            kind: PlainMessageKind::Plain,
            header: None,
            lines: lines
                .iter()
                .map(|text| MessageLine {
                    kind: MessageLineKind::Paragraph,
                    spans: vec![InlineSpan {
                        text: (*text).to_string(),
                        tone: TextTone::Default,
                        emphasis: TextEmphasis::default(),
                        entity: None,
                    }],
                })
                .collect(),
            metadata: None,
        };

        let key = chat.next_internal_key();
        let _ = chat.history_insert_plain_state_with_key(state, key, "test");
    }

    fn make_pending_fix_state(review: ReviewOutputEvent) -> AutoResolveState {
        AutoResolveState {
            prompt: "prompt".to_string(),
            hint: "hint".to_string(),
            metadata: None,
            attempt: 0,
            max_attempts: AUTO_RESOLVE_MAX_REVIEW_ATTEMPTS,
            phase: AutoResolvePhase::PendingFix { review },
            last_review: None,
            last_fix_message: None,
        }
    }

    #[allow(dead_code)]
    fn review_output_with_finding() -> ReviewOutputEvent {
        ReviewOutputEvent {
            findings: vec![ReviewFinding {
                title: "issue".to_string(),
                body: "details".to_string(),
                confidence_score: 0.5,
                priority: 0,
                code_location: ReviewCodeLocation {
                    absolute_file_path: PathBuf::from("src/lib.rs"),
                    line_range: ReviewLineRange { start: 1, end: 1 },
                },
            }],
            overall_correctness: "incorrect".to_string(),
            overall_explanation: "needs fixes".to_string(),
            overall_confidence_score: 0.5,
        }
    }

    #[test]
    fn esc_router_prioritizes_auto_stop_when_waiting_for_review() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.on_begin_review(false);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoStopActive);
        assert!(!route.allows_double_esc);
    }

    #[test]
    fn esc_router_prioritizes_agent_cancel_before_cli_interrupt() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });
        chat.bottom_pane.set_task_running(true);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
    }

    #[test]
    fn esc_requires_follow_up_after_canceling_agents() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.auto_state.is_active(), "Auto Drive remains active until follow-up Esc");
        assert!(chat
            .active_agents
            .iter()
            .all(|agent| matches!(agent.status, AgentStatus::Cancelled)));
        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoStopActive);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(!chat.auto_state.is_active());
        assert!(chat.auto_state.last_run_summary.is_none());
    }

    #[test]
    fn cancel_agents_preserves_spinner_for_running_terminal_when_auto_inactive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let terminal_launch = TerminalLaunch {
            id: 42,
            title: "Terminal".to_string(),
            command: vec!["sleep".to_string(), "10".to_string()],
            command_display: "sleep 10".to_string(),
            controller: None,
            auto_close_on_success: false,
            start_running: true,
        };
        chat.terminal_open(&terminal_launch);

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        let mut route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::DismissModal);
        let mut attempts = 0;
        while route.intent == EscIntent::DismissModal && attempts < 3 {
            assert!(chat.execute_esc_intent(
                route.intent,
                KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE),
            ));
            route = chat.describe_esc_context();
            attempts += 1;
        }

        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(
            route.intent,
            KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE),
        ));

        assert!(!chat.auto_state.is_active(), "Auto Drive remains inactive");
        assert!(chat
            .active_agents
            .iter()
            .all(|agent| matches!(agent.status, AgentStatus::Cancelled)));
        chat.maybe_hide_spinner();
        assert!(
            !chat.bottom_pane.is_task_running(),
            "Spinner now clears once overlays dismiss and no other work remains",
        );
    }

    #[test]
    fn esc_cancels_agents_then_command_and_stops_auto_drive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        chat.exec.running_commands.insert(
            ExecCallId("exec-1".to_string()),
            RunningCommand {
                command: vec!["echo".to_string(), "hi".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout: String::new(),
                stderr: String::new(),
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(route.intent, esc_event));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(!chat.auto_state.is_active(), "Auto Drive should stop after cancelling the command");
        assert!(chat.auto_state.last_run_summary.is_none());

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
    }

    #[allow(dead_code)]
    fn esc_cancels_agents_then_command_without_auto_hint() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        chat.exec.running_commands.insert(
            ExecCallId("exec-1".to_string()),
            RunningCommand {
                command: vec!["echo".to_string(), "hi".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout: String::new(),
                stderr: String::new(),
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat
            .active_agents
            .iter()
            .all(|agent| matches!(agent.status, AgentStatus::Cancelled)));
        assert!(
            chat.bottom_pane.standard_terminal_hint().is_none(),
            "Auto Drive exit hint should not display when Auto Drive is inactive",
        );

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.exec.running_commands.is_empty());
        assert!(!chat.bottom_pane.is_task_running());
    }

    #[test]
    fn auto_disabled_cli_turn_preserves_send_prompt_label() {
        let mut harness = ChatWidgetHarness::new();
        harness.with_chat(|chat| {
            chat.config.auto_drive.coordinator_routing = false;
            chat.auto_state.continue_mode = AutoContinueMode::Immediate;
            chat.auto_state.goal = Some("Ship feature".to_string());
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.schedule_auto_cli_prompt("echo ready".to_string());
        });

        let (button_label, countdown_override, ctrl_switch_hint, manual_hint_present) =
            harness.with_chat(|chat| {
                let model = chat
                    .bottom_pane
                    .auto_view_model()
                    .expect("auto coordinator view should be active");
                match model {
                    AutoCoordinatorViewModel::Active(active) => (
                        active
                            .button
                            .as_ref()
                            .expect("button expected")
                            .label
                            .clone(),
                        chat.auto_state.countdown_override,
                        active.ctrl_switch_hint.clone(),
                        active.manual_hint.is_some(),
                    ),
                }
            });

        assert!(button_label.starts_with("Send prompt"));
        assert_eq!(countdown_override, None);
        assert_eq!(ctrl_switch_hint.as_str(), "Esc to edit");
        assert!(manual_hint_present);

        harness.with_chat(|chat| {
            chat.auto_submit_prompt();
        });

        let auto_pending = harness.with_chat(|chat| chat.auto_pending_goal_request);
        assert!(!auto_pending);
    }

    #[test]
    fn auto_bootstrap_starts_from_history() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.config.auto_drive.coordinator_routing = false;
            chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;
            chat.config.approval_policy = AskForApproval::Never;
        }

        {
            let chat = harness.chat();
            insert_plain_cell(chat, &["User: summarize recent progress"]);
            insert_plain_cell(chat, &["Assistant: Tests are passing, next step pending."]);
            chat.handle_auto_command(Some(String::new()));
        }

        let chat = harness.chat();
        assert!(chat.auto_pending_goal_request);
        assert!(!chat.auto_goal_bootstrap_done);
        assert_eq!(
            chat.auto_state.goal.as_deref(),
            Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER)
        );
        assert!(chat.next_cli_text_format.is_none());
        let pending_prompt = chat
            .auto_state
            .current_cli_prompt
            .as_deref()
            .expect("bootstrap prompt");
        assert!(pending_prompt.trim().is_empty());
    }

    #[test]
    fn auto_bootstrap_updates_goal_after_first_decision() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string());
            chat.auto_goal_bootstrap_done = false;
        }

        {
            let chat = harness.chat();
        chat.auto_handle_decision(
            AutoCoordinatorStatus::Continue,
            None,
            None,
            Some("Finish migrations".to_string()),
            Some(AutoTurnCliAction {
                prompt: "echo ready".to_string(),
                context: None,
            }),
            None,
            Vec::new(),
            Vec::new(),
            None,
            None,
        );
        }

        let chat = harness.chat();
        assert_eq!(chat.auto_state.goal.as_deref(), Some("Finish migrations"));
        assert!(chat.auto_goal_bootstrap_done);
        assert!(!chat.auto_pending_goal_request);
        assert_eq!(chat.auto_state.current_cli_prompt.as_deref(), Some("echo ready"));
    }

    #[test]
    fn auto_card_goal_updates_after_derivation() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string());
            chat.auto_card_start(Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string()));
        }

        {
            let chat = harness.chat();
            chat.auto_handle_decision(
                AutoCoordinatorStatus::Continue,
                None,
                None,
                Some("Document release tasks".to_string()),
                Some(AutoTurnCliAction {
                    prompt: "echo start".to_string(),
                    context: None,
                }),
                None,
                Vec::new(),
                Vec::new(),
            );
        }

        let chat = harness.chat();
        let tracker = chat
            .tools_state
            .auto_drive_tracker
            .as_ref()
            .expect("auto drive tracker should be present");
        assert_eq!(tracker.cell.goal_text(), Some("Document release tasks"));
    }

    #[test]
    fn auto_card_shows_progress_current_in_state_detail() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some("Ship feature".to_string());
            chat.auto_card_start(Some("Ship feature".to_string()));
        }

        {
            let chat = harness.chat();
            chat.auto_handle_decision(
                AutoCoordinatorStatus::Continue,
                Some("Past work".to_string()),
                Some("Drafting fix".to_string()),
                None,
                Some(AutoTurnCliAction {
                    prompt: "echo work".to_string(),
                    context: None,
                }),
                None,
                Vec::new(),
                Vec::new(),
            );
        }

        let chat = harness.chat();
        let tracker = chat
            .tools_state
            .auto_drive_tracker
            .as_ref()
            .expect("auto drive tracker should be present");
        let actions = tracker.cell.action_texts();
        assert!(actions.iter().any(|text| text == "Progress: Drafting fix"));
    }

    #[test]
    fn goal_entry_esc_sequence_preserves_draft_and_summary() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.last_run_summary = Some(AutoRunSummary {
            duration: Duration::from_secs(42),
            turns_completed: 3,
            message: Some("All tasks done.".to_string()),
            goal: Some("Finish feature".to_string()),
        });
        chat.auto_show_goal_entry_panel();
        chat.handle_paste("Suggested goal".to_string());
        assert!(matches!(
            chat.auto_goal_escape_state,
            AutoGoalEscState::NeedsEnableEditing
        ));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalEnableEdit);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.auto_state.should_show_goal_entry());
        assert!(matches!(
            chat.auto_goal_escape_state,
            AutoGoalEscState::ArmedForExit
        ));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(!chat.auto_state.should_show_goal_entry());
        assert_eq!(chat.bottom_pane.composer_text(), "Suggested goal");
        assert!(chat.auto_state.last_run_summary.is_some());

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoDismissSummary);
    }

    #[test]
    fn goal_entry_typing_arms_escape_state() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_show_goal_entry_panel();
        }

        harness.send_key(KeyEvent::new(KeyCode::Char('x'), KeyModifiers::NONE));

        let chat = harness.chat();
        assert!(matches!(
            chat.auto_goal_escape_state,
            AutoGoalEscState::NeedsEnableEditing
        ));
        assert_eq!(chat.bottom_pane.composer_text(), "x");
    }

    #[test]
    fn goal_entry_esc_exits_immediately_without_suggestion() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_show_goal_entry_panel();
        assert!(chat.auto_state.should_show_goal_entry());
        assert!(matches!(chat.auto_goal_escape_state, AutoGoalEscState::Inactive));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
        assert!(chat.execute_esc_intent(route.intent, esc_event));

        assert!(!chat.auto_state.should_show_goal_entry());
        assert_eq!(chat.bottom_pane.composer_text(), "");
    }

    #[test]
    fn esc_unwinds_cli_before_stopping_auto() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        let call_id = ExecCallId("exec-1".to_string());
        chat.exec.running_commands.insert(
            call_id.clone(),
            RunningCommand {
                command: vec!["echo".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout: String::new(),
                stderr: String::new(),
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(
            !chat.auto_state.is_active(),
            "Auto Drive now stops immediately after cancelling the CLI task",
        );

        chat.exec.running_commands.clear();
        chat.bottom_pane.set_task_running(false);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
    }

    #[test]
    fn esc_router_cancels_running_task() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.bottom_pane.set_task_running(true);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
    }

    #[test]
    fn esc_cancel_task_while_manual_command_does_not_trigger_auto_drive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.exec.running_commands.insert(
            ExecCallId("exec-1".to_string()),
            RunningCommand {
                command: vec!["echo".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout: String::new(),
                stderr: String::new(),
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(
            !chat.auto_state.is_active(),
            "Auto Drive should remain inactive after cancelling manual command",
        );
        assert!(
            chat.auto_state.last_run_summary.is_none(),
            "Cancelling manual command should not create an Auto Drive summary",
        );
    }

    #[test]
    fn esc_router_handles_diff_confirm_prompt() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.diffs.confirm = Some(crate::chatwidget::diff_ui::DiffConfirm {
            text_to_submit: "Please undo".to_string(),
        });

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::DiffConfirm);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.diffs.confirm.is_none(), "diff confirm should clear after Esc");
    }

    #[test]
    fn esc_router_handles_agents_terminal_overlay() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.agents_terminal.active = true;
        chat.agents_terminal.focus_detail();

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AgentsTerminal);
    }

    #[test]
    fn esc_router_clears_manual_entry_input() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_show_goal_entry_panel();
        assert!(chat.auto_state.should_show_goal_entry());
        chat.bottom_pane.insert_str("draft goal");

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
    }

    #[test]
    fn esc_router_defaults_to_show_hint_when_idle() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::ShowUndoHint);
        assert!(route.allows_double_esc);
    }

    #[test]
    fn reasoning_collapse_hides_intermediate_titles_after_agent_anchor() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.show_reasoning = false;

        let agent_cell = history_cell::AgentRunCell::new("Batch".to_string());
        chat.history_push(agent_cell);

        let reasoning_one = history_cell::CollapsibleReasoningCell::new_with_id(
            vec![Line::from("First reasoning".to_string())],
            Some("r1".to_string()),
        );
        let reasoning_two = history_cell::CollapsibleReasoningCell::new_with_id(
            vec![Line::from("Second reasoning".to_string())],
            Some("r2".to_string()),
        );

        chat.history_push(reasoning_one);
        chat.history_push(reasoning_two);

        chat.refresh_reasoning_collapsed_visibility();

        let reasoning_cells: Vec<&history_cell::CollapsibleReasoningCell> = chat
            .history_cells
            .iter()
            .filter_map(|cell| {
                cell.as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            })
            .collect();

        assert_eq!(reasoning_cells.len(), 2, "expected exactly two reasoning cells");

        assert!(
            reasoning_cells[0].display_lines().is_empty(),
            "intermediate reasoning should hide when collapsed after agent anchor",
        );
        assert!(
            !reasoning_cells[1].display_lines().is_empty(),
            "last reasoning should remain visible",
        );
    }

    #[test]
    fn auto_drive_stays_paused_while_auto_resolve_pending_fix() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.on_prompt_submitted();
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_complete_review();
        chat.auto_state.set_waiting_for_response(true);
        chat.pending_turn_descriptor = None;
        chat.pending_auto_turn_config = None;
        chat.auto_resolve_state = Some(make_pending_fix_state(ReviewOutputEvent::default()));

        chat.auto_on_assistant_final();

        // With cloud-gpt-5-codex gated off, the review request is still queued but
        // may be processed synchronously; ensure the review slot was populated.
        if chat.auto_state.awaiting_review() {
            // Review remains pending; nothing else to assert.
        } else {
            assert!(chat.auto_state.current_cli_prompt.is_some());
        }
        assert!(!chat.auto_state.is_waiting_for_response());
    }

    #[test]
    fn auto_review_skip_resumes_auto_drive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let _stub_lock = AUTO_STUB_LOCK.lock().unwrap();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_prompt_submitted();
        chat.auto_state.set_waiting_for_response(true);
        chat.auto_state.on_complete_review();
        chat.auto_state.set_waiting_for_response(true);

        let turn_config = TurnConfig {
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            text_format_override: None,
        };
        chat.pending_auto_turn_config = Some(turn_config.clone());
        chat.pending_turn_descriptor = Some(TurnDescriptor {
            mode: TurnMode::Normal,
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            agent_preferences: None,
            review_strategy: None,
            text_format_override: None,
        });

        let base_id = "base-commit".to_string();
        let final_id = "final-commit".to_string();

        chat.auto_turn_review_state = Some(AutoTurnReviewState {
            base_commit: Some(GhostCommit::new(base_id.clone(), None)),
        });

        let base_for_capture = base_id.clone();
        let final_for_capture = final_id.clone();
        let _capture_guard = CaptureCommitStubGuard::install(move |message, parent| {
            assert_eq!(message, "auto turn change snapshot");
            assert_eq!(parent.as_deref(), Some(base_for_capture.as_str()));
            Ok(GhostCommit::new(final_for_capture.clone(), parent))
        });

        let base_for_diff = base_id.clone();
        let final_for_diff = final_id.clone();
        let _diff_guard = GitDiffStubGuard::install(move |base, head| {
            assert_eq!(base, base_for_diff);
            assert_eq!(head, final_for_diff);
            Ok(Vec::new())
        });

        let initial_history_len = chat.auto_history.raw_snapshot().len();

        chat.auto_on_assistant_final();
        assert!(chat.auto_state.awaiting_review(), "post-turn review should be pending");

        let descriptor_snapshot = chat.pending_turn_descriptor.clone();
        chat.auto_handle_post_turn_review(turn_config.clone(), descriptor_snapshot.as_ref());

        assert!(
            !chat.auto_state.awaiting_review(),
            "auto drive should clear waiting flag after skipped review"
        );

        let skip_banner = "Auto review skipped: no file changes detected this turn.";
        let skip_present = chat.history_cells.iter().any(|cell| {
            cell.display_lines_trimmed().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.contains(skip_banner))
            })
        });
        assert!(skip_present, "skip banner should appear in history");

        let final_history_len = chat.auto_history.raw_snapshot().len();
        assert!(
            chat.auto_state.is_waiting_for_response()
                || final_history_len > initial_history_len,
            "auto drive should resume conversation after skipped review"
        );
    }

    #[test]
    fn auto_review_skip_stays_blocked_when_auto_resolve_pending() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let _stub_lock = AUTO_STUB_LOCK.lock().unwrap();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_prompt_submitted();
        chat.auto_state.on_complete_review();
        chat.auto_state.set_waiting_for_response(true);

        let turn_config = TurnConfig {
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            text_format_override: None,
        };
        chat.pending_auto_turn_config = Some(turn_config.clone());
        chat.pending_turn_descriptor = Some(TurnDescriptor {
            mode: TurnMode::Normal,
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            agent_preferences: None,
            review_strategy: None,
            text_format_override: None,
        });

        let base_id = "base-commit".to_string();
        let final_id = "final-commit".to_string();

        chat.auto_turn_review_state = Some(AutoTurnReviewState {
            base_commit: Some(GhostCommit::new(base_id.clone(), None)),
        });

        chat.auto_resolve_state = Some(make_pending_fix_state(ReviewOutputEvent::default()));

        let base_for_capture = base_id.clone();
        let final_for_capture = final_id.clone();
        let _capture_guard = CaptureCommitStubGuard::install(move |message, parent| {
            assert_eq!(message, "auto turn change snapshot");
            assert_eq!(parent.as_deref(), Some(base_for_capture.as_str()));
            Ok(GhostCommit::new(final_for_capture.clone(), parent))
        });

        let base_for_diff = base_id.clone();
        let final_for_diff = final_id.clone();
        let _diff_guard = GitDiffStubGuard::install(move |base, head| {
            assert_eq!(base, base_for_diff);
            assert_eq!(head, final_for_diff);
            Ok(Vec::new())
        });

        chat.auto_on_assistant_final();
        assert!(chat.auto_state.awaiting_review(), "auto-resolve should block resume before skip");

        let descriptor_snapshot = chat.pending_turn_descriptor.clone();
        chat.auto_handle_post_turn_review(turn_config.clone(), descriptor_snapshot.as_ref());

        assert!(
            chat.auto_state.awaiting_review(),
            "auto drive should remain waiting when auto-resolve blocks"
        );
        assert!(
            !chat.auto_state.is_waiting_for_response(),
            "skip should not resume coordinator when auto-resolve blocks"
        );
    }

    #[test]
    fn auto_handle_decision_launches_cli_agents_and_review() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;

        chat.auto_handle_decision(
            AutoCoordinatorStatus::Continue,
            Some("Finished setup".to_string()),
            Some("Running unit tests".to_string()),
            Some("Refine goal".to_string()),
            Some(AutoTurnCliAction {
                prompt: "Run cargo test".to_string(),
                context: Some("use --all-features".to_string()),
            }),
            Some(AutoTurnAgentsTiming::Parallel),
            vec![AutoTurnAgentsAction {
                prompt: "Draft alternative fix".to_string(),
                context: None,
                write: false,
                write_requested: Some(false),
                models: None,
            }],
            Vec::new(),
            None,
            None,
        );

        assert_eq!(
            chat.auto_state.current_cli_prompt.as_deref(),
            Some("Run cargo test")
        );
        assert!(!chat.auto_state.awaiting_review());
        assert_eq!(chat.auto_state.pending_agent_actions.len(), 1);
        assert_eq!(
            chat.auto_state.pending_agent_timing,
            Some(AutoTurnAgentsTiming::Parallel)
        );
        let action = &chat.auto_state.pending_agent_actions[0];
        assert_eq!(action.prompt, "Draft alternative fix");
        assert!(action.write);

        let notice = "Auto Drive enabled write mode";
        let write_notice_present = chat
            .history_cells
            .iter()
            .any(|cell| {
                cell.display_lines_trimmed().iter().any(|line| {
                    line.spans
                        .iter()
                        .any(|span| span.content.contains(notice))
                })
            });
        assert!(write_notice_present);
    }

    #[test]
    fn coordinator_router_emits_notice_for_status_question() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
        chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.config.auto_drive.coordinator_routing = true;
            chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;
        }

        let baseline_notice_count = {
            let chat = harness.chat();
            chat.history_cells
                .iter()
                .filter(|cell| matches!(cell.kind(), HistoryCellType::Notice))
                .count()
        };

        {
            let chat = harness.chat();
            chat.auto_handle_user_reply(
                Some("Two active agents reporting steady progress.".to_string()),
                None,
            );
        }

        let notice_count = {
            let chat = harness.chat();
            chat.history_cells
                .iter()
                .filter(|cell| matches!(cell.kind(), HistoryCellType::Notice))
                .count()
        };
        assert!(notice_count > baseline_notice_count);

        let header_span = {
            let chat = harness.chat();
            let notice_cell = chat
                .history_cells
                .iter()
                .rev()
                .find(|cell| matches!(cell.kind(), HistoryCellType::Notice))
                .expect("notice cell");
            let lines = notice_cell.display_lines_trimmed();
            assert!(!lines.is_empty());
            lines
                .first()
                .and_then(|line| line.spans.first())
                .map(|span| span.content.to_string())
                .unwrap_or_default()
        };
        assert_eq!(header_span, "AUTO DRIVE RESPONSE");
    }

    #[test]
    fn coordinator_router_injects_cli_for_plan_requests() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
        chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.config.auto_drive.coordinator_routing = true;
            chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;
        }

        harness.drain_events();

        {
            let chat = harness.chat();
            chat.auto_handle_user_reply(None, Some("/plan".to_string()));
        }

        let events = harness.drain_events();
        let (command, payload) = events
            .iter()
            .find_map(|event| match event {
                AppEvent::DispatchCommand(cmd, payload) => Some((cmd, payload.clone())),
                _ => None,
            })
            .expect("dispatch for /plan");
        assert_eq!(*command, SlashCommand::Auto);
        assert!(payload.contains("/plan"), "payload={payload}");
    }

    #[test]
    fn coordinator_router_bypasses_slash_commands() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
        chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.config.auto_drive.coordinator_routing = true;
        }

        harness.drain_events();
        {
            let chat = harness.chat();
            chat.submit_user_message(UserMessage::from("/status".to_string()));
        }

        let events = harness.drain_events();
        assert!(
            events.iter().any(|event| matches!(event, AppEvent::DispatchCommand(_, _))
                || matches!(event, AppEvent::CodexOp(_))),
            "slash command should follow existing dispatch path"
        );
    }

    #[test]
    fn build_turn_message_includes_agent_guidance() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.subagents_enabled = true;
        chat.auto_state.pending_agent_actions = vec![AutoTurnAgentsAction {
            prompt: "Draft alternative fix".to_string(),
            context: Some("Focus on parser module".to_string()),
            write: false,
            write_requested: Some(false),
            models: Some(vec![
                "claude-sonnet-4.5".to_string(),
                "gemini-2.5-pro".to_string(),
            ]),
        }];
        chat.auto_state.pending_agent_timing = Some(AutoTurnAgentsTiming::Blocking);

        chat.auto_state.current_cli_context = Some("Workspace root: /tmp".to_string());

        let message = chat
            .build_auto_turn_message("Run diagnostics")
            .expect("message");
        assert!(message.contains("Workspace root: /tmp"));
        assert!(message.contains("Run diagnostics"));
        assert!(message.contains("Please run agent.create"));
        assert!(message.contains("write: false"));
        assert!(message.contains("Models: [claude-sonnet-4.5, gemini-2.5-pro]"));
        assert!(message.contains("Draft alternative fix"));
        assert!(message.contains("Focus on parser module"));
        assert!(message.contains("agent.wait"));
        assert!(message.contains("Timing (blocking)"));
        assert!(message.contains("Launch these agents first"));
        assert!(!message.contains("agent {\"action\""), "message should not include raw agent JSON");
    }

    #[test]
    fn task_complete_triggers_review_when_waiting_flag_set() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let _stub_lock = AUTO_STUB_LOCK.lock().unwrap();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_prompt_submitted();

        let turn_config = TurnConfig {
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            text_format_override: None,
        };
        chat.pending_auto_turn_config = Some(turn_config.clone());
        chat.pending_turn_descriptor = Some(TurnDescriptor {
            mode: TurnMode::Normal,
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            agent_preferences: None,
            review_strategy: None,
            text_format_override: None,
        });

        let base_id = "base-commit".to_string();
        let final_id = "final-commit".to_string();

        chat.auto_turn_review_state = Some(AutoTurnReviewState {
            base_commit: Some(GhostCommit::new(base_id.clone(), None)),
        });

        let base_for_capture = base_id.clone();
        let final_for_capture = final_id.clone();
        let _capture_guard = CaptureCommitStubGuard::install(move |message, parent| {
            assert_eq!(message, "auto turn change snapshot");
            assert_eq!(parent.as_deref(), Some(base_for_capture.as_str()));
            Ok(GhostCommit::new(final_for_capture.clone(), parent))
        });

        let base_for_diff = base_id.clone();
        let final_for_diff = final_id.clone();
        let _diff_guard = GitDiffStubGuard::install(move |base, head| {
            assert_eq!(base, base_for_diff);
            assert_eq!(head, final_for_diff);
            Ok(Vec::new())
        });

        chat.auto_on_assistant_final();
        assert!(chat.auto_state.awaiting_review());

        let descriptor_snapshot = chat.pending_turn_descriptor.clone();
        chat.auto_handle_post_turn_review(turn_config.clone(), descriptor_snapshot.as_ref());

        chat.handle_code_event(Event {
            id: "turn".to_string(),
            event_seq: 42,
            msg: EventMsg::TaskComplete(TaskCompleteEvent {
                last_agent_message: None,
            }),
            order: None,
        });

        assert!(
            !chat.auto_state.awaiting_review(),
            "waiting flag should clear after TaskComplete launches skip review"
        );

        let skip_banner = "Auto review skipped: no file changes detected this turn.";
        let skip_present = chat.history_cells.iter().any(|cell| {
            cell.display_lines_trimmed().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.contains(skip_banner))
            })
        });
        assert!(skip_present, "skip banner should appear after review skip");
    }

    #[test]
    fn finalize_explore_updates_even_with_stale_index() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let call_id = "call-explore".to_string();
        let order = OrderMeta {
            request_ordinal: 1,
            output_index: Some(0),
            sequence_number: Some(0),
        };

        chat.handle_code_event(Event {
            id: call_id.clone(),
            event_seq: 0,
            msg: EventMsg::ExecCommandBegin(ExecCommandBeginEvent {
                call_id: call_id.clone(),
                command: vec!["bash".into(), "-lc".into(), "cat foo.txt".into()],
                cwd: std::env::temp_dir(),
                parsed_cmd: vec![ParsedCommand::Read {
                    cmd: "cat foo.txt".to_string(),
                    name: "foo.txt".to_string(),
                }],
            }),
            order: Some(order.clone()),
        });

        let exec_call_id = ExecCallId(call_id.clone());
        let running = chat
            .exec
            .running_commands
            .get_mut(&exec_call_id)
            .expect("explore command should be tracked");
        let (agg_idx, entry_idx) = running
            .explore_entry
            .expect("read command should register an explore entry");

        // Simulate an out-of-date index so finalize must recover by searching.
        running.explore_entry = Some((usize::MAX, entry_idx));
        chat.exec.running_explore_agg_index = Some(usize::MAX);

        chat.finalize_all_running_due_to_answer();

        let cell = chat.history_cells[agg_idx]
            .as_any()
            .downcast_ref::<ExploreAggregationCell>()
            .expect("explore aggregation cell should remain present");
        let entry = cell
            .record()
            .entries
            .get(entry_idx)
            .expect("entry index should still be valid");
        assert!(
            matches!(entry.status, history_cell::ExploreEntryStatus::Success),
            "explore entry should be marked successful instead of remaining running"
        );
        assert!(
            !chat.exec.running_commands.contains_key(&exec_call_id),
            "finalization should clear the running command"
        );
    }

    #[test]
    fn ordering_keeps_new_answers_after_prior_backgrounds() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        chat.last_seen_request_index = 1;
        chat.current_request_index = 1;
        chat.internal_seq = 0;

        chat.push_background_tail("background-one".to_string());
        chat.push_background_tail("background-two".to_string());

        assert_eq!(chat.history_cells.len(), 2, "expected two background cells");

        let answer_id = "answer-turn-1";
        let seeded_key = OrderKey {
            req: 1,
            out: 1,
            seq: 0,
        };
        chat.seed_stream_order_key(StreamKind::Answer, answer_id, seeded_key);

        let response_text = "assistant-response";
        chat.insert_final_answer_with_id(
            Some(answer_id.to_string()),
            vec![Line::from(response_text)],
            response_text.to_string(),
        );

        assert_eq!(chat.history_cells.len(), 3, "expected assistant cell to be added");

        let tail_kinds: Vec<HistoryCellType> = chat
            .history_cells
            .iter()
            .map(|cell| cell.kind())
            .collect();

        let len = tail_kinds.len();
        assert_eq!(
            &tail_kinds[len - 3..],
            &[
                HistoryCellType::BackgroundEvent,
                HistoryCellType::BackgroundEvent,
                HistoryCellType::Assistant,
            ],
            "assistant output should appear after existing background cells",
        );
    }

    #[test]
    fn final_answer_clears_spinner_when_agent_never_reports_terminal_status() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let turn_id = "turn-1".to_string();

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 0,
            msg: EventMsg::TaskStarted,
            order: None,
        });

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 1,
            msg: EventMsg::AgentStatusUpdate(AgentStatusUpdateEvent {
                agents: vec![CoreAgentInfo {
                    id: "agent-1".to_string(),
                    name: "Todo Agent".to_string(),
                    status: "running".to_string(),
                    batch_id: Some("batch-single".to_string()),
                    model: None,
                    last_progress: None,
                    result: None,
                    error: None,
                    elapsed_ms: None,
                    token_count: None,
                }],
                context: None,
                task: None,
            }),
            order: None,
        });

        assert!(
            chat.bottom_pane.is_task_running(),
            "spinner should remain active while the agent reports running"
        );

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 2,
            msg: EventMsg::AgentMessage(AgentMessageEvent {
                message: "Completed todo items.".to_string(),
            }),
            order: None,
        });

        assert!(
            !chat.bottom_pane.is_task_running(),
            "spinner should clear once the final answer arrives even without a terminal status update"
        );

        assert_eq!(chat.overall_task_status, "complete".to_string());

        assert!(
            chat
                .agent_runtime
                .values()
                .all(|rt| rt.completed_at.is_none()),
            "runtime should remain incomplete until backend reports a terminal status"
        );

        assert!(
            chat
                .active_agents
                .iter()
                .all(|agent| !matches!(agent.status, AgentStatus::Pending | AgentStatus::Running)),
            "agents should be forced into a terminal status after the answer completes"
        );
    }

    #[test]
    fn spinner_rearms_when_late_agent_update_reports_running() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let turn_id = "turn-1".to_string();

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 0,
            msg: EventMsg::TaskStarted,
            order: None,
        });

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 1,
            msg: EventMsg::AgentStatusUpdate(AgentStatusUpdateEvent {
                agents: vec![CoreAgentInfo {
                    id: "agent-1".to_string(),
                    name: "Todo Agent".to_string(),
                    status: "running".to_string(),
                    batch_id: Some("batch-single".to_string()),
                    model: None,
                    last_progress: None,
                    result: None,
                    error: None,
                    elapsed_ms: None,
                    token_count: None,
                }],
                context: None,
                task: None,
            }),
            order: None,
        });

        assert!(chat.bottom_pane.is_task_running(), "spinner should be running initially");

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 2,
            msg: EventMsg::AgentMessage(AgentMessageEvent {
                message: "Completed todo items.".to_string(),
            }),
            order: None,
        });

        assert!(
            !chat.bottom_pane.is_task_running(),
            "final answer should clear the spinner when no terminal update arrives"
        );

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 3,
            msg: EventMsg::AgentStatusUpdate(AgentStatusUpdateEvent {
                agents: vec![CoreAgentInfo {
                    id: "agent-1".to_string(),
                    name: "Todo Agent".to_string(),
                    status: "running".to_string(),
                    batch_id: Some("batch-single".to_string()),
                    model: None,
                    last_progress: None,
                    result: None,
                    error: None,
                    elapsed_ms: None,
                    token_count: None,
                }],
                context: None,
                task: None,
            }),
            order: None,
        });

        assert!(
            chat.bottom_pane.is_task_running(),
            "late running update should re-enable the spinner"
        );
    }

    #[test]
    fn scrollback_spacer_preserves_top_cell_bottom_line() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        insert_plain_cell(chat, &["old-1", "old-2"]);
        insert_plain_cell(chat, &["mid-1", "mid-2"]);
        insert_plain_cell(chat, &["new-1", "new-2"]);

        let viewport_height = 6;
        chat.layout.scroll_offset = 2;

        let mut terminal = Terminal::new(TestBackend::new(40, viewport_height)).expect("terminal");
        terminal
            .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
            .expect("draw history");

        let adjusted = chat.history_render.adjust_scroll_to_content(2);
        assert_eq!(adjusted, 1, "scroll origin should step back from spacer row");

        let prefix = chat.history_render.prefix_sums.borrow();
        assert!(!prefix.is_empty(), "prefix sums populated after draw");
        let start_idx = match prefix.binary_search(&adjusted) {
            Ok(i) => i,
            Err(i) => i.saturating_sub(1),
        };
        assert_eq!(start_idx, 0, "expected first cell to be visible after adjustment");

        let content_y = prefix[start_idx];
        drop(prefix);
        let skip_top = adjusted.saturating_sub(content_y);
        assert_eq!(skip_top, 1, "should display the second line of the oldest cell");

        let cell = &chat.history_cells[start_idx];
        let lines = cell.display_lines_trimmed();
        let line = lines
            .get(skip_top as usize)
            .expect("line available after scroll adjustment");
        let text: String = line.spans.iter().map(|span| span.content.as_ref()).collect();
        assert_eq!(text.trim(), "old-2");
    }

    #[test]
    fn scrollback_spacer_exact_offset_adjusts_to_content() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        insert_plain_cell(chat, &["old-1", "old-2"]);
        insert_plain_cell(chat, &["mid-1", "mid-2"]);
        insert_plain_cell(chat, &["new-1", "new-2"]);

        let viewport_height = 6;
        chat.layout.scroll_offset = 2;

        {
            let mut terminal =
                Terminal::new(TestBackend::new(40, viewport_height)).expect("terminal");
            terminal
                .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
                .expect("draw history");
        }

        let ranges = chat.history_render.spacing_ranges_for_test();
        let (pos, _) = ranges
            .first()
            .copied()
            .expect("expected a spacer-induced adjustment");
        let adjusted = chat.history_render.adjust_scroll_to_content(pos);
        assert!(
            adjusted < pos,
            "scroll adjustment should reduce the origin when landing on a spacer"
        );
    }

    #[test]
    fn scrollback_top_boundary_retains_oldest_content() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        insert_plain_cell(chat, &["old-1", "old-2"]);
        insert_plain_cell(chat, &["mid-1", "mid-2"]);
        insert_plain_cell(chat, &["new-1", "new-2"]);

        {
            let mut terminal = Terminal::new(TestBackend::new(40, 6)).expect("terminal");
            terminal
                .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
                .expect("draw history");
        }

        let max_scroll = chat.layout.last_max_scroll.get();
        assert!(max_scroll > 0, "expected overflow to produce a positive max scroll");
        chat.layout.scroll_offset = max_scroll;

        let mut terminal = Terminal::new(TestBackend::new(40, 6)).expect("terminal");
        terminal
            .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
            .expect("draw history at top boundary");

        let max_scroll = chat.layout.last_max_scroll.get();
        let scroll_from_top = max_scroll.saturating_sub(chat.layout.scroll_offset);
        let effective = chat.history_render.adjust_scroll_to_content(scroll_from_top);
        let prefix = chat.history_render.prefix_sums.borrow();
        let mut start_idx = match prefix.binary_search(&effective) {
            Ok(i) => i,
            Err(i) => i.saturating_sub(1),
        };
        start_idx = start_idx.min(prefix.len().saturating_sub(1));
        start_idx = start_idx.min(chat.history_cells.len().saturating_sub(1));
        let content_y = prefix[start_idx];
        drop(prefix);

        let skip = effective.saturating_sub(content_y) as usize;
        let cell = &chat.history_cells[start_idx];
        let lines = cell.display_lines_trimmed();
        let target_index = skip.min(lines.len().saturating_sub(1));
        let visible = lines
            .get(target_index)
            .map(|line| {
                line.spans
                    .iter()
                    .map(|span| span.content.as_ref())
                    .collect::<String>()
            })
            .unwrap_or_default();

        assert!(
            visible.contains("old-1"),
            "scrolling to the top should keep the oldest content visible"
        );
    }

    #[test]
    fn ordering_stream_delta_should_follow_existing_background_tail() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        chat.last_seen_request_index = 1;
        chat.push_background_tail("background".to_string());

        let stream_state = AssistantStreamState {
            id: HistoryId::ZERO,
            stream_id: "stream-1".into(),
            preview_markdown: "partial".into(),
            deltas: vec![AssistantStreamDelta {
                delta: "partial".into(),
                sequence: Some(0),
                received_at: SystemTime::now(),
            }],
            citations: vec![],
            metadata: None,
            in_progress: true,
            last_updated_at: SystemTime::now(),
            truncated_prefix_bytes: 0,
        };
        let stream_cell = history_cell::new_streaming_content(stream_state, &chat.config);

        chat.history_insert_with_key_global_tagged(
            Box::new(stream_cell),
            OrderKey {
                req: 1,
                out: 0,
                seq: 0,
            },
            "stream",
            None,
        );

        let kinds: Vec<HistoryCellType> = chat
            .history_cells
            .iter()
            .map(|cell| cell.kind())
            .collect();

        assert_eq!(
            kinds,
            vec![HistoryCellType::BackgroundEvent, HistoryCellType::Assistant],
            "streaming assistant output should append after the existing background tail cell",
        );
    }

    #[test]
    fn ordering_tool_reasoning_explore_should_preserve_arrival_sequence() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        chat.last_seen_request_index = 1;

        let make_plain = |text: &str| PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::System,
            kind: PlainMessageKind::Plain,
            header: None,
            lines: vec![MessageLine {
                kind: MessageLineKind::Paragraph,
                spans: vec![InlineSpan {
                    text: text.to_string(),
                    tone: TextTone::Default,
                    emphasis: TextEmphasis::default(),
                    entity: None,
                }],
            }],
            metadata: None,
        };

        // Reasoning arrives first with later output index.
        let reasoning_key = ChatWidget::raw_order_key_from_order_meta(&OrderMeta {
            request_ordinal: 1,
            output_index: Some(2),
            sequence_number: Some(0),
        });
        chat.history_insert_plain_state_with_key(make_plain("reasoning"), reasoning_key, "reasoning");

        // Explore summary follows immediately afterwards.
        let explore_key = ChatWidget::raw_order_key_from_order_meta(&OrderMeta {
            request_ordinal: 1,
            output_index: Some(3),
            sequence_number: Some(0),
        });
        chat.history_insert_plain_state_with_key(make_plain("explore"), explore_key, "explore");

        // Tool run summary arrives last but references an earlier output index.
        let tool_key = ChatWidget::raw_order_key_from_order_meta(&OrderMeta {
            request_ordinal: 1,
            output_index: Some(1),
            sequence_number: Some(0),
        });
        chat.history_insert_plain_state_with_key(make_plain("tool"), tool_key, "tool");

        let labels: Vec<String> = chat
            .history_cells
            .iter()
            .map(|cell| {
                cell.display_lines_trimmed()
                    .first()
                    .map(|line| line.spans.iter().map(|span| span.content.as_ref()).collect())
                    .unwrap_or_default()
            })
            .collect();

        assert_eq!(
            labels,
            vec!["reasoning".to_string(), "explore".to_string(), "tool".to_string()],
            "later inserts with smaller output_index should not leapfrog visible reasoning/explore summaries",
        );
    }

    #[test]
    fn ordering_cross_request_pre_prompt_should_not_prepend_previous_turn() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let make_plain = |text: &str| PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::System,
            kind: PlainMessageKind::Plain,
            header: None,
            lines: vec![MessageLine {
                kind: MessageLineKind::Paragraph,
                spans: vec![InlineSpan {
                    text: text.to_string(),
                    tone: TextTone::Default,
                    emphasis: TextEmphasis::default(),
                    entity: None,
                }],
            }],
            metadata: None,
        };

        chat.history_insert_plain_state_with_key(
            make_plain("req1"),
            OrderKey {
                req: 1,
                out: 0,
                seq: 0,
            },
            "req1",
        );

        chat.last_seen_request_index = 1;
        chat.pending_user_prompts_for_next_turn = 0;

        let key = chat.system_order_key(SystemPlacement::PrePromptInCurrent, None);
        chat.history_insert_plain_state_with_key(make_plain("system"), key, "system");

        let labels: Vec<String> = chat
            .history_cells
            .iter()
            .map(|cell| {
                cell.display_lines_trimmed()
                    .first()
                    .map(|line| line.spans.iter().map(|span| span.content.as_ref()).collect())
                    .unwrap_or_default()
            })
            .collect();

        assert_eq!(
            labels,
            vec!["req1".to_string(), "system".to_string()],
            "pre-prompt system notices for a new request should append after the prior turn rather than prepending it",
        );
    }

    #[test]
    fn resume_ordering_offsets_provider_ordinals() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let make_plain = |id: u64,
                           text: &str,
                           role: PlainMessageRole,
                           kind: PlainMessageKind| -> PlainMessageState {
            PlainMessageState {
                id: HistoryId(id),
                role,
                kind,
                header: None,
                lines: vec![MessageLine {
                    kind: MessageLineKind::Paragraph,
                    spans: vec![InlineSpan {
                        text: text.to_string(),
                        tone: TextTone::Default,
                        emphasis: TextEmphasis::default(),
                        entity: None,
                    }],
                }],
                metadata: None,
            }
        };

        let snapshot = HistorySnapshot {
            records: vec![
                HistoryRecord::PlainMessage(make_plain(
                    1,
                    "user-turn",
                    PlainMessageRole::User,
                    PlainMessageKind::User,
                )),
                HistoryRecord::PlainMessage(make_plain(
                    2,
                    "assistant-turn",
                    PlainMessageRole::Assistant,
                    PlainMessageKind::Assistant,
                )),
            ],
            next_id: 3,
            exec_call_lookup: HashMap::new(),
            tool_call_lookup: HashMap::new(),
            stream_lookup: HashMap::new(),
            order: vec![
                OrderKeySnapshot {
                    req: 5,
                    out: 0,
                    seq: 0,
                },
                OrderKeySnapshot {
                    req: 5,
                    out: 1,
                    seq: 0,
                },
            ],
            order_debug: Vec::new(),
        };

        chat.restore_history_snapshot(&snapshot);

        assert_eq!(
            chat.last_seen_request_index, 5,
            "restoring snapshot should set last_seen_request_index"
        );

        let order_meta = OrderMeta {
            request_ordinal: 0,
            output_index: Some(0),
            sequence_number: Some(0),
        };
        let key = chat.provider_order_key_from_order_meta(&order_meta);
        assert_eq!(
            key.req, 6,
            "resume should bias provider ordinals so new output slots after restored history"
        );

        let new_state = PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::Assistant,
            kind: PlainMessageKind::Assistant,
            header: None,
            lines: vec![MessageLine {
                kind: MessageLineKind::Paragraph,
                spans: vec![InlineSpan {
                    text: "new-assistant".to_string(),
                    tone: TextTone::Default,
                    emphasis: TextEmphasis::default(),
                    entity: None,
                }],
            }],
            metadata: None,
        };

        let pos = chat.history_insert_plain_state_with_key(new_state, key, "resume-order");
        assert_eq!(pos, chat.history_cells.len().saturating_sub(1));

        let inserted_key = chat.cell_order_seq[pos];
        assert_eq!(inserted_key.req, 6);

        let inserted_text: String = chat.history_cells[pos]
            .display_lines_trimmed()
            .iter()
            .flat_map(|line| line.spans.iter().map(|span| span.content.as_ref()))
            .collect();
        assert!(
            inserted_text.contains("new-assistant"),
            "resume insertion should surface the new assistant answer at the tail"
        );
    }



}

fn append_thought_ellipsis(text: &str) -> String {
    let trimmed = text.trim_end();
    if trimmed.ends_with('…') {
        trimmed.to_string()
    } else {
        format!("{trimmed}…")
    }
}

fn extract_latest_bold_title(text: &str) -> Option<String> {
    fn prev_non_ws(text: &str, end: usize) -> Option<char> {
        text[..end].chars().rev().find(|ch| !ch.is_whitespace())
    }

    fn next_non_ws(text: &str, start: usize) -> Option<char> {
        text[start..].chars().find(|ch| !ch.is_whitespace())
    }

    fn normalize_candidate(candidate: &str) -> Option<String> {
        let trimmed = candidate.trim();
        if trimmed.is_empty() {
            return None;
        }
        Some(trimmed.to_string())
    }

    let bytes = text.as_bytes();
    let mut idx = 0usize;
    let mut latest: Option<String> = None;
    let mut open_start: Option<usize> = None;

    while idx + 1 < bytes.len() {
        if bytes[idx] == b'*' && bytes[idx + 1] == b'*' {
            if let Some(start) = open_start {
                let candidate = &text[start..idx];
                let before = prev_non_ws(text, start);
                let after = next_non_ws(text, idx + 2);
                let looks_like_heading = before
                    .map(|ch| matches!(ch, '"' | '\n' | '\r' | ':' | '[' | '{'))
                    .unwrap_or(true)
                    && after
                        .map(|ch| matches!(ch, '"' | '\n' | '\r' | ',' | '}' | ']'))
                        .unwrap_or(true);

                if looks_like_heading {
                    if let Some(clean) = normalize_candidate(candidate) {
                        latest = Some(clean);
                    }
                }
                open_start = None;
                idx += 2;
                continue;
            } else {
                open_start = Some(idx + 2);
                idx += 2;
                continue;
            }
        }
        idx += 1;
    }

    if latest.is_none() {
        if let Some(start) = open_start {
            if let Some(clean) = normalize_candidate(&text[start..]) {
                latest = Some(clean);
            }
        }
    }

    if latest.is_some() {
        return latest;
    }

    for raw_line in text.lines() {
        let trimmed = raw_line.trim();
        if trimmed.is_empty() {
            continue;
        }

        if let Some(title) = heading_from_line(trimmed) {
            latest = Some(title);
        }
    }

    latest
}

fn heading_from_line(line: &str) -> Option<String> {
    let normalized = remove_bullet_prefix(line.trim_start());
    if !normalized.starts_with("**") {
        return None;
    }

    let rest = &normalized[2..];
    let end = rest.find("**");
    let title = match end {
        Some(idx) => &rest[..idx],
        None => rest,
    };

    if title.trim().is_empty() {
        return None;
    }

    Some(title.to_string())
}

fn remove_bullet_prefix(line: &str) -> &str {
    let mut normalized = line;
    for prefix in ["- ", "* ", "\u{2022} "] {
        if normalized.starts_with(prefix) {
            normalized = normalized[prefix.len()..].trim_start();
            break;
        }
    }
    normalized
}

fn strip_role_prefix_if_present(input: &str) -> (&str, bool) {
    const PREFIXES: [&str; 2] = ["Coordinator:", "CLI:"];
    for prefix in PREFIXES {
        if input.len() >= prefix.len() {
            let (head, tail) = input.split_at(prefix.len());
            if head.eq_ignore_ascii_case(prefix) {
                return (tail, true);
            }
        }
    }
    (input, false)
}

impl ChatWidget<'_> {
    fn auto_resolve_enabled(&self) -> bool {
        self.auto_resolve_state.is_some()
    }

    fn auto_resolve_clear(&mut self) {
        self.auto_resolve_state = None;
        self.maybe_resume_auto_after_review();
    }

    fn auto_resolve_notice<S: Into<String>>(&mut self, message: S) {
        self.push_background_tail(message.into());
        self.request_redraw();
    }

    fn auto_resolve_commit_sha(&self) -> Option<String> {
        self.auto_resolve_state
            .as_ref()
            .and_then(|state| state.metadata.as_ref())
            .and_then(|metadata| metadata.commit.clone())
    }

    fn auto_resolve_scope(&self) -> Option<String> {
        self.auto_resolve_state
            .as_ref()
            .and_then(|state| state.metadata.as_ref())
            .and_then(|metadata| metadata.scope.clone())
    }

    fn worktree_has_uncommitted_changes(&self) -> Option<bool> {
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(["status", "--short"])
            .output()
            .ok()?;
        if !output.status.success() {
            return None;
        }
        let stdout = String::from_utf8_lossy(&output.stdout);
        Some(!stdout.trim().is_empty())
    }

    fn current_head_commit_sha(&self) -> Option<String> {
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(["rev-parse", "HEAD"])
            .output()
            .ok()?;
        if !output.status.success() {
            return None;
        }
        let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if stdout.is_empty() {
            None
        } else {
            Some(stdout)
        }
    }

    fn commit_subject_for(&self, commit: &str) -> Option<String> {
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(["show", "-s", "--format=%s", commit])
            .output()
            .ok()?;
        if !output.status.success() {
            return None;
        }
        let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if stdout.is_empty() {
            None
        } else {
            Some(stdout)
        }
    }

    fn auto_resolve_should_block_auto_resume(&self) -> bool {
        match self.auto_resolve_state.as_ref().map(|state| &state.phase) {
            Some(AutoResolvePhase::PendingFix { .. })
            | Some(AutoResolvePhase::AwaitingFix { .. })
            | Some(AutoResolvePhase::AwaitingJudge { .. }) => true,
            Some(AutoResolvePhase::WaitingForReview) => self.is_review_flow_active(),
            None => false,
        }
    }

    fn maybe_resume_auto_after_review(&mut self) {
        if !self.auto_state.is_active() || !self.auto_state.awaiting_review() {
            return;
        }
        if self.is_review_flow_active() || self.auto_resolve_should_block_auto_resume() {
            return;
        }
        self.cleanup_active_review_worktree();
        self.auto_state.on_complete_review();
        if !self.auto_state.should_bypass_coordinator_next_submit() {
            self.auto_send_conversation();
        }
        self.request_redraw();
    }

    fn auto_resolve_format_findings(review: &ReviewOutputEvent) -> String {
        let mut sections: Vec<String> = Vec::new();
        if !review.findings.is_empty() {
            sections.push(format_review_findings_block(&review.findings, None));
        }
        let explanation = review.overall_explanation.trim();
        if !explanation.is_empty() {
            sections.push(explanation.to_string());
        }
        sections
            .into_iter()
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect::<Vec<_>>()
            .join("\n\n")
    }

    fn auto_resolve_handle_review_enter(&mut self) {
        if let Some(state) = self.auto_resolve_state.as_mut() {
            state.phase = AutoResolvePhase::WaitingForReview;
            state.last_review = None;
            state.last_fix_message = None;
        }
    }

    fn auto_resolve_handle_review_exit(&mut self, review_output: Option<ReviewOutputEvent>) {
        if self.auto_resolve_state.is_none() {
            return;
        }

        let notice: Option<String>;
        let mut should_clear = false;
        {
            let state = self.auto_resolve_state.as_mut().unwrap();
            match review_output {
                Some(ref output) => {
                    state.attempt = state.attempt.saturating_add(1);
                    state.last_review = Some(output.clone());
                    state.last_fix_message = None;

                    if output.findings.is_empty() {
                        notice = Some("Auto-resolve: review reported no actionable findings. Exiting.".to_string());
                        should_clear = true;
                    } else if state.attempt > state.max_attempts {
                        notice = Some(format!(
                            "Auto-resolve: reached {attempts} review attempts; handing control back to you.",
                            attempts = state.max_attempts
                        ));
                        should_clear = true;
                    } else {
                        state.phase = AutoResolvePhase::PendingFix {
                            review: output.clone(),
                        };
                        notice = Some("Auto-resolve: review found issues. Preparing follow-up fix request.".to_string());
                    }
                }
                None => {
                    notice = Some(
                        "Auto-resolve: review ended without findings. Please inspect manually.".to_string(),
                    );
                    should_clear = true;
                }
            }
        }

        if should_clear {
            self.auto_resolve_clear();
        }
        if let Some(message) = notice {
            self.auto_resolve_notice(message);
        }
    }

    fn auto_resolve_on_task_complete(&mut self, last_agent_message: Option<String>) {
        let Some(state_snapshot) = self.auto_resolve_state.clone() else {
            return;
        };

        match state_snapshot.phase {
            AutoResolvePhase::PendingFix { review } => {
                if let Some(state) = self.auto_resolve_state.as_mut() {
                    state.phase = AutoResolvePhase::AwaitingFix {
                        review: review.clone(),
                    };
                }
                self.dispatch_auto_fix(&review);
            }
            AutoResolvePhase::AwaitingFix { review } => {
                if let Some(state) = self.auto_resolve_state.as_mut() {
                    state.last_fix_message = last_agent_message.clone();
                    state.phase = AutoResolvePhase::AwaitingJudge {
                        review: review.clone(),
                    };
                }
                self.dispatch_auto_judge(&review, last_agent_message);
            }
            AutoResolvePhase::AwaitingJudge { review } => {
                let message = last_agent_message.unwrap_or_default();
                self.auto_resolve_process_judge(review, message);
            }
            AutoResolvePhase::WaitingForReview => {}
        }
    }

    fn dispatch_auto_fix(&mut self, review: &ReviewOutputEvent) {
        let summary = Self::auto_resolve_format_findings(review);
        let mut preface = String::from(
            "You are continuing an automated /review resolution loop. Review the listed findings and determine whether they represent real issues introduced by our changes. If they are, apply the necessary fixes and resolve any similar issues you can identify before responding."
        );
        if !summary.is_empty() {
            preface.push_str("\n\nFindings:\n");
            preface.push_str(&summary);
        }
        if self
            .auto_resolve_scope()
            .as_deref()
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(commit) = self.auto_resolve_commit_sha() {
                let short_sha: String = commit.chars().take(7).collect();
                preface.push_str("\n\nCommit under review: ");
                preface.push_str(&commit);
                preface.push_str(" (short SHA ");
                preface.push_str(&short_sha);
                preface.push_str(
                    "). If you make changes to address these findings, amend this commit before responding so the review target reflects your fixes.",
                );
            }
        }
        self.auto_resolve_notice("Auto-resolve: asking the agent to verify and address the review findings.");
        self.submit_hidden_text_message_with_preface(
            "Is this a real issue introduced by our changes? If so, please fix and resolve all similar issues.".to_string(),
            preface,
        );
    }

    fn dispatch_auto_judge(&mut self, review: &ReviewOutputEvent, fix_message: Option<String>) {
        let summary = Self::auto_resolve_format_findings(review);
        let mut preface = String::from(
            "You are evaluating whether the latest fixes resolved the findings from `/review`. Respond with a strict JSON object containing `status` and optional `rationale`. Valid `status` values: `review_again`, `no_issue`, `continue_fix`. Do not include any additional text before or after the JSON."
        );
        if !summary.is_empty() {
            preface.push_str("\n\nOriginal findings:\n");
            preface.push_str(&summary);
        }
        if let Some(fix) = fix_message.as_ref().map(|s| s.trim()).filter(|s| !s.is_empty()) {
            preface.push_str("\n\nLatest agent response:\n");
            preface.push_str(fix);
        }
        preface.push_str("\n\nReturn JSON: {\"status\": \"...\", \"rationale\": \"optional explanation\"}.");
        if self
            .auto_resolve_scope()
            .as_deref()
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(commit) = self.auto_resolve_commit_sha() {
                let short_sha: String = commit.chars().take(7).collect();
                preface.push_str("\n\nCommit under review: ");
                preface.push_str(&commit);
                preface.push_str(" (short SHA ");
                preface.push_str(&short_sha);
                preface.push_str(
                    "). Confirm that any fixes have been committed (amend the commit if necessary) before returning `no_issue`.",
                );
            }
        }

        self.auto_resolve_notice("Auto-resolve: requesting status JSON from the agent.");
        self.submit_hidden_text_message_with_preface("Auto-resolve status check".to_string(), preface);
    }

    fn dispatch_auto_continue(&mut self, review: &ReviewOutputEvent) {
        let summary = Self::auto_resolve_format_findings(review);
        let mut preface = String::from(
            "The previous status check indicated more work is required on the review findings. Continue addressing the remaining issues before responding."
        );
        if !summary.is_empty() {
            preface.push_str("\n\nOutstanding findings:\n");
            preface.push_str(&summary);
        }
        self.auto_resolve_notice("Auto-resolve: asking the agent to continue working on the findings.");
        self.submit_hidden_text_message_with_preface("Please continue".to_string(), preface);
    }

    fn restart_auto_resolve_review(&mut self) {
        let Some(state_snapshot) = self.auto_resolve_state.clone() else {
            return;
        };
        let next_attempt = state_snapshot.attempt.saturating_add(1);
        let bounded_attempt = next_attempt.min(state_snapshot.max_attempts);
        let max_attempts = state_snapshot.max_attempts;
        let prep_label = format!(
            "Preparing follow-up code review (attempt {bounded_attempt} of {max_attempts})"
        );
        let mut base_prompt = state_snapshot.prompt.trim_end().to_string();
        if let Some(idx) = base_prompt.find(AUTO_RESOLVE_REVIEW_FOLLOWUP) {
            base_prompt = base_prompt[..idx].trim_end().to_string();
        }

        let mut next_hint = state_snapshot.hint.clone();
        let mut next_metadata = state_snapshot.metadata.clone();

        if next_metadata
            .as_ref()
            .and_then(|meta| meta.scope.as_ref())
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(new_commit) = self.current_head_commit_sha() {
                let short_sha: String = new_commit.chars().take(7).collect();
                let subject = self.commit_subject_for(&new_commit);
                base_prompt = if let Some(subject) = subject {
                    format!(
                        "Review the code changes introduced by commit {new_commit} (\"{subject}\"). Provide prioritized, actionable findings."
                    )
                } else {
                    format!(
                        "Review the code changes introduced by commit {new_commit}. Provide prioritized, actionable findings."
                    )
                };
                next_hint = format!("commit {short_sha}");
                if let Some(meta) = next_metadata.as_mut() {
                    meta.commit = Some(new_commit.clone());
                }
            }
        }

        let mut continued_prompt = base_prompt.clone();
        if let Some(last_review) = state_snapshot.last_review.as_ref() {
            let recap = Self::auto_resolve_format_findings(last_review);
            if !recap.is_empty() {
                continued_prompt.push_str("\n\nPreviously reported findings to re-validate:\n");
                continued_prompt.push_str(&recap);
            }
        }
        if state_snapshot
            .metadata
            .as_ref()
            .and_then(|meta| meta.scope.as_ref())
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(commit) = state_snapshot
                .metadata
                .as_ref()
                .and_then(|meta| meta.commit.clone())
            {
                if let Some(true) = self.worktree_has_uncommitted_changes() {
                    continued_prompt.push_str("\n\nNote: there are uncommitted changes in the working tree since commit ");
                    continued_prompt.push_str(&commit);
                    continued_prompt.push_str(
                        ". Ensure the review covers the updated workspace rather than only the original commit snapshot.",
                    );
                }
            }
        }
        continued_prompt.push_str("\n\n");
        continued_prompt.push_str(AUTO_RESOLVE_REVIEW_FOLLOWUP);
        self.begin_review(
            continued_prompt,
            next_hint.clone(),
            Some(prep_label),
            next_metadata.clone(),
        );
        if let Some(state) = self.auto_resolve_state.as_mut() {
            state.phase = AutoResolvePhase::WaitingForReview;
            state.prompt = base_prompt;
            state.hint = next_hint;
            state.metadata = next_metadata;
            state.last_review = None;
            state.last_fix_message = None;
        }
    }

    fn auto_resolve_process_judge(&mut self, review: ReviewOutputEvent, message: String) {
        let trimmed = message.trim();
        let Some(decision) = Self::auto_resolve_parse_decision(trimmed) else {
            self.auto_resolve_notice("Auto-resolve: expected JSON status but received something else. Stopping automation.");
            self.auto_resolve_clear();
            return;
        };

        let status = decision.status.to_ascii_lowercase();
        let rationale = decision.rationale.unwrap_or_default();

        match status.as_str() {
            "no_issue" => {
                let rationale_text = rationale.trim();
                let attempt_limit_reached = self
                    .auto_resolve_state
                    .as_ref()
                    .is_some_and(|state| state.attempt >= state.max_attempts);

                if attempt_limit_reached {
                    if rationale_text.is_empty() {
                        self.auto_resolve_notice(
                            "Auto-resolve: agent reported no remaining issues but hit the review attempt limit. Please inspect manually.".to_string(),
                        );
                    } else {
                        self.auto_resolve_notice(format!(
                            "Auto-resolve: no remaining issues. {rationale_text} Attempt limit reached; handing control back to you."
                        ));
                    }
                    self.auto_resolve_clear();
                } else {
                    if rationale_text.is_empty() {
                        self.auto_resolve_notice(
                            "Auto-resolve: agent reported no remaining issues. Running follow-up /review to confirm.".to_string(),
                        );
                    } else {
                        self.auto_resolve_notice(format!(
                            "Auto-resolve: no remaining issues. {rationale_text} Running follow-up /review to confirm."
                        ));
                    }
                    if let Some(state) = self.auto_resolve_state.as_mut() {
                        state.phase = AutoResolvePhase::WaitingForReview;
                    }
                    self.restart_auto_resolve_review();
                }
            }
            "continue_fix" => {
                if let Some(state) = self.auto_resolve_state.as_mut() {
                    state.phase = AutoResolvePhase::AwaitingFix {
                        review: review.clone(),
                    };
                }
                self.dispatch_auto_continue(&review);
            }
            "review_again" => {
                let stop = self
                    .auto_resolve_state
                    .as_ref()
                    .is_some_and(|state| state.attempt >= state.max_attempts);
                if stop {
                    self.auto_resolve_notice("Auto-resolve: review-again requested but attempt limit reached. Stopping.");
                    self.auto_resolve_clear();
                } else {
                    if rationale.trim().is_empty() {
                        self.auto_resolve_notice("Auto-resolve: running another /review pass.".to_string());
                    } else {
                        let rationale_text = rationale.trim();
                        self.auto_resolve_notice(format!(
                            "Auto-resolve: running another /review pass. {rationale_text}"
                        ));
                    }
                    self.restart_auto_resolve_review();
                }
            }
            other => {
                self.auto_resolve_notice(format!(
                    "Auto-resolve: unexpected status '{other}'. Stopping automation."
                ));
                self.auto_resolve_clear();
            }
        }
    }

    fn auto_resolve_parse_decision(raw: &str) -> Option<AutoResolveDecision> {
        if let Ok(decision) = serde_json::from_str::<AutoResolveDecision>(raw) {
            return Some(decision);
        }

        if let Some(start) = raw.find("{" ) {
            if let Some(end) = raw.rfind("}") {
                let slice = &raw[start..=end];
                if let Ok(decision) = serde_json::from_str::<AutoResolveDecision>(slice) {
                    return Some(decision);
                }
            }
        }

        // try to strip ```json fences
        if let Some(json_start) = raw.find("```") {
            if let Some(rest) = raw[json_start + 3..].split_once("```") {
                let candidate = rest.0.trim_start_matches("json").trim();
                if let Ok(decision) = serde_json::from_str::<AutoResolveDecision>(candidate) {
                    return Some(decision);
                }
            }
        }

        None
    }

    pub(crate) fn open_review_dialog(&mut self) {
        if self.is_task_running() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/review` — complete or cancel the current task before starting a new review.".to_string(),
            ));
            self.request_redraw();
            return;
        }

        let mut items: Vec<SelectionItem> = Vec::new();

        let auto_label = if self.config.tui.review_auto_resolve {
            "On"
        } else {
            "Off"
        };
        items.push(SelectionItem {
            name: format!("Auto Resolve reviews — {auto_label}"),
            description: Some("Automatically rerun fixes and follow-up checks after each review.".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::ToggleReviewAutoResolve);
            })],
        });

        items.push(SelectionItem {
            name: "Review /branch changes".to_string(),
            description: Some("Compare your worktree branch against its merge target".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::RunReviewCommand(String::new()));
            })],
        });

        items.push(SelectionItem {
            name: "Review a specific commit".to_string(),
            description: Some("Pick from recent commits".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::StartReviewCommitPicker);
            })],
        });

        items.push(SelectionItem {
            name: "Review against a base branch".to_string(),
            description: Some("Diff current branch against another".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::StartReviewBranchPicker);
            })],
        });

        items.push(SelectionItem {
            name: "Custom review instructions".to_string(),
            description: Some("Describe exactly what to audit".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::OpenReviewCustomPrompt);
            })],
        });

        let view: ListSelectionView = ListSelectionView::new(
            " Review options ".to_string(),
            Some("Choose what scope to review".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            6,
        );

        self.bottom_pane.show_list_selection(
            "Review options".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_review_custom_prompt(&mut self) {
        let submit_tx = self.app_event_tx.clone();
        let on_submit: Box<dyn Fn(String) + Send + Sync> = Box::new(move |text: String| {
            submit_tx.send(crate::app_event::AppEvent::RunReviewCommand(text));
        });
        let view = CustomPromptView::new(
            "Custom review instructions".to_string(),
            "Describe the files or changes you want reviewed".to_string(),
            Some("Press Enter to submit · Esc cancel".to_string()),
            self.app_event_tx.clone(),
            None,
            on_submit,
        );
        self.bottom_pane.show_custom_prompt(view);
    }

    pub(crate) fn toggle_review_auto_resolve(&mut self) {
        let new_value = !self.config.tui.review_auto_resolve;
        self.config.tui.review_auto_resolve = new_value;

        if !new_value {
            self.auto_resolve_clear();
        }

        let (_persisted, message) = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_tui_review_auto_resolve(&home, new_value) {
                Ok(_) => {
                    tracing::info!("Persisted review auto resolve toggle: {}", new_value);
                    (true, if new_value {
                        "Auto Resolve enabled for /review."
                    } else {
                        "Auto Resolve disabled for /review."
                    })
                }
                Err(e) => {
                    tracing::warn!("Failed to persist review auto resolve toggle: {}", e);
                    (false, if new_value {
                        "Auto Resolve enabled for this session (failed to persist)."
                    } else {
                        "Auto Resolve disabled for this session (failed to persist)."
                    })
                }
            }
        } else {
            tracing::warn!("Could not locate Codex home to persist review auto resolve toggle");
            (false, if new_value {
                "Auto Resolve enabled for this session."
            } else {
                "Auto Resolve disabled for this session."
            })
        };

        self.bottom_pane.flash_footer_notice(message.to_string());
        // Reopen selection view to reflect new label.
        self.open_review_dialog();
    }

    pub(crate) fn show_review_commit_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading recent commits…".to_string(),
            description: None,
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Select a commit ".to_string(),
            Some("Fetching recent commits from git".to_string()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            6,
        );
        self.bottom_pane.show_list_selection(
            "Select a commit".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_review_commit_picker(&mut self, commits: Vec<CommitLogEntry>) {
        if commits.is_empty() {
            self.bottom_pane
                .flash_footer_notice("No recent commits found for review".to_string());
            self.request_redraw();
            return;
        }

        let auto_resolve = self.config.tui.review_auto_resolve;
        let mut items: Vec<SelectionItem> = Vec::with_capacity(commits.len());
        for entry in commits {
            let subject = entry.subject.trim().to_string();
            let sha = entry.sha.trim().to_string();
            if sha.is_empty() {
                continue;
            }
            let short_sha: String = sha.chars().take(7).collect();
            let title = if subject.is_empty() {
                short_sha.clone()
            } else {
                format!("{short_sha} — {subject}")
            };
            let prompt = if subject.is_empty() {
                format!(
                    "Review the code changes introduced by commit {sha}. Provide prioritized, actionable findings."
                )
            } else {
                format!(
                    "Review the code changes introduced by commit {sha} (\"{subject}\"). Provide prioritized, actionable findings."
                )
            };
            let hint = format!("commit {short_sha}");
            let preparation = format!("Preparing code review for commit {short_sha}");
            let prompt_closure = prompt.clone();
            let hint_closure = hint.clone();
            let prep_closure = preparation.clone();
            let metadata_option = Some(ReviewContextMetadata {
                scope: Some("commit".to_string()),
                commit: Some(sha.clone()),
                ..Default::default()
            });
            let auto_flag = auto_resolve;
            items.push(SelectionItem {
                name: title,
                description: None,
                is_current: false,
                actions: vec![Box::new(move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                        prompt: prompt_closure.clone(),
                        hint: hint_closure.clone(),
                        preparation_label: Some(prep_closure.clone()),
                        metadata: metadata_option.clone(),
                        auto_resolve: auto_flag,
                    });
                })],
            });
        }

        if items.is_empty() {
            self.bottom_pane
                .flash_footer_notice("No recent commits found for review".to_string());
            self.request_redraw();
            return;
        }

        let view = ListSelectionView::new(
            " Select a commit ".to_string(),
            Some("Choose a commit to review".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane.show_list_selection(
            "Select a commit to review".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_review_branch_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading local branches…".to_string(),
            description: None,
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Select a base branch ".to_string(),
            Some("Fetching local branches".to_string()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            6,
        );
        self.bottom_pane.show_list_selection(
            "Select a base branch".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_review_branch_picker(
        &mut self,
        current_branch: Option<String>,
        branches: Vec<String>,
    ) {
        let current_trimmed = current_branch.as_ref().map(|s| s.trim().to_string());
        let mut items: Vec<SelectionItem> = Vec::new();
        let auto_resolve = self.config.tui.review_auto_resolve;
        for branch in branches {
            let branch_trimmed = branch.trim();
            if branch_trimmed.is_empty() {
                continue;
            }
            if current_trimmed
                .as_ref()
                .is_some_and(|current| current == branch_trimmed)
            {
                continue;
            }

            let title = if let Some(current) = current_trimmed.as_ref() {
                format!("{current} → {branch_trimmed}")
            } else {
                format!("Compare against {branch_trimmed}")
            };

            let prompt = if let Some(current) = current_trimmed.as_ref() {
                format!(
                    "Review the code changes between the current branch '{current}' and '{branch_trimmed}'. Identify the intent of the changes in '{current}' and ensure no obvious gaps remain. Find all geniune bugs or regressions which need to be addressed before merging. Return ALL issues which need to be addressed, not just the first one you find."
                )
            } else {
                format!(
                    "Review the code changes that would merge into '{branch_trimmed}'. Identify bugs, regressions, risky patterns, and missing tests before merge."
                )
            };
            let hint = format!("against {branch_trimmed}");
            let preparation = format!("Preparing code review against {branch_trimmed}");
            let prompt_closure = prompt.clone();
            let hint_closure = hint.clone();
            let prep_closure = preparation.clone();
            let metadata_option = Some(ReviewContextMetadata {
                scope: Some("branch_diff".to_string()),
                base_branch: Some(branch_trimmed.to_string()),
                current_branch: current_trimmed.clone(),
                ..Default::default()
            });
            let auto_flag = auto_resolve;
            items.push(SelectionItem {
                name: title,
                description: None,
                is_current: false,
                actions: vec![Box::new(move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                        prompt: prompt_closure.clone(),
                        hint: hint_closure.clone(),
                        preparation_label: Some(prep_closure.clone()),
                        metadata: metadata_option.clone(),
                        auto_resolve: auto_flag,
                    });
                })],
            });
        }

        if items.is_empty() {
            self.bottom_pane
                .flash_footer_notice("No alternative branches found for review".to_string());
            self.request_redraw();
            return;
        }

        let subtitle = current_trimmed
            .as_ref()
            .map(|current| format!("Current branch: {current}"));

        let view = ListSelectionView::new(
            " Select a base branch ".to_string(),
            subtitle,
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane.show_list_selection(
            "Compare against a branch".to_string(),
            None,
            None,
            view,
        );
    }

    /// Handle `/review [focus]` command by starting a dedicated review session.
    pub(crate) fn handle_review_command(&mut self, args: String) {
        if self.is_task_running() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/review` — complete or cancel the current task before starting a new review.".to_string(),
            ));
            self.request_redraw();
            return;
        }

        let trimmed = args.trim();
        let auto_resolve = self.config.tui.review_auto_resolve;
        if trimmed.is_empty() {
            if Self::is_branch_worktree_path(&self.config.cwd) {
                if let Some(git_root) =
                    code_core::git_info::resolve_root_git_project_for_trust(&self.config.cwd)
                {
                    let worktree_cwd = self.config.cwd.clone();
                    let tx = self.app_event_tx.clone();
                    let auto_flag = auto_resolve;
                    tokio::spawn(async move {
                    let branch_metadata =
                        code_core::git_worktree::load_branch_metadata(&worktree_cwd);
                    let metadata_base = branch_metadata.as_ref().and_then(|meta| {
                        meta.remote_ref.clone().or_else(|| {
                            if let (Some(remote_name), Some(base_branch)) =
                                (meta.remote_name.clone(), meta.base_branch.clone())
                            {
                                Some(format!("{}/{}", remote_name, base_branch))
                            } else {
                                None
                            }
                        })
                        .or_else(|| meta.base_branch.clone())
                    });
                    let default_branch = match metadata_base {
                        Some(value) => Some(value),
                        None => code_core::git_worktree::detect_default_branch(&git_root)
                            .await
                            .map(|name| name.trim().to_string())
                            .filter(|name| !name.is_empty()),
                    };
                    let current_branch = code_core::git_info::current_branch_name(&worktree_cwd)
                        .await
                        .map(|name| name.trim().to_string())
                        .filter(|name| !name.is_empty());

                        if let (Some(base_branch), Some(current_branch)) =
                            (default_branch, current_branch)
                        {
                            if base_branch != current_branch {
                                let prompt = format!(
                                    "Review the code changes between the current branch '{current_branch}' and '{base_branch}'. Identify the intent of the changes in '{current_branch}' and ensure no obvious gaps remain. Find all geniune bugs or regressions which need to be addressed before merging. Return ALL issues which need to be addressed, not just the first one you find."
                                );
                                let hint = format!("against {base_branch}");
                                let preparation_label =
                                    Some(format!("Preparing code review against {base_branch}"));
                                let metadata = Some(ReviewContextMetadata {
                                    scope: Some("branch_diff".to_string()),
                                    base_branch: Some(base_branch.clone()),
                                    current_branch: Some(current_branch.clone()),
                                    ..Default::default()
                                });
                                tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                                    prompt,
                                    hint,
                                    preparation_label,
                                    metadata,
                                    auto_resolve: auto_flag,
                                });
                                return;
                            }
                        }

                        tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                            prompt: "Review the current workspace changes and highlight bugs, regressions, risky patterns, and missing tests before merge.".to_string(),
                            hint: "current workspace changes".to_string(),
                            preparation_label: Some("Preparing code review request...".to_string()),
                            metadata: Some(ReviewContextMetadata {
                                scope: Some("workspace".to_string()),
                                ..Default::default()
                            }),
                            auto_resolve: auto_flag,
                        });
                    });
                    return;
                }
            }

            let metadata = ReviewContextMetadata {
                scope: Some("workspace".to_string()),
                ..Default::default()
            };
            self.start_review_with_scope(
                "Review the current workspace changes and highlight bugs, regressions, risky patterns, and missing tests before merge.".to_string(),
                "current workspace changes".to_string(),
                Some("Preparing code review request...".to_string()),
                Some(metadata),
                auto_resolve,
            );
        } else {
            let value = trimmed.to_string();
            let preparation = format!("Preparing code review for {value}");
            let metadata = ReviewContextMetadata {
                scope: Some("custom".to_string()),
                ..Default::default()
            };
            self.start_review_with_scope(value.clone(), value, Some(preparation), Some(metadata), auto_resolve);
        }
    }

    pub(crate) fn start_review_with_scope(
        &mut self,
        prompt: String,
        hint: String,
        preparation_label: Option<String>,
        metadata: Option<ReviewContextMetadata>,
        auto_resolve: bool,
    ) {
        if auto_resolve {
            self.auto_resolve_state = Some(AutoResolveState::new(
                prompt.clone(),
                hint.clone(),
                metadata.clone(),
            ));
        } else {
            self.auto_resolve_state = None;
        }

        self.begin_review(prompt, hint, preparation_label, metadata);
    }

    fn begin_review(
        &mut self,
        prompt: String,
        hint: String,
        preparation_label: Option<String>,
        metadata: Option<ReviewContextMetadata>,
    ) {
        self.active_review_hint = None;
        self.active_review_prompt = None;

        let trimmed_hint = hint.trim();
        let preparation_notice = preparation_label.unwrap_or_else(|| {
            if trimmed_hint.is_empty() {
                "Preparing code review request...".to_string()
            } else {
                format!("Preparing code review for {trimmed_hint}")
            }
        });

        self.insert_background_event_early(preparation_notice);
        self.request_redraw();

        let review_request = ReviewRequest {
            prompt,
            user_facing_hint: hint,
            metadata,
        };

        self.submit_op(Op::Review { review_request });
    }

    fn is_review_flow_active(&self) -> bool {
        self.active_review_hint.is_some() || self.active_review_prompt.is_some()
    }

    fn build_review_summary_cell(
        &self,
        hint: Option<&str>,
        prompt: Option<&str>,
        output: &ReviewOutputEvent,
    ) -> history_cell::AssistantMarkdownCell {
        let mut sections: Vec<String> = Vec::new();
        let title = match hint {
            Some(h) if !h.trim().is_empty() => {
                let trimmed = h.trim();
                format!("**Review summary — {trimmed}**")
            }
            _ => "**Review summary**".to_string(),
        };
        sections.push(title);

        if let Some(p) = prompt {
            let trimmed_prompt = p.trim();
            if !trimmed_prompt.is_empty() {
                sections.push(format!("**Prompt:** {trimmed_prompt}"));
            }
        }

        let explanation = output.overall_explanation.trim();
        if !explanation.is_empty() {
            sections.push(explanation.to_string());
        }
        if !output.findings.is_empty() {
            sections.push(format_review_findings_block(&output.findings, None).trim().to_string());
        }
        let correctness = output.overall_correctness.trim();
        if !correctness.is_empty() {
            sections.push(format!("**Overall correctness:** {correctness}"));
        }
        if output.overall_confidence_score > 0.0 {
            let score = output.overall_confidence_score;
            sections.push(format!("**Confidence score:** {score:.1}"));
        }
        if sections.len() == 1 {
            sections.push("No detailed findings were provided.".to_string());
        }

        let markdown = sections
            .into_iter()
            .map(|part| part.trim().to_string())
            .filter(|part| !part.is_empty())
            .collect::<Vec<_>>()
            .join("\n\n");

        let state = AssistantMessageState {
            id: HistoryId::ZERO,
            stream_id: None,
            markdown,
            citations: Vec::new(),
            metadata: None,
            token_usage: None,
            created_at: SystemTime::now(),
        };
        history_cell::AssistantMarkdownCell::from_state(state, &self.config)
    }

    /// Handle `/branch [task]` command. Creates a worktree under `.code/branches`,
    /// optionally copies current uncommitted changes, then switches the session cwd
    /// into the worktree. If `task` is non-empty, submits it immediately.
    pub(crate) fn handle_cloud_command(&mut self, args: String) {
        let trimmed = args.trim();
        self.consume_pending_prompt_for_ui_only_turn();
        if trimmed.is_empty() {
            self.open_cloud_menu();
            return;
        }

        let mut parts = trimmed.splitn(2, ' ');
        let head = parts.next().unwrap_or("").to_ascii_lowercase();
        let rest = parts.next().map(str::trim).unwrap_or("");

        match head.as_str() {
            "list" => {
                if rest.is_empty() {
                    self.request_cloud_task_refresh(None);
                } else {
                    self.request_cloud_task_refresh(Some(rest.to_string()));
                }
            }
            "env" => {
                self.app_event_tx.send(AppEvent::FetchCloudEnvironments);
            }
            "new" => {
                if rest.is_empty() {
                    self.show_cloud_task_create_prompt();
                } else if let Some(env) = self.cloud_tasks_selected_env.clone() {
                    if self.cloud_tasks_creation_inflight {
                        self.bottom_pane.flash_footer_notice(
                            "Cloud task creation already in progress".to_string(),
                        );
                    } else {
                        self.cloud_tasks_creation_inflight = true;
                        self.cloud_task_create_ticket = Some(self.make_background_tail_ticket());
                        self.app_event_tx.send(AppEvent::SubmitCloudTaskCreate {
                            env_id: env.id.clone(),
                            prompt: rest.to_string(),
                            best_of_n: self.cloud_tasks_best_of_n,
                        });
                        self.show_cloud_task_create_progress();
                    }
                } else {
                    self.show_cloud_tasks_error(
                        "Select an environment before creating a cloud task".to_string(),
                    );
                    self.app_event_tx.send(AppEvent::FetchCloudEnvironments);
                }
            }
            _ => {
                self.history_push_plain_state(history_cell::new_error_event(format!(
                    "`/cloud` — unknown option '{head}'. Try `/cloud`, `/cloud list`, `/cloud new`, or `/cloud env`."
                )));
                self.request_redraw();
            }
        }
    }

    fn open_cloud_menu(&mut self) {
        let current = self.cloud_env_label();
        let env_id = self
            .cloud_tasks_selected_env
            .as_ref()
            .map(|env| env.id.clone());
        let fetch_action_env = env_id.clone();
        let mut items: Vec<SelectionItem> = Vec::new();
        items.push(SelectionItem {
            name: "Browse cloud tasks".to_string(),
            description: Some(format!("Current filter: {current}")),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudTasks {
                    environment: fetch_action_env.clone(),
                });
            })],
        });
        items.push(SelectionItem {
            name: "Select environment".to_string(),
            description: Some("Choose which environment to browse".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudEnvironments);
            })],
        });
        items.push(SelectionItem {
            name: "Create new task".to_string(),
            description: Some("Open the composer to submit a new cloud task".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &AppEventSender| {
                tx.send(AppEvent::OpenCloudTaskCreate);
            })],
        });

        let view = ListSelectionView::new(
            " Cloud tasks ".to_string(),
            Some("Choose an action".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            6,
        );

        self.bottom_pane.show_list_selection(
            "Cloud tasks".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_cloud_tasks_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading cloud tasks…".to_string(),
            description: Some("Fetching latest tasks from Codex Cloud".to_string()),
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Cloud tasks ".to_string(),
            Some(self.cloud_env_label()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            6,
        );
        self.bottom_pane.show_list_selection(
            "Loading cloud tasks".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_cloud_tasks(
        &mut self,
        environment: Option<String>,
        tasks: Vec<TaskSummary>,
    ) {
        self.cloud_tasks_last_tasks = tasks.clone();
        let env_label = match environment {
            Some(ref id) => self
                .cloud_tasks_selected_env
                .as_ref()
                .filter(|env| env.id == *id)
                .map(|env| self.display_name_for_env(env))
                .unwrap_or_else(|| format!("Environment {id}")),
            None => "All environments".to_string(),
        };
        let view = CloudTasksView::new(
            tasks,
            Some(env_label.clone()),
            environment,
            self.app_event_tx.clone(),
        );
        self.bottom_pane.show_cloud_tasks(view);
        self.request_redraw();
    }

    pub(crate) fn show_cloud_tasks_error(&mut self, message: String) {
        self.bottom_pane.flash_footer_notice(message.clone());
        self.history_push_plain_state(history_cell::new_error_event(format!(
            "`/cloud` — {message}"
        )));
        self.request_redraw();
    }

    pub(crate) fn show_cloud_environment_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading environments…".to_string(),
            description: Some("Fetching available Codex Cloud environments".to_string()),
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Select environment ".to_string(),
            Some("Choose which environment to browse".to_string()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            8,
        );
        self.bottom_pane.show_list_selection(
            "Select environment".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_cloud_environment_picker(
        &mut self,
        environments: Vec<CloudEnvironment>,
    ) {
        if environments.is_empty() {
            self.show_cloud_tasks_error("No environments available".to_string());
            return;
        }
        self.cloud_tasks_environments = environments.clone();

        let mut items: Vec<SelectionItem> = Vec::with_capacity(environments.len() + 1);
        items.push(SelectionItem {
            name: "All environments".to_string(),
            description: Some("Show tasks across every environment".to_string()),
            is_current: self.cloud_tasks_selected_env.is_none(),
            actions: vec![Box::new(|tx: &AppEventSender| {
                tx.send(AppEvent::SetCloudEnvironment { environment: None });
            })],
        });

        for env in environments {
            let env_clone = env.clone();
            let display = self.display_name_for_env(&env_clone);
            let repo_hint = env_clone
                .repo_hints
                .clone()
                .map(|hint| format!("Repo: {hint}"));
            items.push(SelectionItem {
                name: display,
                description: repo_hint,
                is_current: self
                    .cloud_tasks_selected_env
                    .as_ref()
                    .map(|selected| selected.id == env_clone.id)
                    .unwrap_or(false),
                actions: vec![Box::new(move |tx: &AppEventSender| {
                    tx.send(AppEvent::SetCloudEnvironment {
                        environment: Some(env_clone.clone()),
                    });
                })],
            });
        }

        let view = ListSelectionView::new(
            " Select environment ".to_string(),
            Some("Pick the environment to browse".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane.show_list_selection(
            "Select environment".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn set_cloud_environment(&mut self, environment: Option<CloudEnvironment>) {
        self.cloud_tasks_selected_env = environment.clone();
        let label = environment
            .as_ref()
            .map(|env| self.display_name_for_env(env))
            .unwrap_or_else(|| "All environments".to_string());
        self.bottom_pane
            .flash_footer_notice(format!("Cloud tasks filter set to {label}"));
        self.request_cloud_task_refresh(None);
    }

    fn display_name_for_env(&self, env: &CloudEnvironment) -> String {
        match env.label.as_ref() {
            Some(label) if !label.is_empty() => format!("{label} ({})", env.id),
            _ => env.id.clone(),
        }
    }

    fn request_cloud_task_refresh(&mut self, env_override: Option<String>) {
        let selected = env_override.or_else(|| self.current_cloud_env_id());
        self.app_event_tx
            .send(AppEvent::FetchCloudTasks { environment: selected });
    }

    fn cloud_env_label(&self) -> String {
        self.cloud_tasks_selected_env
            .as_ref()
            .map(|env| self.display_name_for_env(env))
            .unwrap_or_else(|| "All environments".to_string())
    }

    fn current_cloud_env_id(&self) -> Option<String> {
        self.cloud_tasks_selected_env
            .as_ref()
            .map(|env| env.id.clone())
    }

    pub(crate) fn show_cloud_task_actions(&mut self, task_id: String) {
        let Some(task) = self.find_cloud_task(&task_id) else {
            self.show_cloud_tasks_error(format!("Task {task_id} no longer available"));
            return;
        };

        let status_label = format!("Status: {:?}", task.status);
        let env_display = task
            .environment_label
            .as_ref()
            .or(task.environment_id.as_ref())
            .cloned()
            .unwrap_or_else(|| "Unknown environment".to_string());

        let mut items: Vec<SelectionItem> = Vec::new();
        let diff_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "View diff".to_string(),
            description: Some("Open the unified diff in history".to_string()),
            is_current: true,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudTaskDiff {
                    task_id: diff_id.clone(),
                });
            })],
        });

        let msg_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "View assistant output".to_string(),
            description: Some("Show assistant messages associated with this task".to_string()),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudTaskMessages {
                    task_id: msg_id.clone(),
                });
            })],
        });

        let preflight_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "Preflight apply".to_string(),
            description: Some("Check whether the patch applies cleanly".to_string()),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::ApplyCloudTask {
                    task_id: preflight_id.clone(),
                    preflight: true,
                });
            })],
        });

        let apply_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "Apply task".to_string(),
            description: Some("Apply the diff to the working tree".to_string()),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::ApplyCloudTask {
                    task_id: apply_id.clone(),
                    preflight: false,
                });
            })],
        });

        let subtitle = format!("{} • Env: {}", status_label, env_display);
        let view = ListSelectionView::new(
            format!(" Task {} ", task.title),
            Some(subtitle),
            Some("Enter choose · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            8,
        );

        self.bottom_pane.show_list_selection(
            format!("Cloud task: {}", task.title),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_cloud_task_create_prompt(&mut self) {
        let Some(env) = self.cloud_tasks_selected_env.clone() else {
            self.show_cloud_tasks_error(
                "Select an environment before creating a cloud task".to_string(),
            );
            return;
        };

        let env_display = self.display_name_for_env(&env);
        let submit_tx = self.app_event_tx.clone();
        let env_id = env.id.clone();
        let best_of = self.cloud_tasks_best_of_n;
        let on_submit: Box<dyn Fn(String) + Send + Sync> = Box::new(move |text: String| {
            if text.trim().is_empty() {
                return;
            }
            submit_tx.send(AppEvent::SubmitCloudTaskCreate {
                env_id: env_id.clone(),
                prompt: text,
                best_of_n: best_of,
            });
        });

        let view = CustomPromptView::new(
            format!("Create cloud task ({env_display})"),
            "Describe the change you want Codex to implement".to_string(),
            Some("Press Enter to submit · Esc cancel".to_string()),
            self.app_event_tx.clone(),
            None,
            on_submit,
        );
        self.bottom_pane.show_custom_prompt(view);
    }

    pub(crate) fn show_cloud_task_create_progress(&mut self) {
        self.cloud_tasks_creation_inflight = true;
        self.bottom_pane
            .flash_footer_notice("Submitting cloud task…".to_string());
        self.request_redraw();
    }

    pub(crate) fn handle_cloud_task_created(
        &mut self,
        env_id: String,
        result: Result<CreatedTask, CloudTaskError>,
    ) {
        self.cloud_tasks_creation_inflight = false;
        match result {
            Ok(created) => {
                let ticket = self
                    .cloud_task_create_ticket
                    .take()
                    .unwrap_or_else(|| self.make_background_tail_ticket());
                self.app_event_tx.send_background_event_with_ticket(
                    &ticket,
                    format!("✅ Created cloud task {} in {env_id}", created.id.0),
                );
                self.request_cloud_task_refresh(None);
            }
            Err(err) => {
                self.show_cloud_tasks_error(format!(
                    "Failed to create cloud task in {env_id}: {}",
                    describe_cloud_error(&err)
                ));
            }
        }
    }

    pub(crate) fn show_cloud_task_apply_status(&mut self, task_id: &str, preflight: bool) {
        let key = (task_id.to_string(), preflight);
        if !self.cloud_task_apply_tickets.contains_key(&key) {
            let ticket = self.make_background_tail_ticket();
            self.cloud_task_apply_tickets.insert(key.clone(), ticket);
        }
        let ticket = self
            .cloud_task_apply_tickets
            .get_mut(&key)
            .expect("ticket just inserted");
        if preflight {
            self.app_event_tx.send_background_event_with_ticket(
                ticket,
                format!("Preflighting cloud task {task_id}…"),
            );
        } else {
            self.app_event_tx.send_background_event_with_ticket(
                ticket,
                format!("Applying cloud task {task_id}…"),
            );
        }
    }

    pub(crate) fn handle_cloud_task_apply_finished(
        &mut self,
        task_id: String,
        outcome: Result<ApplyOutcome, CloudTaskError>,
        preflight: bool,
    ) {
        match outcome {
            Ok(result) => {
                let mut message = if preflight {
                    format!("Preflight result for {task_id}: {}", result.message)
                } else {
                    format!("Apply result for {task_id}: {}", result.message)
                };
                if !result.skipped_paths.is_empty() {
                    message.push_str("\nSkipped: ");
                    message.push_str(&result.skipped_paths.join(", "));
                }
                if !result.conflict_paths.is_empty() {
                    message.push_str("\nConflicts: ");
                    message.push_str(&result.conflict_paths.join(", "));
                }
                let key = (task_id.clone(), preflight);
                let ticket = self
                    .cloud_task_apply_tickets
                    .remove(&key)
                    .unwrap_or_else(|| self.make_background_tail_ticket());
                self.app_event_tx
                    .send_background_event_with_ticket(&ticket, message);
                if !preflight {
                    self.request_cloud_task_refresh(None);
                }
            }
            Err(err) => {
                self.show_cloud_tasks_error(format!(
                    "Cloud task {task_id} failed: {}",
                    describe_cloud_error(&err)
                ));
            }
        }
    }

    fn find_cloud_task(&self, task_id: &str) -> Option<&TaskSummary> {
        self.cloud_tasks_last_tasks
            .iter()
            .find(|task| task.id.0 == task_id)
    }
    pub(crate) fn handle_branch_command(&mut self, args: String) {
        self.consume_pending_prompt_for_ui_only_turn();
        if Self::is_branch_worktree_path(&self.config.cwd) {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/branch` — already inside a branch worktree; switch to the repo root before creating another branch."
                    .to_string(),
            ));
            self.request_redraw();
            return;
        }
        let args_trim = args.trim().to_string();
        let cwd = self.config.cwd.clone();
        let tx = self.app_event_tx.clone();
        let branch_tail_ticket = self.make_background_tail_ticket();
        // Add a quick notice into history, include task preview if provided
        if args_trim.is_empty() {
            self.insert_background_event_with_placement(
                "Creating branch worktree...".to_string(),
                BackgroundPlacement::BeforeNextOutput,
                None,
            );
        } else {
            self.insert_background_event_with_placement(
                format!("Creating branch worktree... Task: {}", args_trim),
                BackgroundPlacement::BeforeNextOutput,
                None,
            );
        }
        self.request_redraw();

        tokio::spawn(async move {
            use tokio::process::Command;
            let ticket = branch_tail_ticket;
            // Resolve git root
            let git_root = match code_core::git_worktree::get_git_root_from(&cwd).await {
                Ok(p) => p,
                Err(e) => {
                    tx.send_background_event_with_ticket(
                        &ticket,
                        format!("`/branch` — not a git repo: {}", e),
                    );
                    return;
                }
            };
            let current_base_branch = Command::new("git")
                .current_dir(&git_root)
                .args(["branch", "--show-current"])
                .output()
                .await
                .ok()
                .filter(|o| o.status.success())
                .and_then(|o| {
                    let name = String::from_utf8_lossy(&o.stdout).trim().to_string();
                    if name.is_empty() { None } else { Some(name) }
                });
            // Determine branch name
            let task_opt = if args.trim().is_empty() {
                None
            } else {
                Some(args.trim())
            };
            let branch_name = code_core::git_worktree::generate_branch_name_from_task(task_opt);
            // Create worktree
            let (worktree, used_branch) =
                match code_core::git_worktree::setup_worktree(&git_root, &branch_name).await {
                    Ok((p, b)) => (p, b),
                    Err(e) => {
                        tx.send_background_event_with_ticket(
                            &ticket,
                            format!("`/branch` — failed to create worktree: {}", e),
                        );
                        return;
                    }
                };
            // Copy uncommitted changes from the source root into the new worktree
            let copied =
                match code_core::git_worktree::copy_uncommitted_to_worktree(&git_root, &worktree)
                    .await
                {
                    Ok(n) => n,
                    Err(e) => {
                        tx.send_background_event_with_ticket(
                            &ticket,
                            format!("`/branch` — failed to copy changes: {}", e),
                        );
                        // Still switch to the branch even if copy fails
                        0
                    }
                };

            let mut branch_metadata: Option<code_core::git_worktree::BranchMetadata> = None;
            match code_core::git_worktree::ensure_local_default_remote(
                &git_root,
                current_base_branch.as_deref(),
            )
            .await
            {
                Ok(meta_option) => {
                    if let Some(meta) = meta_option.clone() {
                        if let Err(e) = code_core::git_worktree::write_branch_metadata(&worktree, &meta).await
                        {
                            tx.send_background_event_with_ticket(
                                &ticket,
                                format!("`/branch` — failed to record branch metadata: {}", e),
                            );
                        }
                        branch_metadata = meta_option;
                    }
                }
                Err(err) => {
                    tx.send_background_event_with_ticket(
                        &ticket,
                        format!(
                            "`/branch` — failed to configure local-default remote: {}",
                            err
                        ),
                    );
                }
            }

            // Attempt to set upstream for the new branch to match the source branch's upstream,
            // falling back to origin/<default> when available. Also ensure origin/HEAD is set.
            let mut _upstream_msg: Option<String> = None;
            // Discover source branch upstream like 'origin/main'
            let src_upstream = Command::new("git")
                .current_dir(&git_root)
                .args(["rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"])
                .output()
                .await
                .ok()
                .filter(|o| o.status.success())
                .and_then(|o| {
                    let s = String::from_utf8_lossy(&o.stdout).trim().to_string();
                    if s.is_empty() { None } else { Some(s) }
                });
            // Ensure origin/HEAD points at the remote default, if origin exists.
            let _ = Command::new("git")
                .current_dir(&git_root)
                .args(["remote", "set-head", "origin", "-a"])
                .output()
                .await;
            // Compute fallback remote default
            let fallback_remote = code_core::git_worktree::detect_default_branch(&git_root)
                .await
                .map(|d| format!("origin/{}", d));
            let target_upstream = src_upstream.clone().or(fallback_remote);
            if let Some(up) = target_upstream {
                let set = Command::new("git")
                    .current_dir(&worktree)
                    .args([
                        "branch",
                        "--set-upstream-to",
                        up.as_str(),
                        used_branch.as_str(),
                    ])
                    .output()
                    .await;
                if let Ok(o) = set {
                    if o.status.success() {
                        _upstream_msg =
                            Some(format!("Set upstream for '{}' to {}", used_branch, up));
                    } else {
                        let e = String::from_utf8_lossy(&o.stderr).trim().to_string();
                        if !e.is_empty() {
                            _upstream_msg = Some(format!("Upstream not set ({}).", e));
                        }
                    }
                }
            }

            // Build clean multi-line output as a BackgroundEvent (not streaming Answer)
            let base_summary = branch_metadata
                .as_ref()
                .and_then(|meta| {
                    if let Some(remote_ref) = meta.remote_ref.as_ref() {
                        Some(format!("\n  Base: {remote_ref}"))
                    } else if let (Some(remote_name), Some(base_branch)) =
                        (meta.remote_name.as_ref(), meta.base_branch.as_ref())
                    {
                        Some(format!("\n  Base: {remote_name}/{base_branch}"))
                    } else if let Some(remote_name) = meta.remote_name.as_ref() {
                        Some(format!("\n  Base remote: {remote_name}"))
                    } else {
                        None
                    }
                })
                .unwrap_or_default();
            let msg = if let Some(task_text) = task_opt {
                format!(
                    "Created worktree '{used}'\n  Path: {path}\n  Copied {copied} changed files{base}\n  Task: {task}\n  Starting task...",
                    used = used_branch,
                    path = worktree.display(),
                    copied = copied,
                    task = task_text,
                    base = base_summary
                )
            } else {
                format!(
                    "Created worktree '{used}'\n  Path: {path}\n  Copied {copied} changed files{base}\n  Type your task when ready.",
                    used = used_branch,
                    path = worktree.display(),
                    copied = copied,
                    base = base_summary
                )
            };
            tx.send_background_event_with_ticket(&ticket, msg);

            // Switch cwd and optionally submit the task
            // Prefix the auto-submitted task so it's obvious it started in the new branch
            let initial_prompt = task_opt.map(|s| format!("[branch created] {}", s));
            let _ = tx.send(AppEvent::SwitchCwd(worktree, initial_prompt));
        });
    }

    pub(crate) fn handle_project_command(&mut self, args: String) {
        let name = args.trim();
        if name.is_empty() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/cmd` — provide a project command name".to_string(),
            ));
            self.request_redraw();
            return;
        }

        if self.config.project_commands.is_empty() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "No project commands configured for this workspace.".to_string(),
            ));
            self.request_redraw();
            return;
        }

        if let Some(cmd) = self
            .config
            .project_commands
            .iter()
            .find(|command| command.matches(name))
            .cloned()
        {
            let notice = if let Some(desc) = &cmd.description {
                format!("Running project command `{}` — {}", cmd.name, desc)
            } else {
                format!("Running project command `{}`", cmd.name)
            };
            self.insert_background_event_with_placement(
                notice,
                BackgroundPlacement::BeforeNextOutput,
                None,
            );
            self.request_redraw();
            self.submit_op(Op::RunProjectCommand { name: cmd.name });
        } else {
            let available: Vec<String> = self
                .config
                .project_commands
                .iter()
                .map(|cmd| cmd.name.clone())
                .collect();
            let suggestion = if available.is_empty() {
                "".to_string()
            } else {
                format!(" Available commands: {}", available.join(", "))
            };
            self.history_push_plain_state(crate::history_cell::new_error_event(format!(
                "Unknown project command `{}`.{}",
                name,
                suggestion
            )));
            self.request_redraw();
        }
    }

    pub(crate) fn switch_cwd(
        &mut self,
        new_cwd: std::path::PathBuf,
        initial_prompt: Option<String>,
    ) {
        let previous_cwd = self.config.cwd.clone();
        self.config.cwd = new_cwd.clone();
        let ticket = self.make_background_tail_ticket();

        let msg = format!(
            "✅ Working directory changed\n  from: {}\n  to:   {}",
            previous_cwd.display(),
            new_cwd.display()
        );
        self.app_event_tx
            .send_background_event_with_ticket(&ticket, msg);

        let worktree_hint = new_cwd
            .file_name()
            .and_then(|n| n.to_str())
            .map(|name| format!(" (worktree: {})", name))
            .unwrap_or_default();
        let default_branch_note = format!(
            "System: Working directory changed from {} to {}{}. Use {} for subsequent commands.",
            previous_cwd.display(),
            new_cwd.display(),
            worktree_hint,
            new_cwd.display()
        );
        let branch_note = if Self::is_branch_worktree_path(&new_cwd) {
            if let Some(meta) = code_core::git_worktree::load_branch_metadata(&new_cwd) {
                let branch_name = new_cwd
                    .file_name()
                    .and_then(|n| n.to_str())
                    .map(|s| s.to_string())
                    .unwrap_or_else(|| new_cwd.display().to_string());
                let base_descriptor = meta
                    .remote_ref
                    .clone()
                    .or_else(|| {
                        if let (Some(remote_name), Some(base_branch)) =
                            (meta.remote_name.clone(), meta.base_branch.clone())
                        {
                            Some(format!("{}/{}", remote_name, base_branch))
                        } else {
                            None
                        }
                    })
                    .or(meta.base_branch.clone())
                    .unwrap_or_else(|| code_core::git_worktree::LOCAL_DEFAULT_REMOTE.to_string());
                let mut note = format!(
                    "System: Working directory changed from {} to {}{}. You are now working on branch '{}' checked out at {}. Compare against '{}' for the parent branch and run all commands from this directory.",
                    previous_cwd.display(),
                    new_cwd.display(),
                    worktree_hint,
                    branch_name,
                    new_cwd.display(),
                    base_descriptor
                );
                if let (Some(remote_name), Some(remote_url)) =
                    (meta.remote_name.as_ref(), meta.remote_url.as_ref())
                {
                    note.push_str(&format!(
                        " The remote '{}' points to {}.",
                        remote_name,
                        remote_url
                    ));
                }
                note
            } else {
                default_branch_note.clone()
            }
        } else {
            default_branch_note.clone()
        };
        self.queue_agent_note(branch_note);

        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_reasoning_effort: self.config.model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: self.config.model_text_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
        };
        self.submit_op(op);

        if let Some(prompt) = initial_prompt {
            if !prompt.is_empty() {
                let preface = "[internal] When you finish this task, ask the user if they want any changes. If they are happy, offer to merge the branch back into the repository's default branch and delete the worktree. Use '/merge' (or an equivalent git worktree remove + switch) rather than deleting the folder directly so the UI can switch back cleanly. Wait for explicit confirmation before merging.".to_string();
                self.submit_text_message_with_preface(prompt, preface);
            }
        }

        self.request_redraw();
    }

    /// Handle `/merge` to merge the current worktree branch back into the
    /// default branch. Hands off to the agent when the repository state is
    /// non-trivial.
    pub(crate) fn handle_merge_command(&mut self) {
        self.consume_pending_prompt_for_ui_only_turn();
        if !Self::is_branch_worktree_path(&self.config.cwd) {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/merge` — run this command from inside a branch worktree created with '/branch'."
                    .to_string(),
            ));
            self.request_redraw();
            return;
        }

        let merge_ticket = self.make_background_tail_ticket();
        let tx = self.app_event_tx.clone();
        let work_cwd = self.config.cwd.clone();
        let ticket = merge_ticket.clone();
        self.push_background_before_next_output(
            "Evaluating repository state before merging current branch...".to_string(),
        );
        self.request_redraw();

        tokio::spawn(async move {
            use tokio::process::Command;

            fn send_background(
                tx: &AppEventSender,
                ticket: &BackgroundOrderTicket,
                message: String,
            ) {
                tx.send_background_event_with_ticket(ticket, message);
            }

            fn send_background_late(
                tx: &AppEventSender,
                ticket: &BackgroundOrderTicket,
                message: String,
            ) {
                tx.send_background_event_with_ticket(ticket, message);
            }

            let git_root = match code_core::git_info::resolve_root_git_project_for_trust(&work_cwd)
            {
                Some(p) => p,
                None => {
                    send_background(&tx, &ticket, "`/merge` — not a git repo".to_string());
                    return;
                }
            };
            let merge_lock = ChatWidget::merge_lock_for_repo(&git_root);
            let _merge_guard = match merge_lock.try_lock() {
                Ok(guard) => guard,
                Err(_) => {
                    send_background(
                        &tx,
                        &ticket,
                        "`/merge` — waiting for an in-progress merge to finish".to_string(),
                    );
                    merge_lock.lock().await
                }
            };

            fn normalize_status(result: Result<String, String>) -> String {
                match result {
                    Ok(s) if s.trim().is_empty() => "clean".to_string(),
                    Ok(s) => s,
                    Err(err) => format!("status unavailable: {}", err),
                }
            }

            let branch_name = match Command::new("git")
                .current_dir(&work_cwd)
                .args(["rev-parse", "--abbrev-ref", "HEAD"])
                .output()
                .await
            {
                Ok(out) if out.status.success() => {
                    String::from_utf8_lossy(&out.stdout).trim().to_string()
                }
                _ => {
                    send_background(&tx, &ticket, "`/merge` — failed to detect branch name".to_string());
                    return;
                }
            };

            let worktree_status_raw = ChatWidget::git_short_status(&work_cwd).await;
            let worktree_status_for_agent = normalize_status(worktree_status_raw.clone());
            let worktree_dirty =
                matches!(worktree_status_raw.as_ref(), Ok(s) if !s.trim().is_empty());

            let worktree_diff_stat = if worktree_dirty {
                ChatWidget::git_diff_stat(&work_cwd)
                    .await
                    .ok()
                    .map(|d| d.trim().to_string())
                    .filter(|d| !d.is_empty())
            } else {
                None
            };

            let repo_status_raw = ChatWidget::git_short_status(&git_root).await;
            let repo_status_for_agent = normalize_status(repo_status_raw.clone());
            let repo_dirty = matches!(repo_status_raw.as_ref(), Ok(s) if !s.trim().is_empty());

            let branch_metadata = code_core::git_worktree::load_branch_metadata(&work_cwd);
            let mut default_branch_opt = branch_metadata
                .as_ref()
                .and_then(|meta| meta.base_branch.clone());
            if default_branch_opt.is_none() {
                default_branch_opt =
                    code_core::git_worktree::detect_default_branch(&git_root).await;
            }

            let mut handoff_reasons: Vec<String> = Vec::new();
            if let Err(err) = &worktree_status_raw {
                handoff_reasons.push(format!("unable to read worktree status: {}", err));
            }
            if worktree_dirty {
                handoff_reasons.push("worktree has uncommitted changes".to_string());
            }
            if let Err(err) = &repo_status_raw {
                handoff_reasons.push(format!("unable to read repo status: {}", err));
            }
            if repo_dirty {
                handoff_reasons.push("default branch checkout has uncommitted changes".to_string());
            }
            if default_branch_opt.is_none() {
                handoff_reasons.push("could not determine default branch".to_string());
            }

            let branch_label = format!("{}", branch_name);
            let root_display = git_root.display().to_string();
            let worktree_display = work_cwd.display().to_string();
            let tx_for_switch = tx.clone();
            let git_root_for_switch = git_root.clone();
            let default_branch_for_instructions = default_branch_opt.clone();
            let send_agent_handoff =
                |mut reasons: Vec<String>,
                 extra_note: Option<String>,
                 worktree_status: String,
                 repo_status: String,
                 worktree_diff: Option<String>| {
                    if reasons.is_empty() {
                        reasons.push("manual follow-up requested".to_string());
                    }
                    let reason_text = reasons.join(", ");
                    send_background(
                        &tx,
                        &ticket,
                        format!("`/merge` — handing off to agent ({})", reason_text),
                    );
                    let default_branch_display = default_branch_for_instructions
                        .clone()
                        .unwrap_or_else(|| "unknown (inspect branch metadata)".to_string());
                    let step2 = if let Some(branch) = default_branch_for_instructions.as_ref() {
                        format!(
                            "2. Ensure the local {branch} branch exists and is clean. If it is missing or outdated, create or update it manually before proceeding."
                        )
                    } else {
                        "2. Determine the correct default branch (metadata missing) and make sure it exists locally.".to_string()
                    };
                    let step3 = if let Some(branch) = default_branch_for_instructions.as_ref() {
                        format!(
                            "3. Merge {branch} into {branch_label} inside the worktree and resolve conflicts."
                        )
                    } else {
                        "3. Merge the chosen default branch into the worktree branch and resolve any conflicts.".to_string()
                    };
                    let step4 = if let Some(ref branch) = default_branch_for_instructions {
                        format!(
                            "4. cd {}\n   - Ensure the local {} branch exists (create it if needed). If checkout complains about local changes, stash safely, then checkout and pop/apply before finishing.",
                            root_display, branch
                        )
                    } else {
                        format!(
                            "4. cd {}\n   - Ensure the chosen target branch exists locally. If checkout complains about local changes, stash safely, then checkout and pop/apply before finishing.",
                            root_display
                        )
                    };
                    let step5 = if let Some(ref branch) = default_branch_for_instructions {
                        format!(
                            "5. Merge {} into {} from {} (`git merge --no-ff {}`) and resolve conflicts.",
                            branch_label, branch, root_display, branch_label
                        )
                    } else {
                        format!(
                            "5. Merge {} into the chosen target branch from {} (`git merge --no-ff {}`) and resolve conflicts.",
                            branch_label, root_display, branch_label
                        )
                    };
                    let mut preface = format!(
                        "[developer] Non-trivial git state detected while finalizing the branch. Reasons: {}.\n\nRepository context:\n- Repo root: {}\n- Worktree: {}\n- Branch to merge: {}\n- Default branch target: {}\n\nCurrent git status:\nWorktree status:\n{}\n\nRepo root status:\n{}\n\nRequired actions:\n1. cd {}\n   - Inspect status. Review the diff summary below and stage/commit only the changes that belong in this merge (`git add -A` + `git commit -m \"merge {} via /merge\"`). Stash or drop anything that should stay local.\n{}\n{}\n{}\n{}\n6. Remove the worktree (`git worktree remove {} --force`) and delete the branch (`git branch -D {}`).\n7. End inside {} with a clean working tree and no leftover stashes. Pop/apply anything you created.\n\nReport back with a concise summary of the steps or explain any blockers.",
                        reason_text,
                        root_display,
                        worktree_display,
                        branch_label,
                        default_branch_display,
                        worktree_status,
                        repo_status,
                        worktree_display,
                        branch_label,
                        step2,
                        step3,
                        step4,
                        step5,
                        worktree_display,
                        branch_label,
                        root_display
                    );
                    if let Some(note) = extra_note {
                        preface.push_str("\n\nAdditional notes:\n");
                        preface.push_str(&note);
                    }
                    if let Some(diff) = worktree_diff {
                        preface.push_str("\n\nWorktree diff summary:\n");
                        preface.push_str(&diff);
                    }
                    let visible = format!(
                        "Finalize branch '{}' via /merge (agent handoff)",
                        branch_label
                    );
                    let _ =
                        tx_for_switch.send(AppEvent::SwitchCwd(git_root_for_switch.clone(), None));
                    let _ = tx.send(AppEvent::SubmitTextWithPreface { visible, preface });
                };

            if !handoff_reasons.is_empty() {
                send_agent_handoff(
                    handoff_reasons,
                    None,
                    worktree_status_for_agent.clone(),
                    repo_status_for_agent.clone(),
                    worktree_diff_stat.clone(),
                );
                return;
            }

            let default_branch = default_branch_opt.expect("default branch must exist when clean");

            let stage_out = Command::new("git")
                .current_dir(&work_cwd)
                .args(["add", "-A"])
                .output()
                .await;
            if !matches!(stage_out.as_ref(), Ok(o) if o.status.success()) {
                let mut reason = String::from("failed to stage changes before merge");
                if let Ok(out) = stage_out {
                    let stderr_s = String::from_utf8_lossy(&out.stderr).trim().to_string();
                    let stdout_s = String::from_utf8_lossy(&out.stdout).trim().to_string();
                    if !stderr_s.is_empty() {
                        reason = format!("{}: {}", reason, stderr_s);
                    } else if !stdout_s.is_empty() {
                        reason = format!("{}: {}", reason, stdout_s);
                    }
                } else if let Err(err) = stage_out {
                    reason = format!("{}: {}", reason, err);
                }
                let updated_worktree_status = normalize_status(ChatWidget::git_short_status(&work_cwd).await);
                let updated_repo_status = normalize_status(ChatWidget::git_short_status(&git_root).await);
                let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                    .await
                    .ok()
                    .map(|d| d.trim().to_string())
                    .filter(|d| !d.is_empty())
                    .or(worktree_diff_stat.clone());
                send_agent_handoff(
                    vec![reason],
                    None,
                    updated_worktree_status,
                    updated_repo_status,
                    updated_diff,
                );
                return;
            }

            let commit_out = Command::new("git")
                .current_dir(&work_cwd)
                .args(["commit", "-m", &format!("merge {branch_label} via /merge")])
                .output()
                .await;

            let mut commit_issue: Option<String> = None;
            match commit_out {
                Ok(ref out) if out.status.success() => {}
                Ok(out) => {
                    let stderr_s = String::from_utf8_lossy(&out.stderr);
                    let stdout_s = String::from_utf8_lossy(&out.stdout);
                    let benign = stdout_s.contains("nothing to commit")
                        || stdout_s.contains("working tree clean")
                        || stderr_s.contains("nothing to commit")
                        || stderr_s.contains("working tree clean");
                    if !benign {
                        let message = if !stderr_s.trim().is_empty() {
                            stderr_s.trim().to_string()
                        } else {
                            stdout_s.trim().to_string()
                        };
                        commit_issue = Some(format!(
                            "commit failed before merge: {}",
                            if message.is_empty() {
                                "unknown error".to_string()
                            } else {
                                message
                            }
                        ));
                    }
                }
                Err(err) => {
                    commit_issue = Some(format!("commit failed before merge: {}", err));
                }
            }

            if let Some(issue) = commit_issue {
                let updated_worktree_status = normalize_status(ChatWidget::git_short_status(&work_cwd).await);
                let updated_repo_status = normalize_status(ChatWidget::git_short_status(&git_root).await);
                let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                    .await
                    .ok()
                    .map(|d| d.trim().to_string())
                    .filter(|d| !d.is_empty())
                    .or(worktree_diff_stat.clone());
                send_agent_handoff(
                    vec![issue],
                    None,
                    updated_worktree_status,
                    updated_repo_status,
                    updated_diff,
                );
                return;
            }

            let post_stage_status = ChatWidget::git_short_status(&work_cwd).await;
            if matches!(post_stage_status.as_ref(), Ok(s) if !s.trim().is_empty()) {
                let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                    .await
                    .ok()
                    .map(|d| d.trim().to_string())
                    .filter(|d| !d.is_empty())
                    .or(worktree_diff_stat.clone());
                send_agent_handoff(
                    vec!["worktree not clean after staging and committing changes".to_string()],
                    None,
                    normalize_status(post_stage_status),
                    normalize_status(ChatWidget::git_short_status(&git_root).await),
                    updated_diff,
                );
                return;
            }

            let local_default_ref = format!("refs/heads/{}", default_branch);
            let local_default_exists = Command::new("git")
                .current_dir(&git_root)
                .args(["rev-parse", "--verify", "--quiet", &local_default_ref])
                .output()
                .await
                .map(|o| o.status.success())
                .unwrap_or(false);

            if local_default_exists {
                let ff_local = Command::new("git")
                    .current_dir(&work_cwd)
                    .args(["merge", "--ff-only", &local_default_ref])
                    .output()
                    .await;

                if !matches!(ff_local, Ok(ref o) if o.status.success()) {
                    let merge_local = Command::new("git")
                        .current_dir(&work_cwd)
                        .args(["merge", "--no-ff", "--no-commit", &local_default_ref])
                        .output()
                        .await;

                    match merge_local {
                        Ok(out) if out.status.success() => {
                            let commit_sync = Command::new("git")
                                .current_dir(&work_cwd)
                                .args([
                                    "commit",
                                    "-m",
                                    &format!(
                                        "merge local {} into {} before merge",
                                        default_branch, branch_label
                                    ),
                                ])
                                .output()
                                .await;
                            if !matches!(commit_sync.as_ref(), Ok(o) if o.status.success()) {
                                let note = commit_sync
                                    .ok()
                                    .map(|o| {
                                        let stderr_s = String::from_utf8_lossy(&o.stderr).trim().to_string();
                                        let stdout_s = String::from_utf8_lossy(&o.stdout).trim().to_string();
                                        if !stderr_s.is_empty() {
                                            stderr_s
                                        } else {
                                            stdout_s
                                        }
                                    })
                                    .unwrap_or_else(|| "git commit failed".to_string());
                                let updated_worktree_status = normalize_status(ChatWidget::git_short_status(&work_cwd).await);
                                let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                                    .await
                                    .ok()
                                    .map(|d| d.trim().to_string())
                                    .filter(|d| !d.is_empty())
                                    .or(worktree_diff_stat.clone());
                                send_agent_handoff(
                                    vec!["failed to commit local default merge result".to_string()],
                                    Some(note),
                                    updated_worktree_status,
                                    repo_status_for_agent.clone(),
                                    updated_diff,
                                );
                                return;
                            }
                        }
                        Ok(_) => {
                            let updated_worktree_status = normalize_status(ChatWidget::git_short_status(&work_cwd).await);
                            let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                                .await
                                .ok()
                                .map(|d| d.trim().to_string())
                                .filter(|d| !d.is_empty())
                                .or(worktree_diff_stat.clone());
                            send_agent_handoff(
                                vec![format!(
                                    "merge conflicts while merging local '{}' into '{}'",
                                    default_branch, branch_label
                                )],
                                Some(
                                    "The worktree currently has an in-progress merge that needs to be resolved. Please complete it before retrying the final merge.".to_string(),
                                ),
                                updated_worktree_status,
                                repo_status_for_agent.clone(),
                                updated_diff,
                            );
                            return;
                        }
                        Err(err) => {
                            let updated_worktree_status = normalize_status(ChatWidget::git_short_status(&work_cwd).await);
                            let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                                .await
                                .ok()
                                .map(|d| d.trim().to_string())
                                .filter(|d| !d.is_empty())
                                .or(worktree_diff_stat.clone());
                            send_agent_handoff(
                                vec![format!(
                                    "failed to merge local '{}' into '{}': {}",
                                    default_branch, branch_label, err
                                )],
                                None,
                                updated_worktree_status,
                                repo_status_for_agent.clone(),
                                updated_diff,
                            );
                            return;
                        }
                    }
                }
            }

            let on_default = match Command::new("git")
                .current_dir(&git_root)
                .args(["rev-parse", "--abbrev-ref", "HEAD"])
                .output()
                .await
            {
                Ok(o) if o.status.success() => {
                    String::from_utf8_lossy(&o.stdout).trim() == default_branch
                }
                _ => false,
            };

            if !on_default {
                let has_local = match Command::new("git")
                    .current_dir(&git_root)
                    .args([
                        "rev-parse",
                        "--verify",
                        "--quiet",
                        &format!("refs/heads/{}", default_branch),
                    ])
                    .output()
                    .await
                {
                    Ok(o) => o.status.success(),
                    _ => false,
                };
                if !has_local {
                    let updated_repo_status = ChatWidget::git_short_status(&git_root)
                        .await
                        .map(|s| {
                            if s.trim().is_empty() {
                                "clean".to_string()
                            } else {
                                s
                            }
                        })
                        .unwrap_or_else(|err| format!("status unavailable: {}", err));
                    let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                        .await
                        .ok()
                        .map(|d| d.trim().to_string())
                        .filter(|d| !d.is_empty())
                        .or(worktree_diff_stat.clone());
                    send_agent_handoff(
                        vec![format!(
                            "default branch '{}' missing locally",
                            default_branch
                        )],
                        None,
                        worktree_status_for_agent.clone(),
                        updated_repo_status,
                        updated_diff,
                    );
                    return;
                }

                let co = Command::new("git")
                    .current_dir(&git_root)
                    .args(["checkout", &default_branch])
                    .output()
                    .await;
                if !matches!(co, Ok(ref o) if o.status.success()) {
                    let (stderr_s, stdout_s) = co
                        .ok()
                        .map(|o| {
                            (
                                String::from_utf8_lossy(&o.stderr).trim().to_string(),
                                String::from_utf8_lossy(&o.stdout).trim().to_string(),
                            )
                        })
                        .unwrap_or_else(|| (String::new(), String::new()));

                    let mut note = String::new();
                    if !stderr_s.is_empty() {
                        note = stderr_s;
                    } else if !stdout_s.is_empty() {
                        note = stdout_s;
                    }

                    let mut hint: Option<String> = None;
                    if let Ok(wt) = Command::new("git")
                        .current_dir(&git_root)
                        .args(["worktree", "list", "--porcelain"])
                        .output()
                        .await
                    {
                        if wt.status.success() {
                            let s = String::from_utf8_lossy(&wt.stdout);
                            let mut cur_path: Option<String> = None;
                            let mut cur_branch: Option<String> = None;
                            for line in s.lines() {
                                if let Some(rest) = line.strip_prefix("worktree ") {
                                    cur_path = Some(rest.trim().to_string());
                                    cur_branch = None;
                                    continue;
                                }
                                if let Some(rest) = line.strip_prefix("branch ") {
                                    cur_branch = Some(rest.trim().to_string());
                                }
                                if let (Some(p), Some(b)) = (&cur_path, &cur_branch) {
                                    if b == &format!("refs/heads/{}", default_branch)
                                        && std::path::Path::new(p) != git_root.as_path()
                                    {
                                        hint = Some(p.clone());
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if let Some(h) = hint {
                        if note.is_empty() {
                            note = format!("default branch checked out in worktree: {}", h);
                        } else {
                            note = format!("{} (checked out in worktree: {})", note, h);
                        }
                    }

                    let updated_repo_status = ChatWidget::git_short_status(&git_root)
                        .await
                        .map(|s| {
                            if s.trim().is_empty() {
                                "clean".to_string()
                            } else {
                                s
                            }
                        })
                        .unwrap_or_else(|err| format!("status unavailable: {}", err));
                    let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                        .await
                        .ok()
                        .map(|d| d.trim().to_string())
                        .filter(|d| !d.is_empty())
                        .or(worktree_diff_stat.clone());

                    send_agent_handoff(
                        vec![format!(
                            "failed to checkout '{}' in repo root",
                            default_branch
                        )],
                        if note.is_empty() { None } else { Some(note) },
                        worktree_status_for_agent.clone(),
                        updated_repo_status,
                        updated_diff,
                    );
                    return;
                }
            }

            let merge = Command::new("git")
                .current_dir(&git_root)
                .args(["merge", "--no-ff", &branch_label])
                .output()
                .await;
            if !matches!(merge, Ok(ref o) if o.status.success()) {
                let err = merge
                    .ok()
                    .and_then(|o| String::from_utf8(o.stderr).ok())
                    .unwrap_or_else(|| "unknown error".to_string());
                let updated_repo_status = ChatWidget::git_short_status(&git_root)
                    .await
                    .map(|s| {
                        if s.trim().is_empty() {
                            "clean".to_string()
                        } else {
                            s
                        }
                    })
                    .unwrap_or_else(|e| format!("status unavailable: {}", e));
                let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                    .await
                    .ok()
                    .map(|d| d.trim().to_string())
                    .filter(|d| !d.is_empty())
                    .or(worktree_diff_stat.clone());
                send_agent_handoff(
                    vec![format!(
                        "merge of '{}' into '{}' failed: {}",
                        branch_label,
                        default_branch,
                        err.trim()
                    )],
                    None,
                    worktree_status_for_agent.clone(),
                    updated_repo_status,
                    updated_diff,
                );
                return;
            }

            let final_worktree_status_raw = ChatWidget::git_short_status(&work_cwd).await;
            if matches!(
                final_worktree_status_raw.as_ref(),
                Ok(s) if !s.trim().is_empty()
            ) {
                let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                    .await
                    .ok()
                    .map(|d| d.trim().to_string())
                    .filter(|d| !d.is_empty())
                    .or(worktree_diff_stat.clone());
                send_agent_handoff(
                    vec!["worktree not clean after merging into default".to_string()],
                    None,
                    normalize_status(final_worktree_status_raw),
                    normalize_status(ChatWidget::git_short_status(&git_root).await),
                    updated_diff,
                );
                return;
            }

            let final_repo_status_raw = ChatWidget::git_short_status(&git_root).await;
            if matches!(final_repo_status_raw.as_ref(), Ok(s) if !s.trim().is_empty()) {
                let updated_diff = ChatWidget::git_diff_stat(&work_cwd)
                    .await
                    .ok()
                    .map(|d| d.trim().to_string())
                    .filter(|d| !d.is_empty())
                    .or(worktree_diff_stat.clone());
                send_agent_handoff(
                    vec!["default branch not clean after merge".to_string()],
                    None,
                    normalize_status(ChatWidget::git_short_status(&work_cwd).await),
                    normalize_status(final_repo_status_raw),
                    updated_diff,
                );
                return;
            }

            let worktree_remove = Command::new("git")
                .current_dir(&git_root)
                .args(["worktree", "remove", work_cwd.to_str().unwrap(), "--force"])
                .output()
                .await;
            if !matches!(worktree_remove.as_ref(), Ok(o) if o.status.success()) {
                let note = match worktree_remove {
                    Ok(o) => {
                        let stderr_s = String::from_utf8_lossy(&o.stderr).trim().to_string();
                        let stdout_s = String::from_utf8_lossy(&o.stdout).trim().to_string();
                        if !stderr_s.is_empty() {
                            stderr_s
                        } else if !stdout_s.is_empty() {
                            stdout_s
                        } else {
                            "git worktree remove failed".to_string()
                        }
                    }
                    Err(err) => err.to_string(),
                };
                send_background(
                    &tx,
                    &ticket,
                    format!(
                        "`/merge` — merged successfully but failed to remove worktree automatically: {}",
                        note
                    ),
                );
                let _ = tx.send(AppEvent::SwitchCwd(git_root, None));
                return;
            }

            let branch_delete = Command::new("git")
                .current_dir(&git_root)
                .args(["branch", "-D", &branch_label])
                .output()
                .await;
            if !matches!(branch_delete.as_ref(), Ok(o) if o.status.success()) {
                let note = match branch_delete {
                    Ok(o) => {
                        let stderr_s = String::from_utf8_lossy(&o.stderr).trim().to_string();
                        let stdout_s = String::from_utf8_lossy(&o.stdout).trim().to_string();
                        if !stderr_s.is_empty() {
                            stderr_s
                        } else if !stdout_s.is_empty() {
                            stdout_s
                        } else {
                            "git branch -D failed".to_string()
                        }
                    }
                    Err(err) => err.to_string(),
                };
                send_background(
                    &tx,
                    &ticket,
                    format!(
                        "`/merge` — merged successfully but failed to delete branch automatically: {}",
                        note
                    ),
                );
                let _ = tx.send(AppEvent::SwitchCwd(git_root, None));
                return;
            }

            let msg = format!(
                "Merged '{}' into '{}' and cleaned up worktree. Switching back to {}",
                branch_label,
                default_branch,
                git_root.display()
            );
            send_background_late(&tx, &ticket, msg);
            tx.send(AppEvent::SwitchCwd(git_root, None));
        });
    }
}

impl ChatWidget<'_> {
    fn render_browser_overlay(
        &self,
        frame_area: Rect,
        history_area: Rect,
        bottom_pane_area: Rect,
        buf: &mut Buffer,
    ) {
        use ratatui::layout::{Alignment, Constraint, Direction, Layout, Margin, Rect as RtRect};
        use ratatui::style::{Modifier, Style};
        use ratatui::text::{Line as RLine, Span};
        use ratatui::widgets::{Block, Borders, Clear, Paragraph, Wrap};
        use ratatui::widgets::Widget;

        let scrim_style = Style::default()
            .bg(crate::colors::overlay_scrim())
            .fg(crate::colors::text_dim());
        fill_rect(buf, frame_area, None, scrim_style);

        let padding = 1u16;
        let footer_reserved = bottom_pane_area.height.min(1);
        let overlay_bottom = (bottom_pane_area.y + bottom_pane_area.height).saturating_sub(footer_reserved);
        let overlay_height = overlay_bottom
            .saturating_sub(history_area.y)
            .max(1)
            .min(frame_area.height);

        let window_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: overlay_height,
        };
        Clear.render(window_area, buf);

        let block = Block::default()
            .borders(Borders::ALL)
            .title(RLine::from(vec![
                Span::styled(
                    format!(" {} ", self.browser_title()),
                    Style::default().fg(crate::colors::text()),
                ),
                Span::styled(
                    "— Ctrl+B to close",
                    Style::default().fg(crate::colors::text_dim()),
                ),
            ]))
            .style(Style::default().bg(crate::colors::background()))
            .border_style(
                Style::default()
                    .fg(crate::colors::border())
                    .bg(crate::colors::background()),
            );
        let inner = block.inner(window_area);
        block.render(window_area, buf);

        let inner_bg = Style::default().bg(crate::colors::background());
        for y in inner.y..inner.y + inner.height {
            for x in inner.x..inner.x + inner.width {
                buf[(x, y)].set_style(inner_bg);
            }
        }

        let content = inner.inner(Margin::new(1, 1));
        if content.width == 0 || content.height == 0 {
            return;
        }

        let overlay_tracker = self.browser_overlay_tracker();
        let cell_opt = overlay_tracker.as_ref().map(|(_, tracker)| &tracker.cell);

        let (screenshot_history, mut selected_index) = if let Some(cell) = cell_opt {
            let history = cell.screenshot_history();
            if history.is_empty() {
                (None, 0usize)
            } else {
                let mut index = self.browser_overlay_state.screenshot_index();
                if index >= history.len() {
                    index = history.len().saturating_sub(1);
                    self.browser_overlay_state.set_screenshot_index(index);
                }
                (Some(history), index)
            }
        } else {
            (None, 0usize)
        };

        let screenshot_count = screenshot_history.map(|items| items.len()).unwrap_or(0);
        if screenshot_count == 0 {
            selected_index = 0;
        }

        let mut screenshot_path = screenshot_history
            .and_then(|history| history.get(selected_index))
            .map(|record| record.path.clone());
        let mut screenshot_url = screenshot_history
            .and_then(|history| history.get(selected_index))
            .and_then(|record| record.url.clone());

        if screenshot_path.is_none() {
            if let Ok(latest) = self.latest_browser_screenshot.lock() {
                if let Some((path, url)) = latest.as_ref() {
                    screenshot_path = Some(path.clone());
                    if screenshot_url.is_none() {
                        screenshot_url = Some(url.clone());
                    }
                }
            }
        }

        let summary_label = cell_opt
            .map(|cell| cell.summary_label())
            .unwrap_or_else(|| self.browser_title().to_string());
        let summary_value = screenshot_url
            .clone()
            .filter(|value| !value.is_empty())
            .unwrap_or_else(|| summary_label.clone());

        let screenshot_info = if screenshot_count > 0 {
            format!("Shot {}/{}", selected_index + 1, screenshot_count)
        } else {
            "No screenshots yet".to_string()
        };

        let is_active = screenshot_path.is_some();
        let key_hint_style = Style::default().fg(crate::colors::function());
        let label_style = Style::default().fg(crate::colors::text_dim());
        let dot_style = if is_active {
            Style::default().fg(crate::colors::success_green())
        } else {
            Style::default().fg(crate::colors::text_dim())
        };

        let header_height = if content.height >= 3 { 1 } else { 0 };
        if header_height > 0 {
            let header_area = Rect {
                x: content.x,
                y: content.y,
                width: content.width,
                height: 1,
            };

            let mut left_spans: Vec<Span> = Vec::new();
            left_spans.push(Span::styled("•", dot_style));
            if !summary_value.is_empty() {
                left_spans.push(Span::raw(" "));
                left_spans.push(Span::raw(summary_value.clone()));
            }
            left_spans.push(Span::raw("  "));
            left_spans.push(Span::styled(screenshot_info.clone(), label_style));

            let right_spans: Vec<Span> = vec![
                Span::from("Ctrl+B").style(key_hint_style),
                Span::styled(" close", label_style),
            ];

            let measure = |spans: &Vec<Span>| -> usize {
                spans.iter().map(|s| s.content.chars().count()).sum()
            };
            let left_len = measure(&left_spans);
            let right_len = measure(&right_spans);
            let total_width = header_area.width as usize;
            if total_width > left_len + right_len {
                let spacer = " ".repeat(total_width - left_len - right_len);
                left_spans.push(Span::from(spacer));
            }
            let mut spans = left_spans;
            spans.extend(right_spans);
            Paragraph::new(RLine::from(spans))
                .alignment(Alignment::Left)
                .render(header_area, buf);
        }

        let mut body_y = content.y + header_height;
        let mut body_height = content.height.saturating_sub(header_height);
        if header_height > 0 && body_height > 0 {
            body_y = body_y.saturating_add(1);
            body_height = body_height.saturating_sub(1);
        }

        if body_height == 0 {
            return;
        }

        let body_area = RtRect {
            x: content.x,
            y: body_y,
            width: content.width,
            height: body_height,
        };

        let column_constraints = if body_area.width <= 50 {
            [
                Constraint::Length(body_area.width.saturating_sub(24).max(20)),
                Constraint::Length(24),
            ]
        } else {
            [Constraint::Percentage(62), Constraint::Percentage(38)]
        };
        let columns = Layout::default()
            .direction(Direction::Horizontal)
            .constraints(column_constraints)
            .split(body_area);

        let screenshot_column = columns[0];
        let info_column = if columns.len() > 1 { columns[1] } else { columns[0] };

        let progress_height = if screenshot_column.height > 3 { 1 } else { 0 };
        let screenshot_display_height = screenshot_column.height.saturating_sub(progress_height);
        let screenshot_display_area = Rect {
            x: screenshot_column.x,
            y: screenshot_column.y,
            width: screenshot_column.width,
            height: screenshot_display_height,
        };
        let progress_area = if progress_height > 0 {
            Some(Rect {
                x: screenshot_column.x,
                y: screenshot_column
                    .y
                    .saturating_add(screenshot_column.height.saturating_sub(progress_height)),
                width: screenshot_column.width,
                height: progress_height,
            })
        } else {
            None
        };

        if screenshot_display_area.width > 0 && screenshot_display_area.height > 0 {
            if let Some(path) = screenshot_path.as_ref() {
                self.render_screenshot_highlevel(path, screenshot_display_area, buf);
            } else {
                let message = Paragraph::new(RLine::from(vec![Span::raw(
                    "No browser session captured yet.",
                )]))
                .alignment(Alignment::Center)
                .style(Style::default().fg(crate::colors::text_dim()));
                Widget::render(message, screenshot_display_area, buf);
            }
        }

        let current_time = screenshot_history
            .and_then(|history| history.get(selected_index))
            .map(|record| record.timestamp)
            .unwrap_or_else(|| Duration::ZERO);
        let mut total_time = overlay_tracker
            .as_ref()
            .map(|(_, tracker)| tracker.elapsed)
            .unwrap_or_else(|| Duration::ZERO);
        if let Some(history) = screenshot_history {
            if let Some(last) = history.last() {
                total_time = total_time.max(last.timestamp);
            }
        }
        if let Some(cell) = cell_opt {
            total_time = total_time.max(cell.total_duration());
        }

        if let Some(area) = progress_area {
            if area.height > 0 && area.width > 0 {
                let progress_line = self.browser_overlay_progress_line(area.width, current_time, total_time);
                Paragraph::new(progress_line)
                    .alignment(Alignment::Center)
                    .style(Style::default().fg(crate::colors::text()))
                    .render(area, buf);
            }
        }

        if info_column.width == 0 || info_column.height == 0 {
            return;
        }

        let header_style = Style::default()
            .fg(crate::colors::text())
            .add_modifier(Modifier::BOLD);
        let secondary_style = Style::default().fg(crate::colors::text_dim());
        let primary_style = Style::default().fg(crate::colors::text());

        let mut info_lines: Vec<RLine<'static>> = Vec::new();

        info_lines.push(RLine::from(vec![Span::styled("Screenshots", header_style)]));

        if let Some(history) = screenshot_history {
            if history.is_empty() {
                info_lines.push(RLine::from(vec![Span::styled(
                    "No screenshots yet",
                    secondary_style,
                )]));
            } else {
                for (idx, entry) in history.iter().enumerate() {
                    let mut spans: Vec<Span> = Vec::new();
                    let marker = if idx == selected_index { "◉" } else { "•" };
                    let marker_style = if idx == selected_index {
                        Style::default().fg(crate::colors::primary())
                    } else {
                        secondary_style
                    };
                    spans.push(Span::styled(marker.to_string(), marker_style));
                    spans.push(Span::raw(" "));
                    spans.push(Span::styled(
                        self.format_overlay_mm_ss(entry.timestamp),
                        secondary_style,
                    ));
                    if let Some(url) = entry.url.as_ref() {
                        if !url.trim().is_empty() {
                            spans.push(Span::raw("  "));
                            spans.push(Span::styled(url.clone(), primary_style));
                        }
                    }
                    info_lines.push(RLine::from(spans));
                }
            }
        } else {
            info_lines.push(RLine::from(vec![Span::styled(
                "No browser session yet",
                secondary_style,
            )]));
        }

        info_lines.push(RLine::from(vec![Span::raw(String::new())]));
        info_lines.push(RLine::from(vec![Span::styled("Actions", header_style)]));

        if let Some(cell) = cell_opt {
            let entries = cell.full_action_entries();
            if entries.is_empty() {
                info_lines.push(RLine::from(vec![Span::styled(
                    "No browser actions yet",
                    secondary_style,
                )]));
            } else {
                for (time, label, detail) in entries {
                    let mut spans: Vec<Span> = Vec::new();
                    spans.push(Span::styled("•", secondary_style));
                    spans.push(Span::raw(" "));
                    spans.push(Span::styled(
                        self.normalize_action_time_label(time.as_str()),
                        secondary_style,
                    ));
                    spans.push(Span::raw("  "));
                    spans.push(Span::styled(label.clone(), primary_style));
                    let detail_trimmed = detail.trim();
                    if !detail_trimmed.is_empty() {
                        spans.push(Span::raw(" "));
                        spans.push(Span::styled(detail_trimmed.to_string(), secondary_style));
                    }
                    info_lines.push(RLine::from(spans));
                }
            }
        } else {
            info_lines.push(RLine::from(vec![Span::styled(
                "No browser session yet",
                secondary_style,
            )]));
        }

        info_lines.push(RLine::from(vec![Span::raw(String::new())]));
        info_lines.push(RLine::from(vec![Span::styled(
            "Controls: ←/→ or ↑/↓ select screenshot • Shift+↑/↓ or j/k scroll actions",
            secondary_style,
        )]));

        let max_scroll = info_lines.len().saturating_sub(info_column.height as usize);
        let max_scroll_u16 = max_scroll.min(u16::MAX as usize) as u16;
        self.browser_overlay_state
            .update_action_metrics(info_column.height, max_scroll_u16);
        let scroll = self
            .browser_overlay_state
            .action_scroll()
            .min(max_scroll_u16);

        let paragraph = Paragraph::new(info_lines)
            .style(Style::default().fg(crate::colors::text()))
            .wrap(Wrap { trim: false })
            .scroll((scroll, 0));
        Widget::render(paragraph, info_column, buf);
    }

    fn render_settings_overlay(
        &self,
        frame_area: Rect,
        history_area: Rect,
        buf: &mut Buffer,
        overlay: &SettingsOverlayView,
    ) {
        use ratatui::widgets::Clear;

        let scrim_style = Style::default()
            .bg(crate::colors::overlay_scrim())
            .fg(crate::colors::text_dim());
        fill_rect(buf, frame_area, None, scrim_style);

        let padding = 1u16;
        let overlay_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: history_area.height,
        };

        Clear.render(overlay_area, buf);

        let bg_style = Style::default().bg(crate::colors::overlay_scrim());
        fill_rect(buf, overlay_area, None, bg_style);

        overlay.render(overlay_area, buf);
    }

    fn browser_title(&self) -> &'static str {
        if self.browser_is_external {
            "Chrome"
        } else {
            "Browser"
        }
    }

    fn render_agents_terminal_overlay(
        &self,
        frame_area: Rect,
        history_area: Rect,
        bottom_pane_area: Rect,
        buf: &mut Buffer,
    ) {
        use ratatui::layout::{Constraint, Direction, Layout, Margin, Rect as RtRect};
        use ratatui::style::{Modifier, Style};
        use ratatui::text::{Line, Span};
        use ratatui::widgets::{Block, Borders, Clear, List, ListItem, ListState, Paragraph, Wrap};

        let scrim_style = Style::default()
            .bg(crate::colors::overlay_scrim())
            .fg(crate::colors::text_dim());
        fill_rect(buf, frame_area, None, scrim_style);

        let padding = 1u16;
        let footer_reserved = bottom_pane_area.height.min(1);
        let overlay_bottom = (bottom_pane_area.y + bottom_pane_area.height).saturating_sub(footer_reserved);
        let overlay_height = overlay_bottom
            .saturating_sub(history_area.y)
            .max(1)
            .min(frame_area.height);

        let window_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: overlay_height,
        };
        Clear.render(window_area, buf);

        let title_spans = vec![
            Span::styled(" Agents ", Style::default().fg(crate::colors::text())),
            Span::styled("— Ctrl+A to close", Style::default().fg(crate::colors::text_dim())),
        ];

        let block = Block::default()
            .borders(Borders::ALL)
            .title(Line::from(title_spans))
            .style(Style::default().bg(crate::colors::background()))
            .border_style(
                Style::default()
                    .fg(crate::colors::border())
                    .bg(crate::colors::background()),
            );
        let inner = block.inner(window_area);
        block.render(window_area, buf);

        let inner_bg = Style::default().bg(crate::colors::background());
        for y in inner.y..inner.y + inner.height {
            for x in inner.x..inner.x + inner.width {
                buf[(x, y)].set_style(inner_bg);
            }
        }

        let content = inner.inner(Margin::new(1, 1));
        if content.width == 0 || content.height == 0 {
            return;
        }

        let hint_height = if content.height >= 2 { 1 } else { 0 };
        let body_height = content.height.saturating_sub(hint_height);
        let body_area = RtRect {
            x: content.x,
            y: content.y,
            width: content.width,
            height: body_height,
        };
        let hint_area = RtRect {
            x: content.x,
            y: content.y.saturating_add(body_height),
            width: content.width,
            height: hint_height,
        };

        let sidebar_target = 28u16;
        let sidebar_width = if body_area.width <= sidebar_target + 12 {
            (body_area.width.saturating_mul(35) / 100).clamp(16, body_area.width)
        } else {
            sidebar_target.min(body_area.width.saturating_sub(12)).max(16)
        };

        let constraints = if body_area.width <= sidebar_width {
            [Constraint::Length(body_area.width), Constraint::Length(0)]
        } else {
            [Constraint::Length(sidebar_width), Constraint::Min(12)]
        };

        let chunks = Layout::default()
            .direction(Direction::Horizontal)
            .constraints(constraints)
            .split(body_area);

        // Sidebar list of agents grouped by batch id
        let mut items: Vec<ListItem> = Vec::new();
        let mut row_entries: Vec<Option<AgentsSidebarEntry>> = Vec::new();

        let header_style = Style::default()
            .fg(crate::colors::text())
            .add_modifier(Modifier::BOLD);
        let overview_style = Style::default().fg(crate::colors::text_dim());

        for group in self.agents_terminal.sidebar_groups() {
            items.push(ListItem::new(Line::from(vec![
                Span::styled(group.label.clone(), header_style),
            ])));
            row_entries.push(None);

            let overview_entry = AgentsSidebarEntry::Overview(group.batch_id.clone());
            items.push(ListItem::new(Line::from(vec![
                Span::styled(" ★ Overview".to_string(), overview_style),
            ])));
            row_entries.push(Some(overview_entry));

            for agent_id in group.agent_ids {
                if let Some(entry) = self.agents_terminal.entries.get(&agent_id) {
                    let model_label = entry
                        .model
                        .as_ref()
                        .and_then(|value| {
                            let trimmed = value.trim();
                            (!trimmed.is_empty()).then(|| trimmed.to_string())
                        })
                        .unwrap_or_else(|| entry.name.clone());
                    let text = format!(" • {model_label}");
                    let color = agent_status_color(entry.status.clone());
                    items.push(ListItem::new(Line::from(vec![Span::styled(
                        text,
                        Style::default().fg(color),
                    )])));
                    row_entries.push(Some(AgentsSidebarEntry::Agent(agent_id.clone())));
                }
            }
        }

        if items.is_empty() {
            items.push(ListItem::new(Line::from(vec![Span::styled(
                "No agents yet",
                Style::default().fg(crate::colors::text_dim()),
            )])));
            row_entries.push(None);
        }

        let mut list_state = ListState::default();
        if let Some(selected_entry) = self.agents_terminal.current_sidebar_entry() {
            if let Some(row_idx) = row_entries
                .iter()
                .position(|entry| entry.as_ref() == Some(&selected_entry))
            {
                list_state.select(Some(row_idx));
            }
        }

        let sidebar_has_focus = self.agents_terminal.focus() == AgentsTerminalFocus::Sidebar;
        let highlight_style = if sidebar_has_focus {
            Style::default()
                .fg(crate::colors::primary())
                .add_modifier(Modifier::BOLD)
        } else {
            Style::default()
                .fg(crate::colors::text_dim())
                .add_modifier(Modifier::BOLD)
        };
        let sidebar = List::new(items)
            .highlight_style(highlight_style)
            .highlight_symbol("›");

        fill_rect(
            buf,
            chunks[0],
            None,
            Style::default().bg(crate::colors::background()),
        );
        ratatui::widgets::StatefulWidget::render(sidebar, chunks[0], buf, &mut list_state);

        let right_area = if chunks.len() > 1 { chunks[1] } else { chunks[0] };
        let mut lines: Vec<Line> = Vec::new();

        match self.agents_terminal.current_sidebar_entry() {
            Some(AgentsSidebarEntry::Agent(agent_id)) => {
                if let Some(entry) = self.agents_terminal.entries.get(agent_id.as_str()) {
                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            entry.name.clone(),
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD),
                        ),
                        Span::raw("  "),
                        Span::styled(
                            agent_status_label(entry.status.clone()),
                            Style::default().fg(agent_status_color(entry.status.clone())),
                        ),
                        Span::raw("  "),
                        Span::styled(
                            format!("#{}", agent_id.chars().take(7).collect::<String>()),
                            Style::default().fg(crate::colors::text_dim()),
                        ),
                    ]));

                    if let Some(model) = entry.model.as_ref() {
                        lines.push(Line::from(vec![
                            Span::raw(" "),
                            Span::styled(
                                format!("Model: {model}"),
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }

                    if entry
                        .batch_label
                        .as_ref()
                        .map(|value| !value.trim().is_empty())
                        .unwrap_or(false)
                        || entry.batch_id.is_some()
                    {
                        let mut parts: Vec<String> = Vec::new();
                        if let Some(label) = entry
                            .batch_label
                            .as_ref()
                            .and_then(|value| {
                                let trimmed = value.trim();
                                (!trimmed.is_empty()).then(|| trimmed.to_string())
                            })
                        {
                            parts.push(label);
                        }
                        if let Some(batch_id) = entry.batch_id.as_ref() {
                            let short = short_batch_label(batch_id);
                            if short.is_empty() {
                                parts.push(batch_id.clone());
                            } else {
                                parts.push(short);
                            }
                        }
                        let batch_text = if parts.is_empty() {
                            "Ad-hoc".to_string()
                        } else {
                            parts.join("  ")
                        };
                        lines.push(Line::from(vec![
                            Span::raw(" "),
                            Span::styled(
                                format!("Batch: {batch_text}"),
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }

                    if let Some(context_text) = entry
                        .batch_context
                        .as_ref()
                        .filter(|value| !value.trim().is_empty())
                    {
                        self.ensure_trailing_blank_line(&mut lines);
                        self.append_agents_overlay_section(&mut lines, "Context", context_text);
                    }

                    self.ensure_trailing_blank_line(&mut lines);
                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            "Action History",
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD),
                        ),
                    ]));
                    self.ensure_trailing_blank_line(&mut lines);

                    if entry.logs.is_empty() {
                        lines.push(Line::from(vec![
                            Span::raw(" "),
                            Span::styled(
                                "No updates yet",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    } else {
                        for (idx, log) in entry.logs.iter().enumerate() {
                            self.append_agent_log_lines(
                                &mut lines,
                                log.timestamp,
                                log.kind,
                                log.message.as_str(),
                                None,
                            );
                            if idx + 1 < entry.logs.len() {
                                lines.push(Line::from(""));
                            }
                        }
                    }
                } else {
                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            "No data for selected agent",
                            Style::default().fg(crate::colors::text_dim()),
                        ),
                    ]));
                }
            }
            Some(AgentsSidebarEntry::Overview(batch_id)) => {
                let mut batch_entries: Vec<&AgentTerminalEntry> = Vec::new();
                for id in &self.agents_terminal.order {
                    if let Some(entry) = self.agents_terminal.entries.get(id) {
                        if entry.batch_id == batch_id {
                            batch_entries.push(entry);
                        }
                    }
                }

                if batch_entries.is_empty() {
                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            "No data for this batch",
                            Style::default().fg(crate::colors::text_dim()),
                        ),
                    ]));
                } else {
                    let count = batch_entries.len();
                    let title = batch_entries
                        .iter()
                        .find_map(|entry| {
                            entry.batch_label.as_ref().and_then(|value| {
                                let trimmed = value.trim();
                                (!trimmed.is_empty()).then(|| trimmed.to_string())
                            })
                        })
                        .or_else(|| {
                            batch_id
                                .as_ref()
                                .map(|id| short_batch_label(id))
                        })
                        .unwrap_or_else(|| "Ad-hoc Agents".to_string());
                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            title,
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD),
                        ),
                        Span::raw("  "),
                        Span::styled(
                            if count == 1 {
                                "1 agent".to_string()
                            } else {
                                format!("{count} agents")
                            },
                            Style::default().fg(crate::colors::text_dim()),
                        ),
                    ]));

                    let mut model_labels: Vec<String> = batch_entries
                        .iter()
                        .map(|entry| {
                            entry
                                .model
                                .as_ref()
                                .and_then(|value| {
                                    let trimmed = value.trim();
                                    (!trimmed.is_empty()).then(|| trimmed.to_string())
                                })
                                .unwrap_or_else(|| entry.name.clone())
                        })
                        .collect();
                    model_labels.sort();
                    model_labels.dedup();
                    if !model_labels.is_empty() {
                        lines.push(Line::from(vec![
                            Span::raw(" "),
                            Span::styled(
                                format!("Models: {}", model_labels.join(", ")),
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }

                    if let Some(context_text) = batch_entries
                        .iter()
                        .find_map(|entry| entry.batch_context.as_ref())
                        .and_then(|value| {
                            let trimmed = value.trim();
                            (!trimmed.is_empty()).then(|| value.as_str())
                        })
                    {
                        self.ensure_trailing_blank_line(&mut lines);
                        self.append_agents_overlay_section(&mut lines, "Context", context_text);
                    }

                    self.ensure_trailing_blank_line(&mut lines);
                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            "Action History",
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD),
                        ),
                    ]));
                    self.ensure_trailing_blank_line(&mut lines);

                    let mut aggregated: Vec<(DateTime<Local>, AgentLogKind, String, String)> = Vec::new();
                    for entry in &batch_entries {
                        let entry = *entry;
                        let agent_label = entry
                            .model
                            .as_ref()
                            .and_then(|value| {
                                let trimmed = value.trim();
                                (!trimmed.is_empty()).then(|| trimmed.to_string())
                            })
                            .unwrap_or_else(|| entry.name.clone());
                        for log in &entry.logs {
                            aggregated.push((
                                log.timestamp,
                                log.kind,
                                log.message.clone(),
                                agent_label.clone(),
                            ));
                        }
                    }
                    aggregated.sort_by(|a, b| {
                        a.0
                            .cmp(&b.0)
                            .then_with(|| a.3.cmp(&b.3))
                            .then_with(|| a.2.cmp(&b.2))
                    });

                    if aggregated.is_empty() {
                        lines.push(Line::from(vec![
                            Span::raw(" "),
                            Span::styled(
                                "No updates yet",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    } else {
                        for (idx, (timestamp, kind, message, agent_label_text)) in
                            aggregated.iter().enumerate()
                        {
                            self.append_agent_log_lines(
                                &mut lines,
                                *timestamp,
                                *kind,
                                message.as_str(),
                                Some(agent_label_text.as_str()),
                            );
                            if idx + 1 < aggregated.len() {
                                lines.push(Line::from(""));
                            }
                        }
                    }
                }
            }
            None => {
                lines.push(Line::from(vec![
                    Span::raw(" "),
                    Span::styled(
                        "No agents available",
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                ]));
            }
        }

        let viewport_height = right_area.height.max(1);
        let total_lines = lines.len() as u16;
        let max_scroll = total_lines.saturating_sub(viewport_height);
        self.layout.last_history_viewport_height.set(viewport_height);
        self.layout.last_max_scroll.set(max_scroll);

        let detail_has_focus = self.agents_terminal.focus() == AgentsTerminalFocus::Detail;
        let detail_border_color = if detail_has_focus {
            crate::colors::border_focused()
        } else {
            crate::colors::border()
        };
        let history_block = Block::default()
            .borders(Borders::ALL)
            .title(" Agent History ")
            .border_style(Style::default().fg(detail_border_color));

        Paragraph::new(lines)
            .block(history_block)
            .wrap(Wrap { trim: false })
            .scroll((self.layout.scroll_offset.min(max_scroll), 0))
            .render(right_area, buf);

        if hint_height == 1 {
            let hint_line = Line::from(vec![
                Span::styled("↑/↓", Style::default().fg(crate::colors::function())),
                Span::styled(" Navigate/Scroll  ", Style::default().fg(crate::colors::text_dim())),
                Span::styled("→/Enter", Style::default().fg(crate::colors::function())),
                Span::styled(" Focus output  ", Style::default().fg(crate::colors::text_dim())),
                Span::styled("←", Style::default().fg(crate::colors::function())),
                Span::styled(" Back to list  ", Style::default().fg(crate::colors::text_dim())),
                Span::styled("Tab", Style::default().fg(crate::colors::function())),
                Span::styled(" Next agent  ", Style::default().fg(crate::colors::text_dim())),
                Span::styled("PgUp/PgDn", Style::default().fg(crate::colors::function())),
                Span::styled(" Page scroll  ", Style::default().fg(crate::colors::text_dim())),
                Span::styled("Esc", Style::default().fg(crate::colors::error())),
                Span::styled(" Exit", Style::default().fg(crate::colors::text_dim())),
            ]);
            Paragraph::new(hint_line)
                .style(Style::default().bg(crate::colors::background()))
                .alignment(ratatui::layout::Alignment::Center)
                .render(hint_area, buf);
        }
    }

    #[allow(dead_code)]
    /// Render the agent status panel in the HUD
    fn render_agent_panel(&self, area: Rect, buf: &mut Buffer) {
        use ratatui::text::Line as RLine;
        use ratatui::text::Span;
        use ratatui::text::Text;
        use ratatui::widgets::Block;
        use ratatui::widgets::Borders;
        use ratatui::widgets::Paragraph;
        use ratatui::widgets::Sparkline;
        use ratatui::widgets::SparklineBar;
        use ratatui::widgets::Widget;
        use ratatui::widgets::Wrap;

        // Update sparkline data for animation
        if !self.active_agents.is_empty() || self.agents_ready_to_start {
            self.update_sparkline_data();
        }

        let short_id = |id: &str| -> String { id.chars().take(8).collect() };
        let mut rendered_batches = std::collections::HashSet::new();

        // Agent status block
        let agent_block = Block::default()
            .borders(Borders::ALL)
            .title(" Agents ")
            .border_style(Style::default().fg(crate::colors::border()));

        let inner_agent = agent_block.inner(area);
        agent_block.render(area, buf);
        // Render a one-line collapsed header inside expanded panel
        use ratatui::layout::Margin;
        let header_pad = inner_agent.inner(Margin::new(1, 0));
        let header_line = Rect {
            x: header_pad.x,
            y: header_pad.y,
            width: header_pad.width,
            height: 1,
        };
        let key_hint_style = Style::default().fg(crate::colors::function());
        let label_style = Style::default().dim();
        let is_active = !self.active_agents.is_empty() || self.agents_ready_to_start;
        let dot_style = if is_active {
            Style::default().fg(crate::colors::success_green())
        } else {
            Style::default().fg(crate::colors::text_dim())
        };
        // Build summary like collapsed header
        let count = self.active_agents.len();
        let summary = if count == 0 && self.agents_ready_to_start {
            "Starting...".to_string()
        } else if count == 0 {
            "no active agents".to_string()
        } else {
            let mut parts: Vec<String> = Vec::new();
            for a in self.active_agents.iter().take(3) {
                let s = match a.status {
                    AgentStatus::Pending => "pending",
                    AgentStatus::Running => "running",
                    AgentStatus::Completed => "done",
                    AgentStatus::Failed => "failed",
                    AgentStatus::Cancelled => "cancelled",
                };
                parts.push(format!("{} ({})", a.name, s));
            }
            let extra = if count > 3 {
                format!(" +{}", count - 3)
            } else {
                String::new()
            };
            format!("{}{}", parts.join(", "), extra)
        };
        let mut left_spans: Vec<Span> = Vec::new();
        left_spans.push(Span::styled("•", dot_style));
        // no status text; dot conveys status
        // single space between dot and summary; no label/separator
        left_spans.push(Span::raw(" "));
        left_spans.push(Span::raw(summary));
        let right_spans: Vec<Span> = vec![
            Span::from("Ctrl+A").style(key_hint_style),
            Span::styled(" open terminal", label_style),
        ];
        let measure =
            |spans: &Vec<Span>| -> usize { spans.iter().map(|s| s.content.chars().count()).sum() };
        let left_len = measure(&left_spans);
        let right_len = measure(&right_spans);
        let total_width = header_line.width as usize;
        if total_width > left_len + right_len {
            left_spans.push(Span::from(" ".repeat(total_width - left_len - right_len)));
        }
        let mut spans = left_spans;
        spans.extend(right_spans);
        Paragraph::new(RLine::from(spans)).render(header_line, buf);

        // Body area excludes the header line and a spacer line
        let inner_agent = Rect {
            x: inner_agent.x,
            y: inner_agent.y + 2,
            width: inner_agent.width,
            height: inner_agent.height.saturating_sub(2),
        };

        // Dynamically calculate sparkline height based on agent activity
        // More agents = taller sparkline area
        let agent_count = self.active_agents.len();
        let sparkline_height = if agent_count == 0 && self.agents_ready_to_start {
            1u16 // Minimal height when preparing
        } else if agent_count == 0 {
            0u16 // No sparkline when no agents
        } else {
            (agent_count as u16 + 1).min(4) // 2-4 lines based on agent count
        };

        // Ensure we have enough space for both content and sparkline
        // Reserve at least 3 lines for content (status + blank + message)
        let min_content_height = 3u16;
        let available_height = inner_agent.height;

        let (actual_content_height, actual_sparkline_height) = if sparkline_height > 0 {
            if available_height > min_content_height + sparkline_height {
                // Enough space for both
                (
                    available_height.saturating_sub(sparkline_height),
                    sparkline_height,
                )
            } else if available_height > min_content_height {
                // Limited space - give minimum to content, rest to sparkline
                (
                    min_content_height,
                    available_height
                        .saturating_sub(min_content_height)
                        .min(sparkline_height),
                )
            } else {
                // Very limited space - content only
                (available_height, 0)
            }
        } else {
            // No sparkline needed
            (available_height, 0)
        };

        let content_area = Rect {
            x: inner_agent.x,
            y: inner_agent.y,
            width: inner_agent.width,
            height: actual_content_height,
        };
        let sparkline_area = Rect {
            x: inner_agent.x,
            y: inner_agent.y + actual_content_height,
            width: inner_agent.width,
            height: actual_sparkline_height,
        };

        // Build all content into a single Text structure for proper wrapping
        let mut text_content = vec![];

        // Add blank line at the top
        text_content.push(RLine::from(" "));

        // Add overall task status at the top
        let status_color = match self.overall_task_status.as_str() {
            "planning" => crate::colors::warning(),
            "running" => crate::colors::info(),
            "consolidating" => crate::colors::warning(),
            "complete" => crate::colors::success(),
            "failed" => crate::colors::error(),
            "cancelled" => crate::colors::warning(),
            _ => crate::colors::text_dim(),
        };

        text_content.push(RLine::from(vec![
            Span::from(" "),
            Span::styled(
                "Status: ",
                Style::default()
                    .fg(crate::colors::text())
                    .add_modifier(Modifier::BOLD),
            ),
            Span::styled(&self.overall_task_status, Style::default().fg(status_color)),
        ]));

        // Add blank line
        text_content.push(RLine::from(" "));

        // Display agent statuses
        if self.agents_ready_to_start && self.active_agents.is_empty() {
            // Show "Building context..." message when agents are expected
            text_content.push(RLine::from(vec![
                Span::from(" "),
                Span::styled(
                    "Building context...",
                    Style::default()
                        .fg(crate::colors::text_dim())
                        .add_modifier(Modifier::ITALIC),
                ),
            ]));
        } else if self.active_agents.is_empty() {
            text_content.push(RLine::from(vec![
                Span::from(" "),
                Span::styled(
                    "No active agents",
                    Style::default().fg(crate::colors::text_dim()),
                ),
            ]));
        } else {
            // Show agent names/models and final messages
            for agent in &self.active_agents {
                let status_color = match agent.status {
                    AgentStatus::Pending => crate::colors::warning(),
                    AgentStatus::Running => crate::colors::info(),
                    AgentStatus::Completed => crate::colors::success(),
                    AgentStatus::Failed => crate::colors::error(),
                    AgentStatus::Cancelled => crate::colors::warning(),
                };

                // Build status + timing suffix where available
                let status_text = match agent.status {
                    AgentStatus::Pending => "pending".to_string(),
                    AgentStatus::Running => {
                        if let Some(rt) = self.agent_runtime.get(&agent.id) {
                            if let Some(start) = rt.started_at {
                                let now = Instant::now();
                                let elapsed = now.saturating_duration_since(start);
                                format!("running {}", self.fmt_short_duration(elapsed))
                            } else {
                                "running".to_string()
                            }
                        } else {
                            "running".to_string()
                        }
                    }
                    AgentStatus::Completed | AgentStatus::Failed | AgentStatus::Cancelled => {
                        if let Some(rt) = self.agent_runtime.get(&agent.id) {
                            if let (Some(start), Some(done)) = (rt.started_at, rt.completed_at) {
                                let dur = done.saturating_duration_since(start);
                                let base = match agent.status {
                                    AgentStatus::Completed => "completed",
                                    AgentStatus::Failed => "failed",
                                    AgentStatus::Cancelled => "cancelled",
                                    _ => unreachable!(),
                                };
                                format!("{} {}", base, self.fmt_short_duration(dur))
                            } else {
                                match agent.status {
                                    AgentStatus::Completed => "completed".to_string(),
                                    AgentStatus::Failed => "failed".to_string(),
                                    AgentStatus::Cancelled => "cancelled".to_string(),
                                    _ => unreachable!(),
                                }
                            }
                        } else {
                            match agent.status {
                                AgentStatus::Completed => "completed".to_string(),
                                AgentStatus::Failed => "failed".to_string(),
                                AgentStatus::Cancelled => "cancelled".to_string(),
                                _ => unreachable!(),
                            }
                        }
                    }
                };

                let mut line_spans: Vec<Span> = Vec::new();
                line_spans.push(Span::from(" "));
                line_spans.push(
                    Span::styled(
                        format!("{}", agent.name),
                        Style::default()
                            .fg(crate::colors::text())
                            .add_modifier(Modifier::BOLD),
                    ),
                );
                line_spans.push(Span::styled(
                    format!(" [{}]", short_id(&agent.id)),
                    Style::default().fg(crate::colors::text_dim()),
                ));
                if let Some(ref model) = agent.model {
                    if !model.is_empty() {
                        line_spans.push(Span::styled(
                            format!(" ({})", model),
                            Style::default().fg(crate::colors::text_dim()),
                        ));
                    }
                }
                line_spans.push(Span::from(": "));
                line_spans.push(Span::styled(status_text, Style::default().fg(status_color)));
                text_content.push(RLine::from(line_spans));

                // For running agents, show latest progress hint if available
                if matches!(agent.status, AgentStatus::Running) {
                    if let Some(ref lp) = agent.last_progress {
                        let mut lp_trim = lp.trim().to_string();
                        if lp_trim.len() > 120 {
                            lp_trim.truncate(120);
                            lp_trim.push('…');
                        }
                        text_content.push(RLine::from(vec![
                            Span::from("   "),
                            Span::styled(
                                lp_trim,
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }
                }

                // For completed/failed agents, show their final message or error
                match agent.status {
                    AgentStatus::Completed => {
                        if let Some(ref msg) = agent.result {
                            text_content.push(RLine::from(vec![
                                Span::from("   "),
                                Span::styled(msg, Style::default().fg(crate::colors::text_dim())),
                            ]));
                        }
                    }
                    AgentStatus::Failed => {
                        if let Some(ref err) = agent.error {
                            text_content.push(RLine::from(vec![
                                Span::from("   "),
                                Span::styled(
                                    err,
                                    Style::default()
                                        .fg(crate::colors::error())
                                        .add_modifier(Modifier::ITALIC),
                                ),
                            ]));
                        }
                    }
                    AgentStatus::Cancelled => {
                        if let Some(ref err) = agent.error {
                            text_content.push(RLine::from(vec![
                                Span::from("   "),
                                Span::styled(
                                    err,
                                    Style::default()
                                        .fg(crate::colors::warning())
                                        .add_modifier(Modifier::ITALIC),
                                ),
                            ]));
                        }
                    }
                    _ => {}
                }

                if let Some(ref batch) = agent.batch_id {
                    if rendered_batches.insert(batch.clone()) {
                        let batch_line = format!(
                            "Batch {} — use agent {{\"action\":\"wait\",\"wait\":{{\"batch_id\":\"{}\"}}}}",
                            short_id(batch),
                            batch
                        );
                        text_content.push(RLine::from(vec![
                            Span::from("   "),
                            Span::styled(
                                batch_line,
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }
                }
            }
        }

        // Calculate how much vertical space the fixed content takes
        let fixed_content_height = text_content.len() as u16;

        // Create the first paragraph for the fixed content (status and agents) without wrapping
        let fixed_paragraph = Paragraph::new(Text::from(text_content));

        // Render the fixed content first
        let fixed_area = Rect {
            x: content_area.x,
            y: content_area.y,
            width: content_area.width,
            height: fixed_content_height.min(content_area.height),
        };
        fixed_paragraph.render(fixed_area, buf);

        // Calculate remaining area for wrapped content
        let remaining_height = content_area.height.saturating_sub(fixed_content_height);
        if remaining_height > 0 {
            let wrapped_area = Rect {
                x: content_area.x,
                y: content_area.y + fixed_content_height,
                width: content_area.width,
                height: remaining_height,
            };

            // Add context and task sections with proper wrapping in the remaining area
            let mut wrapped_content = vec![];

            if let Some(ref task) = self.agent_task {
                wrapped_content.push(RLine::from(" ")); // Empty line separator
                wrapped_content.push(RLine::from(vec![
                    Span::from(" "),
                    Span::styled(
                        "Task:",
                        Style::default()
                            .fg(crate::colors::text())
                            .add_modifier(Modifier::BOLD),
                    ),
                    Span::from(" "),
                    Span::styled(task, Style::default().fg(crate::colors::text_dim())),
                ]));
            }

            if let Some(ref hint) = self.recent_agent_hint {
                wrapped_content.push(RLine::from(" "));
                wrapped_content.push(RLine::from(vec![
                    Span::from(" "),
                    Span::styled(
                        "Next steps:",
                        Style::default()
                            .fg(crate::colors::text())
                            .add_modifier(Modifier::BOLD),
                    ),
                ]));
                for line in hint.lines() {
                    wrapped_content.push(RLine::from(vec![
                        Span::from("   "),
                        Span::styled(
                            line.trim_end(),
                            Style::default().fg(crate::colors::text_dim()),
                        ),
                    ]));
                }
            }

            if !wrapped_content.is_empty() {
                // Create paragraph with wrapping enabled for the long text content
                let wrapped_paragraph =
                    Paragraph::new(Text::from(wrapped_content)).wrap(Wrap { trim: false });
                wrapped_paragraph.render(wrapped_area, buf);
            }
        }

        // Render sparkline at the bottom if we have data and agents are active
        let sparkline_data = self.sparkline_data.borrow();

        // Debug logging
        tracing::debug!(
            "Sparkline render check: data_len={}, agents={}, ready={}, height={}, actual_height={}, area={:?}",
            sparkline_data.len(),
            self.active_agents.len(),
            self.agents_ready_to_start,
            sparkline_height,
            actual_sparkline_height,
            sparkline_area
        );

        if !sparkline_data.is_empty()
            && (!self.active_agents.is_empty() || self.agents_ready_to_start)
            && actual_sparkline_height > 0
        {
            // Convert data to SparklineBar with colors based on completion status
            let bars: Vec<SparklineBar> = sparkline_data
                .iter()
                .map(|(value, is_completed)| {
                    let color = if *is_completed {
                        crate::colors::success() // Green for completed
                    } else {
                        crate::colors::border() // Border color for normal activity
                    };
                    SparklineBar::from(*value).style(Style::default().fg(color))
                })
                .collect();

            // Use dynamic max based on the actual data for better visibility
            // During preparing/planning, values are small (2-3), during running they're larger (5-15)
            // For planning phase with single line, use smaller max for better visibility
            let max_value = if self.agents_ready_to_start && self.active_agents.is_empty() {
                // Planning phase - use smaller max for better visibility of 1-3 range
                sparkline_data
                    .iter()
                    .map(|(v, _)| *v)
                    .max()
                    .unwrap_or(4)
                    .max(4)
            } else {
                // Running phase - use larger max
                sparkline_data
                    .iter()
                    .map(|(v, _)| *v)
                    .max()
                    .unwrap_or(10)
                    .max(10)
            };

            let sparkline = Sparkline::default().data(bars).max(max_value); // Dynamic max for better visibility
            sparkline.render(sparkline_area, buf);
        }
    }
}

impl WidgetRef for &ChatWidget<'_> {
    fn render_ref(&self, area: Rect, buf: &mut Buffer) {
        // Top-level widget render timing
        let _perf_widget_start = if self.perf_state.enabled {
            Some(std::time::Instant::now())
        } else {
            None
        };

        // Ensure a consistent background even when individual widgets skip
        // painting unchanged regions. Without this, gutters and inter‑cell
        // spacing can show through after we reduced full clears.
        // Cost: one Block render across the frame (O(area)); acceptable and
        // fixes visual artifacts reported after redraw reductions.
        if !self.standard_terminal_mode {
            use ratatui::style::Style;
            use ratatui::widgets::Block;
            let bg = Block::default().style(Style::default().bg(crate::colors::background()));
            bg.render(area, buf);
        }

        // Remember full frame height for HUD sizing logic
        self.layout.last_frame_height.set(area.height);
        self.layout.last_frame_width.set(area.width);

        let layout_areas = self.layout_areas(area);
        let status_bar_area = layout_areas.get(0).copied().unwrap_or(area);
        let history_area = layout_areas.get(1).copied().unwrap_or(area);
        let bottom_pane_area = layout_areas.get(2).copied().unwrap_or(area);

        // Record the effective bottom pane height for buffer-mode scrollback inserts.
        self.layout
            .last_bottom_reserved_rows
            .set(bottom_pane_area.height);

        // Render status bar and HUD only in full TUI mode
        if !self.standard_terminal_mode {
            self.render_status_bar(status_bar_area, buf);
        }

        // In standard-terminal mode, do not paint the history region: committed
        // content is appended to the terminal's own scrollback via
        // insert_history_lines and repainting here would overwrite it.
        if self.standard_terminal_mode {
            // Render only the bottom pane (composer or its active view) without painting
            // backgrounds to preserve the terminal's native theme.
            ratatui::widgets::WidgetRef::render_ref(&(&self.bottom_pane), bottom_pane_area, buf);
            // Scrub backgrounds in the bottom pane region so any widget-set bg becomes transparent.
            self.clear_backgrounds_in(buf, bottom_pane_area);
            return;
        }

        // Create a unified scrollable container for all chat content
        // Use consistent padding throughout
        let padding = 1u16;
        let content_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: history_area.height,
        };

        // Reset the full history region to the baseline theme background once per frame.
        // Individual cells only repaint when their visuals differ (e.g., assistant tint),
        // which keeps overdraw minimal while ensuring stale characters disappear.
        let base_style = Style::default()
            .bg(crate::colors::background())
            .fg(crate::colors::text());
        fill_rect(buf, history_area, Some(' '), base_style);

        // Collect all content items into a single list.
        // The shared renderer cache (documented in docs/history_render_cache_bridge.md)
        // consumes this list via `RenderRequest` so we can reuse per-cell caches
        // while progressively moving the draw loop toward pure HistoryRecord state.
        let mut all_content: Vec<&dyn HistoryCell> = Vec::new();
        for cell in self.history_cells.iter() {
            all_content.push(cell);
        }

        // Add active/streaming cell if present
        if let Some(ref cell) = self.active_exec_cell {
            all_content.push(cell as &dyn HistoryCell);
        }

        // Add live streaming content if present
        let streaming_lines = self
            .live_builder
            .display_rows()
            .into_iter()
            .map(|r| ratatui::text::Line::from(r.text))
            .collect::<Vec<_>>();

        let streaming_cell = if !streaming_lines.is_empty() {
            let state =
                self.synthesize_stream_state_from_lines(None, &streaming_lines, true);
            Some(history_cell::new_streaming_content(state, &self.config))
        } else {
            None
        };

        if let Some(ref cell) = streaming_cell {
            all_content.push(cell);
        }

        // Append any queued user messages as sticky preview cells at the very
        // end so they always render at the bottom until they are dispatched.
        let mut queued_preview_cells: Vec<crate::history_cell::PlainHistoryCell> = Vec::new();
        if !self.queued_user_messages.is_empty() {
            for qm in &self.queued_user_messages {
                let state = history_cell::new_queued_user_prompt(qm.display_text.clone());
                queued_preview_cells.push(crate::history_cell::PlainHistoryCell::from_state(state));
            }
            for c in &queued_preview_cells {
                all_content.push(c as &dyn HistoryCell);
            }
        }

        let mut render_requests: Vec<RenderRequest> = Vec::with_capacity(all_content.len());
        for (idx, cell) in all_content.iter().enumerate() {
            let (history_id, has_record) = if idx < self.history_cell_ids.len() {
                if let Some(id) = self.history_cell_ids[idx] {
                    let exists = self.history_state.index_of(id).is_some();
                    (id, exists)
                } else {
                    (HistoryId::ZERO, false)
                }
            } else {
                (HistoryId::ZERO, false)
            };

            let cell_has_custom_render = cell.has_custom_render();
            let is_streaming = cell
                .as_any()
                .downcast_ref::<crate::history_cell::StreamingContentCell>()
                .is_some();

            let mut cacheable = history_id != HistoryId::ZERO
                && has_record
                && !cell_has_custom_render
                && !cell.is_animating()
                && !is_streaming;

            let assistant = cell
                .as_any()
                .downcast_ref::<crate::history_cell::AssistantMarkdownCell>();

            let mut fallback_lines = None;
            let mut kind = RenderRequestKind::Legacy;
            if history_id != HistoryId::ZERO {
                if let Some(record) = self.history_state.record(history_id) {
                    match record {
                        HistoryRecord::Exec(_) => {
                            kind = RenderRequestKind::Exec { id: history_id };
                        }
                        HistoryRecord::MergedExec(_) => {
                            kind = RenderRequestKind::MergedExec { id: history_id };
                        }
                        HistoryRecord::Explore(_) => {
                            let hold_header = if idx < self.history_cells.len() {
                                self.rendered_explore_should_hold(idx)
                            } else {
                                true
                            };
                            let full_detail = self.is_reasoning_shown();
                            kind = RenderRequestKind::Explore {
                                id: history_id,
                                hold_header,
                                full_detail,
                            };
                        }
                        HistoryRecord::Diff(_) => {
                            kind = RenderRequestKind::Diff { id: history_id };
                        }
                        HistoryRecord::AssistantStream(stream_state) => {
                            kind = RenderRequestKind::Streaming { id: history_id };
                            if stream_state.in_progress {
                                cacheable = false;
                            }
                        }
                        HistoryRecord::AssistantMessage(_) => {
                            kind = RenderRequestKind::Assistant { id: history_id };
                        }
                        other => {
                            fallback_lines =
                                self.fallback_lines_for_record(*cell, other);
                        }
                    }
                }
            }

            if fallback_lines.is_none() && !cell_has_custom_render && history_id == HistoryId::ZERO {
                let lines = cell.display_lines_trimmed();
                if !lines.is_empty() {
                    fallback_lines = Some(lines);
                }
            }

            render_requests.push(RenderRequest {
                history_id,
                cell: Some(*cell),
                assistant,
                use_cache: cacheable,
                fallback_lines,
                kind,
                config: &self.config,
            });

        }

        // Calculate total content height using prefix sums; build if needed
        let spacing = 1u16; // Standard spacing between cells
        const GUTTER_WIDTH: u16 = 2; // Same as in render loop
        let reasoning_visible = self.is_reasoning_shown();
        let cache_width = content_area.width.saturating_sub(GUTTER_WIDTH);

        // Opportunistically clear height cache if width changed
        self.history_render.handle_width_change(cache_width);

        // Perf: count a frame
        if self.perf_state.enabled {
            let mut p = self.perf_state.stats.borrow_mut();
            p.frames = p.frames.saturating_add(1);
        }

        let render_settings = RenderSettings::new(cache_width, self.render_theme_epoch, reasoning_visible);
        let request_count = render_requests.len();
        let needs_prefix_rebuild =
            self.history_render
                .should_rebuild_prefix(content_area.width, request_count);

        let perf_enabled = self.perf_state.enabled;
        let mut rendered_cells_full: Option<Vec<VisibleCell>> = None;
        if needs_prefix_rebuild {
            if perf_enabled {
                let mut p = self.perf_state.stats.borrow_mut();
                p.prefix_rebuilds = p.prefix_rebuilds.saturating_add(1);
            }

            let prefix_start = perf_enabled.then(std::time::Instant::now);
            let cells = self.history_render.visible_cells(
                &self.history_state,
                &render_requests,
                render_settings,
            );

            let mut prefix: Vec<u16> = Vec::with_capacity(cells.len().saturating_add(1));
            prefix.push(0);
            let mut acc = 0u16;
            let content_width = content_area.width.saturating_sub(GUTTER_WIDTH);
            let mut spacing_ranges: Vec<(u16, u16)> = Vec::new();

            for (idx, vis) in cells.iter().enumerate() {
                let cell = vis.cell.expect("rendered cell missing source");
                let line_count = vis.height;
                if self.perf_state.enabled
                    && matches!(vis.height_source, history_render::HeightSource::DesiredHeight)
                {
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.height_misses_render = p.height_misses_render.saturating_add(1);
                    if let Some(ns) = vis.height_measure_ns {
                        let label = self.perf_label_for_item(cell);
                        p.record_render((idx, content_width), label.as_str(), ns);
                    }
                }
                acc = acc.saturating_add(line_count);

                let mut should_add_spacing = idx < cells.len().saturating_sub(1) && line_count > 0;
                if should_add_spacing {
                    let prev_visible_idx = (0..idx).rev().find(|j| cells[*j].height > 0);
                    let next_visible_idx = ((idx + 1)..cells.len()).find(|j| cells[*j].height > 0);

                    if next_visible_idx.is_none() {
                        should_add_spacing = false;
                    } else {
                        let this_collapsed = cell
                            .as_any()
                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                            .map(|rc| rc.is_collapsed())
                            .unwrap_or(false);
                        if this_collapsed {
                            let prev_collapsed = prev_visible_idx
                                .and_then(|j| cells[j]
                                    .cell
                                    .and_then(|c| {
                                        c.as_any()
                                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                                            .map(|rc| rc.is_collapsed())
                                    }))
                                .unwrap_or(false);
                            let next_collapsed = next_visible_idx
                                .and_then(|j| cells[j]
                                    .cell
                                    .and_then(|c| {
                                        c.as_any()
                                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                                            .map(|rc| rc.is_collapsed())
                                    }))
                                .unwrap_or(false);
                            if prev_collapsed && next_collapsed {
                                should_add_spacing = false;
                            }
                        }
                    }
                }
                if should_add_spacing {
                    let spacing_start = acc;
                    acc = acc.saturating_add(spacing);
                    // Track the spacer interval so scroll adjustments can skip over it later.
                    spacing_ranges.push((spacing_start, acc));
                }
                prefix.push(acc);
            }

            let total_height = *prefix.last().unwrap_or(&0);
            if let (true, Some(t0)) = (perf_enabled, prefix_start) {
                let elapsed = t0.elapsed().as_nanos();
                let mut p = self.perf_state.stats.borrow_mut();
                p.ns_total_height = p.ns_total_height.saturating_add(elapsed);
            }
            self.history_render
                .update_prefix_cache(content_area.width, prefix, total_height, cells.len());
            self.history_render.update_spacing_ranges(spacing_ranges);
            rendered_cells_full = Some(cells);
        }

        let mut total_height = self.history_render.last_total_height();
        let base_total_height = total_height;
        if total_height > 0 && content_area.height > 0 && request_count > 0 {
            let viewport_rows = content_area.height;
            if base_total_height > viewport_rows {
                let remainder = base_total_height % viewport_rows;
                let mut spacer_lines = 0u16;
                if remainder == 0 {
                    spacer_lines = if base_total_height == viewport_rows { 1 } else { 2 };
                } else if viewport_rows >= 4
                    && (remainder <= 2 || remainder >= viewport_rows.saturating_sub(2))
                {
                    spacer_lines = 1;
                }
                if spacer_lines > 0 {
                    total_height = total_height.saturating_add(spacer_lines);
                    tracing::debug!(
                        target: "code_tui::history_render",
                        lines = spacer_lines,
                        base_height = base_total_height,
                        padded_height = total_height,
                        viewport = viewport_rows,
                        remainder = remainder,
                        "history overscan: adding bottom spacer",
                    );
                }
            }
        }
        let overscan_extra = total_height.saturating_sub(base_total_height);
        // Calculate scroll position and vertical alignment
        // Stabilize viewport when input area height changes while scrolled up.
        let prev_viewport_h = self.layout.last_history_viewport_height.get();
        if prev_viewport_h == 0 {
            // Initialize on first render
            self.layout
                .last_history_viewport_height
                .set(content_area.height);
        }

        let (start_y, scroll_pos) = if total_height <= content_area.height {
            // Content fits - always align to bottom so "Popular commands" stays at the bottom
            let start_y = content_area.y + content_area.height.saturating_sub(total_height);
            // Update last_max_scroll cache
            self.layout.last_max_scroll.set(0);
            (start_y, 0u16) // No scrolling needed
        } else {
            // Content overflows - calculate scroll position
            // scroll_offset is measured from the bottom (0 = bottom/newest)
            // Convert to distance from the top for rendering math.
            let max_scroll = total_height.saturating_sub(content_area.height);
            // Update cache and clamp for display only
            self.layout.last_max_scroll.set(max_scroll);
            let clamped_scroll_offset = self.layout.scroll_offset.min(max_scroll);
            let mut scroll_from_top = max_scroll.saturating_sub(clamped_scroll_offset);

            if overscan_extra > 0 && clamped_scroll_offset == 0 {
                scroll_from_top = scroll_from_top.saturating_sub(overscan_extra);
            }

            // Viewport stabilization: when user is scrolled up (offset > 0) and the
            // history viewport height changes due to the input area growing/shrinking,
            // adjust the scroll_from_top to keep the top line steady on screen.
            if clamped_scroll_offset > 0 {
                let prev_h = prev_viewport_h as i32;
                let curr_h = content_area.height as i32;
                let delta_h = prev_h - curr_h; // positive if viewport shrank
                if delta_h != 0 {
                    // Adjust in the opposite direction to keep the same top anchor
                    let sft = scroll_from_top as i32 - delta_h;
                    let sft = sft.clamp(0, max_scroll as i32) as u16;
                    scroll_from_top = sft;
                }
            }

            // If our scroll origin landed on a spacer row between cells, nudge it up so
            // the viewport starts with real content instead of an empty separator.
            let adjusted_scroll_from_top = self
                .history_render
                .adjust_scroll_to_content(scroll_from_top);

            (content_area.y, adjusted_scroll_from_top)
        };

        // Record current viewport height for the next frame
        self.layout
            .last_history_viewport_height
            .set(content_area.height);

        let _perf_hist_clear_start = if self.perf_state.enabled {
            Some(std::time::Instant::now())
        } else {
            None
        };

        // Render the scrollable content with spacing using prefix sums
        let mut screen_y = start_y; // Position on screen
        let spacing = 1u16; // Spacing between cells
        let viewport_bottom = scroll_pos.saturating_add(content_area.height);
        let ps_ref = self.history_render.prefix_sums.borrow();
        let ps: &Vec<u16> = &ps_ref;
        let mut start_idx = match ps.binary_search(&scroll_pos) {
            Ok(i) => i,
            Err(i) => i.saturating_sub(1),
        };
        start_idx = start_idx.min(request_count);
        let mut end_idx = match ps.binary_search(&viewport_bottom) {
            Ok(i) => i,
            Err(i) => i,
        };
        end_idx = end_idx.saturating_add(1).min(request_count);

        let mut _subset_rendered: Option<Vec<VisibleCell>> = None;
        let visible_slice: &[VisibleCell] = if let Some(ref full) = rendered_cells_full {
            &full[start_idx..end_idx]
        } else {
            _subset_rendered = Some(self.history_render.visible_cells(
                &self.history_state,
                &render_requests[start_idx..end_idx],
                render_settings,
            ));
            _subset_rendered.as_ref().map(|v| v.as_slice()).unwrap_or(&[])
        };

        // Only schedule animation frames if an animating cell is actually visible.
        let has_visible_animation = visible_slice.iter().any(|visible| {
            visible
                .cell
                .map(|cell| cell.is_animating())
                .unwrap_or(false)
        });
        if has_visible_animation {
            tracing::debug!("Visible animation detected, scheduling next frame");
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(std::time::Duration::from_millis(
                    50,
                )));
        }

        let render_loop_start = if self.perf_state.enabled {
            Some(std::time::Instant::now())
        } else {
            None
        };
        #[derive(Debug)]
        struct HeightMismatch {
            history_id: HistoryId,
            cached: u16,
            recomputed: u16,
            idx: usize,
            preview: String,
        }

        let mut height_mismatches: Vec<HeightMismatch> = Vec::new();

        for (offset, visible) in visible_slice.iter().enumerate() {
            let idx = start_idx + offset;
            let item = visible
                .cell
                .expect("visible cell missing backing cell for render");
            // Calculate height with reduced width due to gutter
            const GUTTER_WIDTH: u16 = 2;
            let content_width = content_area.width.saturating_sub(GUTTER_WIDTH);
            let maybe_assistant = item
                .as_any()
                .downcast_ref::<crate::history_cell::AssistantMarkdownCell>();
            let is_streaming = item
                .as_any()
                .downcast_ref::<crate::history_cell::StreamingContentCell>()
                .is_some();

            let mut layout_for_render: Option<Rc<CachedLayout>> = visible
                .layout
                .as_ref()
                .map(|lr| lr.layout());

            let item_height = visible.height;
            if content_area.width > 0 {
                if let Some(req) = render_requests.get(idx) {
                    if req.history_id != HistoryId::ZERO
                        && matches!(item.kind(), history_cell::HistoryCellType::Reasoning)
                    {
                        if item_height == 0 && content_width == 0 {
                            // Zero-width viewport leaves both cached and computed heights at 0.
                            // Skip to avoid false positives during aggressive window resizes.
                            continue;
                        }

                        #[cfg(debug_assertions)]
                        {
                            let mut preview: Option<String> = None;
                            let fresh = item.desired_height(content_width);
                            if fresh != item_height {
                                if preview.is_none() {
                                    let lines = item.display_lines_trimmed();
                                    if !lines.is_empty() {
                                        preview = Some(ChatWidget::reasoning_preview(&lines));
                                    }
                                }
                                height_mismatches.push(HeightMismatch {
                                    history_id: req.history_id,
                                    cached: item_height,
                                    recomputed: fresh,
                                    idx,
                                    preview: preview.unwrap_or_default(),
                                });
                            }
                        }
                    }
                }
            }
            if self.perf_state.enabled
                && rendered_cells_full.is_none()
                && matches!(visible.height_source, history_render::HeightSource::DesiredHeight)
            {
                let mut p = self.perf_state.stats.borrow_mut();
                p.height_misses_render = p.height_misses_render.saturating_add(1);
                if let Some(ns) = visible.height_measure_ns {
                    let label = self.perf_label_for_item(item);
                    p.record_render((idx, content_width), label.as_str(), ns);
                }
            }

            let content_y = ps[idx];

            // The prefix sums already account for spacer rows between cells (and omit the
            // trailing spacer). Avoid additional compensation when rendering the final
            // visible cell; otherwise we double-count spacing and trim the last line.
            let skip_top = if content_y < scroll_pos {
                scroll_pos - content_y
            } else {
                0
            };

            // Stop if we've gone past the bottom of the screen
            if screen_y >= content_area.y + content_area.height {
                break;
            }

            // Calculate how much height is available for this item
            let available_height = (content_area.y + content_area.height).saturating_sub(screen_y);
            let visible_height = item_height.saturating_sub(skip_top).min(available_height);


            if visible_height > 0 {
                // Define gutter width (2 chars: symbol + space)
                const GUTTER_WIDTH: u16 = 2;

                // Split area into gutter and content
                let gutter_area = Rect {
                    x: content_area.x,
                    y: screen_y,
                    width: GUTTER_WIDTH.min(content_area.width),
                    height: visible_height,
                };

                let item_area = Rect {
                    x: content_area.x + GUTTER_WIDTH.min(content_area.width),
                    y: screen_y,
                    width: content_area.width.saturating_sub(GUTTER_WIDTH),
                    height: visible_height,
                };

                if history_cell_logging_enabled() {
                    let row_start = item_area.y;
                    let row_end = item_area
                        .y
                        .saturating_add(visible_height)
                        .saturating_sub(1);
                    let cache_hit = layout_for_render.is_some();
                    tracing::info!(
                        target: "code_tui::history_cells",
                        idx,
                        kind = ?item.kind(),
                        row_start,
                        row_end,
                        height = visible_height,
                        width = item_area.width,
                        skip_rows = skip_top,
                        item_height,
                        content_y,
                        cache_hit,
                        assistant = maybe_assistant.is_some(),
                        streaming = is_streaming,
                        custom = item.has_custom_render(),
                        animating = item.is_animating(),
                        "history cell render",
                    );
                }

                // Paint gutter background. For Assistant, extend the assistant tint under the
                // gutter and also one extra column to the left (so the • has color on both sides),
                // without changing layout or symbol positions.
                let is_assistant =
                    matches!(item.kind(), crate::history_cell::HistoryCellType::Assistant);
                let gutter_bg = if is_assistant {
                    crate::colors::assistant_bg()
                } else {
                    crate::colors::background()
                };

                // Paint gutter background for assistant cells so the tinted
                // strip appears contiguous with the message body. This avoids
                // the light "hole" seen after we reduced redraws. For other
                // cell types keep the default background (already painted by
                // the frame bg fill above).
                if is_assistant && gutter_area.width > 0 && gutter_area.height > 0 {
                    let _perf_gutter_start = if self.perf_state.enabled {
                        Some(std::time::Instant::now())
                    } else {
                        None
                    };
                    let style = Style::default().bg(gutter_bg);
                    let mut tint_x = gutter_area.x;
                    let mut tint_width = gutter_area.width;
                    if content_area.x > history_area.x {
                        tint_x = content_area.x.saturating_sub(1);
                        tint_width = tint_width.saturating_add(1);
                    }
                    let tint_rect = Rect::new(tint_x, gutter_area.y, tint_width, gutter_area.height);
                    fill_rect(buf, tint_rect, Some(' '), style);
                    // Also tint one column immediately to the right of the content area
                    // so the assistant block is visually bookended. This column lives in the
                    // right padding stripe; when the scrollbar is visible it will draw over
                    // the far-right edge, which is fine.
                    let right_col_x = content_area.x.saturating_add(content_area.width);
                    let history_right = history_area.x.saturating_add(history_area.width);
                    if right_col_x < history_right {
                        let right_rect = Rect::new(right_col_x, item_area.y, 1, item_area.height);
                        fill_rect(buf, right_rect, Some(' '), style);
                    }
                    if let Some(t0) = _perf_gutter_start {
                        let dt = t0.elapsed().as_nanos();
                        let mut p = self.perf_state.stats.borrow_mut();
                        p.ns_gutter_paint = p.ns_gutter_paint.saturating_add(dt);
                        // Rough accounting: area of gutter rectangle (clamped to u64)
                        let area_cells: u64 =
                            (gutter_area.width as u64).saturating_mul(gutter_area.height as u64);
                        p.cells_gutter_paint = p.cells_gutter_paint.saturating_add(area_cells);
                    }
                }

                // Render gutter symbol if present
                if let Some(symbol) = item.gutter_symbol() {
                    // Choose color based on symbol/type
                    let color = if symbol == "❯" {
                        // Executed arrow – color reflects exec state
                        if let Some(exec) = item
                            .as_any()
                            .downcast_ref::<crate::history_cell::ExecCell>()
                        {
                            match &exec.output {
                                None => crate::colors::text(), // Running...
                                // Successful runs use the theme success color so the arrow stays visible on all themes
                                Some(o) if o.exit_code == 0 => crate::colors::text(),
                                Some(_) => crate::colors::error(),
                            }
                        } else {
                            // Handle merged exec cells (multi-block "Ran") the same as single execs
                            match item.kind() {
                                crate::history_cell::HistoryCellType::Exec {
                                    kind: crate::history_cell::ExecKind::Run,
                                    status: crate::history::state::ExecStatus::Success,
                                } => crate::colors::text(),
                                crate::history_cell::HistoryCellType::Exec {
                                    kind: crate::history_cell::ExecKind::Run,
                                    status: crate::history::state::ExecStatus::Error,
                                } => crate::colors::error(),
                                crate::history_cell::HistoryCellType::Exec { .. } => {
                                    crate::colors::text()
                                }
                                _ => crate::colors::text(),
                            }
                        }
                    } else if symbol == "↯" {
                        // Patch/Updated arrow color – match the header text color
                        match item.kind() {
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::ApplySuccess,
                            } => crate::colors::success(),
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::ApplyBegin,
                            } => crate::colors::success(),
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::Proposed,
                            } => crate::colors::primary(),
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::ApplyFailure,
                            } => crate::colors::error(),
                            _ => crate::colors::primary(),
                        }
                    } else if matches!(symbol, "◐" | "◓" | "◑" | "◒")
                        && item
                            .as_any()
                            .downcast_ref::<crate::history_cell::RunningToolCallCell>()
                            .map_or(false, |cell| cell.has_title("Waiting"))
                    {
                        crate::colors::text_bright()
                    } else if matches!(symbol, "○" | "◔" | "◑" | "◕" | "●") {
                        if let Some(plan_cell) = item
                            .as_any()
                            .downcast_ref::<crate::history_cell::PlanUpdateCell>()
                        {
                            if plan_cell.is_complete() {
                                crate::colors::success()
                            } else {
                                crate::colors::info()
                            }
                        } else {
                            crate::colors::success()
                        }
                    } else {
                        match symbol {
                            "›" => crate::colors::text(),        // user
                            "⋮" => crate::colors::primary(),     // thinking
                            "•" => crate::colors::text_bright(), // codex/agent
                            "⚙" => crate::colors::info(),        // tool working
                            "✔" => crate::colors::success(),     // tool complete
                            "✖" => crate::colors::error(),       // error
                            "★" => crate::colors::text_bright(), // notice/popular
                            _ => crate::colors::text_dim(),
                        }
                    };

                    // Draw the symbol anchored to the top of the message (not the viewport).
                    // "Top of the message" accounts for any intentional top padding per cell type.
                    // As you scroll past that anchor, the icon scrolls away with the message.
                    if gutter_area.width >= 2 {
                        // Anchor offset counted from the very start of the item's painted area
                        // to the first line of its content that the icon should align with.
                        let anchor_offset: u16 = match item.kind() {
                            // Assistant messages render with one row of top padding so that
                            // the content visually aligns; anchor to that second row.
                            crate::history_cell::HistoryCellType::Assistant => 1,
                            _ => 0,
                        };

                        // If we've scrolled past the anchor line, don't render the icon.
                        if skip_top <= anchor_offset {
                            let rel = anchor_offset - skip_top; // rows from current viewport top
                            let symbol_y = gutter_area.y.saturating_add(rel);
                            if symbol_y < gutter_area.y.saturating_add(gutter_area.height) {
                                let symbol_style = Style::default().fg(color).bg(gutter_bg);
                                buf.set_string(gutter_area.x, symbol_y, symbol, symbol_style);
                            }
                        }
                    }
                }

                // Render only the visible window of the item using vertical skip
                let skip_rows = skip_top;

                // Log all cells being rendered
                let is_animating = item.is_animating();
                let has_custom = item.has_custom_render();

                if is_animating || has_custom {
                    tracing::debug!(
                        ">>> RENDERING ANIMATION Cell[{}]: area={:?}, skip_rows={}",
                        idx,
                        item_area,
                        skip_rows
                    );
                }

                // Render the cell content first
                let mut handled_assistant = false;
                if let Some(plan) = visible.assistant_plan.as_ref() {
                    if let Some(assistant) = visible
                        .cell
                        .and_then(|c| c.as_any().downcast_ref::<crate::history_cell::AssistantMarkdownCell>())
                    {
                        if skip_rows < plan.total_rows() && item_area.height > 0 {
                            assistant.render_with_layout(plan.as_ref(), item_area, buf, skip_rows);
                        }
                        handled_assistant = true;
                        layout_for_render = None;
                    }
                }

                if !handled_assistant {
                    if let Some(layout_rc) = layout_for_render.as_ref() {
                        self.render_cached_lines(
                            item,
                            layout_rc.as_ref(),
                            item_area,
                            buf,
                            skip_rows,
                        );
                    } else {
                        item.render_with_skip(item_area, buf, skip_rows);
                    }
                }

                // Debug: overlay order info on the spacing row below (or above if needed).
                if self.show_order_overlay {
                    if let Some(Some(info)) = self.cell_order_dbg.get(idx) {
                        let mut text = format!("⟦{}⟧", info);
                        // Live reasoning diagnostics: append current title detection snapshot
                        if let Some(rc) = item
                            .as_any()
                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                        {
                            let snap = rc.debug_title_overlay();
                            text.push_str(" | ");
                            text.push_str(&snap);
                        }
                        let style = Style::default().fg(crate::colors::text_dim());
                        // Prefer below the item in the one-row spacing area
                        let below_y = item_area.y.saturating_add(visible_height);
                        let bottom_y = content_area.y.saturating_add(content_area.height);
                        let maxw = item_area.width as usize;
                        // Truncate safely by display width, not by bytes, to avoid
                        // panics on non-UTF-8 boundaries (e.g., emoji/CJK). Use the
                        // same width logic as our live wrap utilities.
                        let draw_text = {
                            use unicode_width::UnicodeWidthStr as _;
                            if text.width() > maxw {
                                crate::live_wrap::take_prefix_by_width(&text, maxw).0
                            } else {
                                text.clone()
                            }
                        };
                        if item_area.width > 0 {
                            if below_y < bottom_y {
                                buf.set_string(item_area.x, below_y, draw_text.clone(), style);
                            } else if item_area.y > content_area.y {
                                // Fall back to above the item if no space below
                                let above_y = item_area.y.saturating_sub(1);
                                buf.set_string(item_area.x, above_y, draw_text.clone(), style);
                            }
                        }
                    }
                }
                screen_y += visible_height;
            }

            // Add spacing only if something was actually rendered for this item.
            // Prevent a stray blank when zero-height, and suppress spacing between
            // consecutive collapsed reasoning titles so they appear as a tight list.
            let mut should_add_spacing = idx < request_count.saturating_sub(1) && visible_height > 0;
            if should_add_spacing {
                // Special-case: two adjacent collapsed reasoning cells → no spacer.
                let this_is_collapsed_reasoning = item
                    .as_any()
                    .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                    .map(|rc| rc.is_collapsed())
                    .unwrap_or(false);
                if this_is_collapsed_reasoning {
                    let prev_is_collapsed_reasoning = render_requests
                        .get(idx.saturating_sub(1))
                        .and_then(|req| req.cell)
                        .and_then(|c| {
                            c.as_any()
                                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                                .map(|rc| rc.is_collapsed())
                        })
                        .unwrap_or(false);
                    let next_is_collapsed_reasoning = render_requests
                        .get(idx + 1)
                        .and_then(|req| req.cell)
                        .and_then(|c| {
                            c.as_any()
                                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                                .map(|rc| rc.is_collapsed())
                        })
                        .unwrap_or(false);
                    if prev_is_collapsed_reasoning && next_is_collapsed_reasoning {
                        should_add_spacing = false;
                    }
                }
            }
            if should_add_spacing {
                let bottom = content_area.y + content_area.height;
                if screen_y < bottom {
                    // Maintain the single-row spacer between cells (critical for explore →
                    // reasoning bundles) while respecting the visible viewport height. This keeps
                    // the rendered gaps consistent with the cached prefix sums even after scroll
                    // adjustments.
                    let spacing_rows = spacing.min(bottom.saturating_sub(screen_y));
                    screen_y = screen_y.saturating_add(spacing_rows);
                }
            }
        }

        drop(ps_ref);

        if let Some(first) = height_mismatches.first() {
            for mismatch in &height_mismatches {
                tracing::error!(
                    target: "code_tui::history_cells",
                    history_id = ?mismatch.history_id,
                    idx = mismatch.idx,
                    cached = mismatch.cached,
                    recomputed = mismatch.recomputed,
                    preview = %mismatch.preview,
                    "History cell height mismatch detected; aborting to capture repro",
                );
            }
            panic!(
                "history cell height mismatch ({} cases); first id={:?} cached={} recomputed={} preview={}",
                height_mismatches.len(),
                first.history_id,
                first.cached,
                first.recomputed,
                first.preview
            );
        }
        if let Some(start) = render_loop_start {
            if self.perf_state.enabled {
                let elapsed = start.elapsed().as_nanos();
                let pending_scroll = self.perf_state.pending_scroll_rows.get();
                {
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_render_loop = p.ns_render_loop.saturating_add(elapsed);
                    if pending_scroll > 0 {
                        p.record_scroll_render(pending_scroll, elapsed);
                    }
                }
                if pending_scroll > 0 {
                    self.perf_state.pending_scroll_rows.set(0);
                }
            }
        }

        // Clear any bottom gap inside the content area that wasn’t covered by items
        if screen_y < content_area.y + content_area.height {
            let _perf_hist_clear2 = if self.perf_state.enabled {
                Some(std::time::Instant::now())
            } else {
                None
            };
            let gap_height = (content_area.y + content_area.height).saturating_sub(screen_y);
            if gap_height > 0 {
                let gap_rect = Rect::new(content_area.x, screen_y, content_area.width, gap_height);
                fill_rect(buf, gap_rect, Some(' '), base_style);
            }
            if let Some(t0) = _perf_hist_clear2 {
                let dt = t0.elapsed().as_nanos();
                let mut p = self.perf_state.stats.borrow_mut();
                p.ns_history_clear = p.ns_history_clear.saturating_add(dt);
                let cells = (content_area.width as u64)
                    * ((content_area.y + content_area.height - screen_y) as u64);
                p.cells_history_clear = p.cells_history_clear.saturating_add(cells);
            }
        }

        // Render vertical scrollbar when content is scrollable and currently visible
        // Auto-hide after a short delay to avoid copying it along with text.
        let now = std::time::Instant::now();
        let show_scrollbar = total_height > content_area.height
            && self
                .layout
                .scrollbar_visible_until
                .get()
                .map(|t| now < t)
                .unwrap_or(false);
        if show_scrollbar {
            let mut sb_state = self.layout.vertical_scrollbar_state.borrow_mut();
            // Scrollbar expects number of scroll positions, not total rows.
            // For a viewport of H rows and content of N rows, there are
            // max_scroll = N - H positions; valid positions = [0, max_scroll].
            let max_scroll = total_height.saturating_sub(content_area.height);
            let scroll_positions = max_scroll.saturating_add(1).max(1) as usize;
            let pos = scroll_pos.min(max_scroll) as usize;
            *sb_state = sb_state.content_length(scroll_positions).position(pos);
            // Theme-aware scrollbar styling (line + block)
            // Track: thin line using border color; Thumb: block using border_focused.
            let theme = crate::theme::current_theme();
            let sb = Scrollbar::new(ScrollbarOrientation::VerticalRight)
                .symbols(scrollbar_symbols::VERTICAL)
                .begin_symbol(None)
                .end_symbol(None)
                .track_symbol(Some("│"))
                .track_style(
                    Style::default()
                        .fg(crate::colors::border())
                        .bg(crate::colors::background()),
                )
                .thumb_symbol("█")
                .thumb_style(
                    Style::default()
                        .fg(theme.border_focused)
                        .bg(crate::colors::background()),
                );
            // To avoid a small jump at the bottom due to spacer toggling,
            // render the scrollbar in a slightly shorter area (reserve 1 row).
            let sb_area = Rect {
                x: history_area.x,
                y: history_area.y,
                width: history_area.width,
                height: history_area.height.saturating_sub(1),
            };
            StatefulWidget::render(sb, sb_area, buf, &mut sb_state);
        }

        if self.terminal.overlay().is_some() {
            let bg_style = Style::default().bg(crate::colors::background());
            fill_rect(buf, bottom_pane_area, Some(' '), bg_style);
        } else if self.agents_terminal.active {
            let bg_style = Style::default().bg(crate::colors::background());
            fill_rect(buf, bottom_pane_area, Some(' '), bg_style);
        } else {
            // Render the bottom pane directly without a border for now
            // The composer has its own layout with hints at the bottom
            (&self.bottom_pane).render(bottom_pane_area, buf);
        }

        if let Some(overlay) = self.terminal.overlay() {
            let scrim_style = Style::default()
                .bg(crate::colors::overlay_scrim())
                .fg(crate::colors::text_dim());
            fill_rect(buf, area, None, scrim_style);

            let padding = 1u16;
            let footer_reserved = 1.min(bottom_pane_area.height);
            let overlay_bottom = (bottom_pane_area.y + bottom_pane_area.height)
                .saturating_sub(footer_reserved);
            let overlay_height = overlay_bottom
                .saturating_sub(history_area.y)
                .max(1)
                .min(area.height);
            let window_area = Rect {
                x: history_area.x + padding,
                y: history_area.y,
                width: history_area.width.saturating_sub(padding * 2),
                height: overlay_height,
            };
            Clear.render(window_area, buf);

            let block = Block::default()
                .borders(Borders::ALL)
                .title(ratatui::text::Line::from(vec![
                    ratatui::text::Span::styled(
                        format!(" Terminal - {} ", overlay.title),
                        Style::default().fg(crate::colors::text()),
                    ),
                ]))
                .style(Style::default().bg(crate::colors::background()))
                .border_style(
                    Style::default()
                        .fg(crate::colors::border())
                        .bg(crate::colors::background()),
                );
            let inner = block.inner(window_area);
            block.render(window_area, buf);

            let inner_bg = Style::default().bg(crate::colors::background());
            for y in inner.y..inner.y + inner.height {
                for x in inner.x..inner.x + inner.width {
                    buf[(x, y)].set_style(inner_bg);
                }
            }

            let content = inner.inner(ratatui::layout::Margin::new(1, 0));
            if content.height == 0 || content.width == 0 {
                self.terminal.last_visible_rows.set(0);
                self.terminal.last_visible_cols.set(0);
            } else {
                let header_height = 1.min(content.height);
                let footer_height = if content.height >= 2 { 2 } else { 0 };

                let header_area = Rect {
                    x: content.x,
                    y: content.y,
                    width: content.width,
                    height: header_height,
                };
                let footer_area = if footer_height > 0 {
                    Rect {
                        x: content.x,
                        y: content
                            .y
                            .saturating_add(content.height.saturating_sub(footer_height)),
                        width: content.width,
                        height: footer_height,
                    }
                } else {
                    header_area
                };

                if header_height > 0 {
                    fill_rect(buf, header_area, Some(' '), inner_bg);
                    let width_limit = header_area.width as usize;
                    let mut header_spans: Vec<ratatui::text::Span<'static>> = Vec::new();
                    let mut consumed_width: usize = 0;

                    if overlay.running {
                        let now_ms = std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_millis();
                        let frame = crate::spinner::frame_at_time(
                            crate::spinner::current_spinner(),
                            now_ms,
                        );
                        if !frame.is_empty() {
                            consumed_width += frame.chars().count();
                            header_spans.push(ratatui::text::Span::styled(
                                frame,
                                Style::default().fg(crate::colors::spinner()),
                            ));
                            header_spans.push(ratatui::text::Span::raw(" "));
                            consumed_width = consumed_width.saturating_add(1);
                        }

                        let status_text = overlay
                            .start_time
                            .map(|start| format!("Running… ({})", format_duration(start.elapsed())))
                            .unwrap_or_else(|| "Running…".to_string());
                        consumed_width = consumed_width
                            .saturating_add(UnicodeWidthStr::width(status_text.as_str()));
                        header_spans.push(ratatui::text::Span::styled(
                            status_text,
                            Style::default().fg(crate::colors::text_dim()),
                        ));

                        let interval = crate::spinner::current_spinner().interval_ms.max(50);
                        self.app_event_tx
                            .send(AppEvent::ScheduleFrameIn(Duration::from_millis(interval)));
                    } else {
                        let (icon, color, status_text) = match overlay.exit_code {
                            Some(0) => (
                                "✔",
                                crate::colors::success(),
                                overlay
                                    .duration
                                    .map(|d| format!("Completed in {}", format_duration(d)))
                                    .unwrap_or_else(|| "Completed".to_string()),
                            ),
                            Some(code) => (
                                "✖",
                                crate::colors::error(),
                                overlay
                                    .duration
                                    .map(|d| format!("Exit {code} in {}", format_duration(d)))
                                    .unwrap_or_else(|| format!("Exit {code}")),
                            ),
                            None => (
                                "⚠",
                                crate::colors::warning(),
                                overlay
                                    .duration
                                    .map(|d| format!("Stopped after {}", format_duration(d)))
                                    .unwrap_or_else(|| "Stopped".to_string()),
                            ),
                        };

                        header_spans.push(ratatui::text::Span::styled(
                            format!("{icon} "),
                            Style::default().fg(color),
                        ));
                        consumed_width = consumed_width.saturating_add(icon.chars().count() + 1);

                        consumed_width = consumed_width
                            .saturating_add(UnicodeWidthStr::width(status_text.as_str()));
                        header_spans.push(ratatui::text::Span::styled(
                            status_text,
                            Style::default().fg(crate::colors::text_dim()),
                        ));
                    }

                    if !overlay.command_display.is_empty() && width_limit > consumed_width + 5 {
                        let remaining = width_limit.saturating_sub(consumed_width + 5);
                        if remaining > 0 {
                            let truncated = ChatWidget::truncate_with_ellipsis(
                                &overlay.command_display,
                                remaining,
                            );
                            if !truncated.is_empty() {
                                header_spans.push(ratatui::text::Span::styled(
                                    "  •  ",
                                    Style::default().fg(crate::colors::text_dim()),
                                ));
                                header_spans.push(ratatui::text::Span::styled(
                                    truncated,
                                    Style::default().fg(crate::colors::text()),
                                ));
                            }
                        }
                    }

                    let header_line = ratatui::text::Line::from(header_spans);
                    Paragraph::new(RtText::from(vec![header_line]))
                        .wrap(ratatui::widgets::Wrap { trim: true })
                        .render(header_area, buf);
                }

                let mut body_space = content
                    .height
                    .saturating_sub(header_height.saturating_add(footer_height));
                let body_top = header_area.y.saturating_add(header_area.height);
                let mut bottom_cursor = body_top.saturating_add(body_space);

                let mut pending_visible = false;
                let mut pending_box: Option<(Rect, Vec<RtLine<'static>>)> = None;
                if let Some(pending) = overlay.pending_command.as_ref() {
                    if let Some((pending_lines, pending_height)) =
                        pending_command_box_lines(pending, content.width)
                    {
                        if pending_height <= body_space && pending_height > 0 {
                            bottom_cursor = bottom_cursor.saturating_sub(pending_height);
                            let pending_area = Rect {
                                x: content.x,
                                y: bottom_cursor,
                                width: content.width,
                                height: pending_height,
                            };
                            body_space = body_space.saturating_sub(pending_height);
                            pending_box = Some((pending_area, pending_lines));
                            pending_visible = true;
                        }
                    }
                }

                let body_area = Rect {
                    x: content.x,
                    y: body_top,
                    width: content.width,
                    height: body_space,
                };

                // Body content
                let rows = body_area.height;
                let cols = body_area.width;
                let prev_rows = self.terminal.last_visible_rows.replace(rows);
                let prev_cols = self.terminal.last_visible_cols.replace(cols);
                if rows > 0 && cols > 0 && (prev_rows != rows || prev_cols != cols) {
                    self.app_event_tx.send(AppEvent::TerminalResize {
                        id: overlay.id,
                        rows,
                        cols,
                    });
                }

                if rows > 0 && cols > 0 {
                    let mut rendered_rows: Vec<RtLine<'static>> = Vec::new();
                    if overlay.truncated {
                        rendered_rows.push(ratatui::text::Line::from(vec![
                            ratatui::text::Span::styled(
                                "… output truncated (showing last 10,000 lines)",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }
                    rendered_rows.extend(overlay.lines.iter().cloned());
                    let total = rendered_rows.len();
                    let visible = rows as usize;
                    if visible > 0 {
                        let max_scroll = total.saturating_sub(visible);
                        let scroll = (overlay.scroll as usize).min(max_scroll);
                        let end = (scroll + visible).min(total);
                        let window = rendered_rows.get(scroll..end).unwrap_or(&[]);
                        Paragraph::new(RtText::from(window.to_vec()))
                            .wrap(ratatui::widgets::Wrap { trim: false })
                            .render(body_area, buf);
                    }
                }

                if let Some((pending_area, pending_lines)) = pending_box {
                    render_text_box(
                        pending_area,
                        " Command ",
                        crate::colors::function(),
                        pending_lines,
                        buf,
                    );
                }

                // Footer hints
                let mut footer_spans = vec![
                    ratatui::text::Span::styled(
                        "↑↓",
                        Style::default().fg(crate::colors::function()),
                    ),
                    ratatui::text::Span::styled(
                        " Scroll  ",
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                    ratatui::text::Span::styled(
                        "Esc",
                        Style::default().fg(crate::colors::error()),
                    ),
                    ratatui::text::Span::styled(
                        if overlay.running { " Cancel  " } else { " Close  " },
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                ];
                if overlay.running {
                    footer_spans.push(ratatui::text::Span::styled(
                        "Ctrl+C",
                        Style::default().fg(crate::colors::warning()),
                    ));
                    footer_spans.push(ratatui::text::Span::styled(
                        " Cancel",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                } else if pending_visible {
                    footer_spans.push(ratatui::text::Span::styled(
                        "Enter",
                        Style::default().fg(crate::colors::primary()),
                    ));
                    footer_spans.push(ratatui::text::Span::styled(
                        " Run",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                }
                if footer_height > 1 {
                    let spacer_area = Rect {
                        x: footer_area.x,
                        y: footer_area.y,
                        width: footer_area.width,
                        height: footer_area.height.saturating_sub(1),
                    };
                    fill_rect(buf, spacer_area, Some(' '), inner_bg);
                }

                let instructions_area = Rect {
                    x: footer_area.x,
                    y: footer_area.y.saturating_add(footer_area.height.saturating_sub(1)),
                    width: footer_area.width,
                    height: 1,
                };

                Paragraph::new(RtText::from(vec![ratatui::text::Line::from(footer_spans)]))
                    .wrap(ratatui::widgets::Wrap { trim: true })
                    .alignment(ratatui::layout::Alignment::Left)
                    .render(instructions_area, buf);
            }
        }

        if self.terminal.overlay().is_none() && self.browser_overlay_visible {
            self.render_browser_overlay(area, history_area, bottom_pane_area, buf);
            return;
        }

        if self.terminal.overlay().is_none() && self.agents_terminal.active {
            self.render_agents_terminal_overlay(area, history_area, bottom_pane_area, buf);
        }

        // Terminal overlay takes precedence over other overlays

        // Welcome animation is kept as a normal cell in history; no overlay.

        // The welcome animation is no longer rendered as an overlay.

        let terminal_overlay_none = self.terminal.overlay().is_none();
        let agents_terminal_active = self.agents_terminal.active;
        if terminal_overlay_none && !agents_terminal_active {
            if let Some(overlay) = self.settings.overlay.as_ref() {
                self.render_settings_overlay(area, history_area, buf, overlay);
            } else if let Some(overlay) = &self.diffs.overlay {
                // Global scrim: dim the whole background to draw focus to the viewer
                // We intentionally do this across the entire widget area rather than just the
                // history area so the viewer stands out even with browser HUD or status bars.
                let scrim_bg = Style::default()
                    .bg(crate::colors::overlay_scrim())
                    .fg(crate::colors::text_dim());
                let _perf_scrim_start = if self.perf_state.enabled {
                    Some(std::time::Instant::now())
                } else {
                    None
                };
                fill_rect(buf, area, None, scrim_bg);
                if let Some(t0) = _perf_scrim_start {
                    let dt = t0.elapsed().as_nanos();
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_overlay_scrim = p.ns_overlay_scrim.saturating_add(dt);
                    let cells = (area.width as u64) * (area.height as u64);
                    p.cells_overlay_scrim = p.cells_overlay_scrim.saturating_add(cells);
                }
                // Match the horizontal padding used by status bar and input
                let padding = 1u16;
                let area = Rect {
                    x: history_area.x + padding,
                    y: history_area.y,
                    width: history_area.width.saturating_sub(padding * 2),
                    height: history_area.height,
                };

                // Clear and repaint the overlay area with theme scrim background
                Clear.render(area, buf);
                let bg_style = Style::default().bg(crate::colors::overlay_scrim());
                let _perf_overlay_area_bg_start = if self.perf_state.enabled {
                    Some(std::time::Instant::now())
                } else {
                    None
                };
                fill_rect(buf, area, None, bg_style);
                if let Some(t0) = _perf_overlay_area_bg_start {
                    let dt = t0.elapsed().as_nanos();
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_overlay_body_bg = p.ns_overlay_body_bg.saturating_add(dt);
                    let cells = (area.width as u64) * (area.height as u64);
                    p.cells_overlay_body_bg = p.cells_overlay_body_bg.saturating_add(cells);
                }

                // Build a styled title: keys/icons in normal text color; descriptors and dividers dim
                let t_dim = Style::default().fg(crate::colors::text_dim());
                let t_fg = Style::default().fg(crate::colors::text());
                let has_tabs = overlay.tabs.len() > 1;
                let mut title_spans: Vec<ratatui::text::Span<'static>> = vec![
                    ratatui::text::Span::styled(" ", t_dim),
                    ratatui::text::Span::styled("Diff viewer", t_fg),
                ];
                if has_tabs {
                    title_spans.extend_from_slice(&[
                        ratatui::text::Span::styled(" ——— ", t_dim),
                        ratatui::text::Span::styled("◂ ▸", t_fg),
                        ratatui::text::Span::styled(" change tabs ", t_dim),
                    ]);
                }
                title_spans.extend_from_slice(&[
                    ratatui::text::Span::styled("——— ", t_dim),
                    ratatui::text::Span::styled("e", t_fg),
                    ratatui::text::Span::styled(" explain ", t_dim),
                    ratatui::text::Span::styled("——— ", t_dim),
                    ratatui::text::Span::styled("u", t_fg),
                    ratatui::text::Span::styled(" undo ", t_dim),
                    ratatui::text::Span::styled("——— ", t_dim),
                    ratatui::text::Span::styled("Esc", t_fg),
                    ratatui::text::Span::styled(" close ", t_dim),
                ]);
                let block = Block::default()
                    .borders(Borders::ALL)
                    .title(ratatui::text::Line::from(title_spans))
                    // Use normal background for the window itself so it contrasts against the
                    // dimmed scrim behind
                    .style(Style::default().bg(crate::colors::background()))
                    .border_style(
                        Style::default()
                            .fg(crate::colors::border())
                            .bg(crate::colors::background()),
                    );
                let inner = block.inner(area);
                block.render(area, buf);

                // Paint inner content background as the normal theme background
                let inner_bg = Style::default().bg(crate::colors::background());
                let _perf_overlay_inner_bg_start = if self.perf_state.enabled {
                    Some(std::time::Instant::now())
                } else {
                    None
                };
                for y in inner.y..inner.y + inner.height {
                    for x in inner.x..inner.x + inner.width {
                        buf[(x, y)].set_style(inner_bg);
                    }
                }
                if let Some(t0) = _perf_overlay_inner_bg_start {
                    let dt = t0.elapsed().as_nanos();
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_overlay_body_bg = p.ns_overlay_body_bg.saturating_add(dt);
                    let cells = (inner.width as u64) * (inner.height as u64);
                    p.cells_overlay_body_bg = p.cells_overlay_body_bg.saturating_add(cells);
                }

                // Split into header tabs and body/footer
                // Add one cell padding around the entire inside of the window
                let padded_inner = inner.inner(ratatui::layout::Margin::new(1, 1));
                let [tabs_area, body_area] = if has_tabs {
                    Layout::vertical([Constraint::Length(2), Constraint::Fill(1)])
                        .areas(padded_inner)
                } else {
                    // Keep a small header row to show file path and counts
                    let [t, b] = Layout::vertical([Constraint::Length(2), Constraint::Fill(1)])
                        .areas(padded_inner);
                    [t, b]
                };

                // Render tabs only if we have more than one file
                if has_tabs {
                    let labels: Vec<String> = overlay
                        .tabs
                        .iter()
                        .map(|(t, _)| format!("  {}  ", t))
                        .collect();
                    let mut constraints: Vec<Constraint> = Vec::new();
                    let mut total: u16 = 0;
                    for label in &labels {
                        let w = (label.chars().count() as u16)
                            .min(tabs_area.width.saturating_sub(total));
                        constraints.push(Constraint::Length(w));
                        total = total.saturating_add(w);
                        if total >= tabs_area.width.saturating_sub(4) {
                            break;
                        }
                    }
                    constraints.push(Constraint::Fill(1));
                    let chunks = Layout::horizontal(constraints).split(tabs_area);
                    // Draw a light bottom border across the entire tabs strip
                    let tabs_bottom_rule = Block::default()
                        .borders(Borders::BOTTOM)
                        .border_style(Style::default().fg(crate::colors::border()));
                    tabs_bottom_rule.render(tabs_area, buf);
                    for i in 0..labels.len() {
                        // last chunk is filler; guard below
                        if i >= chunks.len().saturating_sub(1) {
                            break;
                        }
                        let rect = chunks[i];
                        if rect.width == 0 {
                            continue;
                        }
                        let selected = i == overlay.selected;

                        // Both selected and unselected tabs use the normal background
                        let tab_bg = crate::colors::background();
                        let bg_style = Style::default().bg(tab_bg);
                        for y in rect.y..rect.y + rect.height {
                            for x in rect.x..rect.x + rect.width {
                                buf[(x, y)].set_style(bg_style);
                            }
                        }

                        // Render label at the top line, with padding
                        let label_rect = Rect {
                            x: rect.x + 1,
                            y: rect.y,
                            width: rect.width.saturating_sub(2),
                            height: 1,
                        };
                        let label_style = if selected {
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD)
                        } else {
                            Style::default().fg(crate::colors::text_dim())
                        };
                        let line = ratatui::text::Line::from(ratatui::text::Span::styled(
                            labels[i].clone(),
                            label_style,
                        ));
                        Paragraph::new(RtText::from(vec![line]))
                            .wrap(ratatui::widgets::Wrap { trim: true })
                            .render(label_rect, buf);
                        // Selected tab: thin underline using text_bright under the label width
                        if selected {
                            let label_len = labels[i].chars().count() as u16;
                            let accent_w = label_len.min(rect.width.saturating_sub(2)).max(1);
                            let accent_rect = Rect {
                                x: label_rect.x,
                                y: rect.y + rect.height.saturating_sub(1),
                                width: accent_w,
                                height: 1,
                            };
                            let underline = Block::default()
                                .borders(Borders::BOTTOM)
                                .border_style(Style::default().fg(crate::colors::text_bright()));
                            underline.render(accent_rect, buf);
                        }
                    }
                } else {
                    // Single-file header: show full path with (+adds -dels)
                    if let Some((label, _)) = overlay.tabs.get(overlay.selected) {
                        let header_line = ratatui::text::Line::from(ratatui::text::Span::styled(
                            label.clone(),
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD),
                        ));
                        let para = Paragraph::new(RtText::from(vec![header_line]))
                            .wrap(ratatui::widgets::Wrap { trim: true });
                        ratatui::widgets::Widget::render(para, tabs_area, buf);
                    }
                }

                // Render selected tab with vertical scroll and highlight current diff block
                if let Some((_, blocks)) = overlay.tabs.get(overlay.selected) {
                    // Flatten blocks into lines and record block start indices
                    let mut all_lines: Vec<ratatui::text::Line<'static>> = Vec::new();
                    let mut block_starts: Vec<(usize, usize)> = Vec::new(); // (start_index, len)
                    for b in blocks {
                        let start = all_lines.len();
                        block_starts.push((start, b.lines.len()));
                        all_lines.extend(b.lines.clone());
                    }

                    let raw_skip = overlay
                        .scroll_offsets
                        .get(overlay.selected)
                        .copied()
                        .unwrap_or(0) as usize;
                    let visible_rows = body_area.height as usize;
                    // Cache visible rows so key handler can clamp
                    self.diffs.body_visible_rows.set(body_area.height);
                    let max_off = all_lines.len().saturating_sub(visible_rows.max(1));
                    let skip = raw_skip.min(max_off);
                    let body_inner = body_area;
                    let visible_rows = body_inner.height as usize;

                    // Collect visible slice
                    let end = (skip + visible_rows).min(all_lines.len());
                    let visible = if skip < all_lines.len() {
                        &all_lines[skip..end]
                    } else {
                        &[]
                    };
                    // Fill body background with a slightly lighter paper-like background
                    let bg = crate::colors::background();
                    let paper_color = match bg {
                        ratatui::style::Color::Rgb(r, g, b) => {
                            let alpha = 0.06f32; // subtle lightening toward white
                            let nr = ((r as f32) * (1.0 - alpha) + 255.0 * alpha).round() as u8;
                            let ng = ((g as f32) * (1.0 - alpha) + 255.0 * alpha).round() as u8;
                            let nb = ((b as f32) * (1.0 - alpha) + 255.0 * alpha).round() as u8;
                            ratatui::style::Color::Rgb(nr, ng, nb)
                        }
                        _ => bg,
                    };
                    let body_bg = Style::default().bg(paper_color);
                    let _perf_overlay_body_bg2 = if self.perf_state.enabled {
                        Some(std::time::Instant::now())
                    } else {
                        None
                    };
                    for y in body_inner.y..body_inner.y + body_inner.height {
                        for x in body_inner.x..body_inner.x + body_inner.width {
                            buf[(x, y)].set_style(body_bg);
                        }
                    }
                    if let Some(t0) = _perf_overlay_body_bg2 {
                        let dt = t0.elapsed().as_nanos();
                        let mut p = self.perf_state.stats.borrow_mut();
                        p.ns_overlay_body_bg = p.ns_overlay_body_bg.saturating_add(dt);
                        let cells = (body_inner.width as u64) * (body_inner.height as u64);
                        p.cells_overlay_body_bg = p.cells_overlay_body_bg.saturating_add(cells);
                    }
                    let paragraph = Paragraph::new(RtText::from(visible.to_vec()))
                        .wrap(ratatui::widgets::Wrap { trim: false });
                    ratatui::widgets::Widget::render(paragraph, body_inner, buf);

                    // No explicit current-block highlight for a cleaner look

                    // Render confirmation dialog if active
                    if self.diffs.confirm.is_some() {
                        // Centered small box
                        let w = (body_inner.width as i16 - 10).max(20) as u16;
                        let h = 5u16;
                        let x = body_inner.x + (body_inner.width.saturating_sub(w)) / 2;
                        let y = body_inner.y + (body_inner.height.saturating_sub(h)) / 2;
                        let dialog = Rect {
                            x,
                            y,
                            width: w,
                            height: h,
                        };
                        Clear.render(dialog, buf);
                        let dlg_block = Block::default()
                            .borders(Borders::ALL)
                            .title("Confirm Undo")
                            .style(
                                Style::default()
                                    .bg(crate::colors::background())
                                    .fg(crate::colors::text()),
                            )
                            .border_style(Style::default().fg(crate::colors::border()));
                        let dlg_inner = dlg_block.inner(dialog);
                        dlg_block.render(dialog, buf);
                        // Fill dialog inner area with theme background for consistent look
                        let dlg_bg = Style::default().bg(crate::colors::background());
                        for y in dlg_inner.y..dlg_inner.y + dlg_inner.height {
                            for x in dlg_inner.x..dlg_inner.x + dlg_inner.width {
                                buf[(x, y)].set_style(dlg_bg);
                            }
                        }
                        let lines = vec![
                            ratatui::text::Line::from("Are you sure you want to undo this diff?"),
                            ratatui::text::Line::from(
                                "Press Enter to confirm • Esc to cancel".to_string().dim(),
                            ),
                        ];
                        let para = Paragraph::new(RtText::from(lines))
                            .style(
                                Style::default()
                                    .bg(crate::colors::background())
                                    .fg(crate::colors::text()),
                            )
                            .wrap(ratatui::widgets::Wrap { trim: true });
                        ratatui::widgets::Widget::render(para, dlg_inner, buf);
                    }
                }
            }

            // Render help overlay (covering the history area) if active
            if self.settings.overlay.is_none() {
                if let Some(overlay) = &self.help.overlay {
                    // Global scrim across widget
                    let scrim_bg = Style::default()
                        .bg(crate::colors::overlay_scrim())
                        .fg(crate::colors::text_dim());
                    for y in area.y..area.y + area.height {
                        for x in area.x..area.x + area.width {
                            buf[(x, y)].set_style(scrim_bg);
                        }
                    }
                    let padding = 1u16;
                    let window_area = Rect {
                        x: history_area.x + padding,
                        y: history_area.y,
                        width: history_area.width.saturating_sub(padding * 2),
                        height: history_area.height,
                    };
                    Clear.render(window_area, buf);
                    let block = Block::default()
                        .borders(Borders::ALL)
                        .title(ratatui::text::Line::from(vec![
                            ratatui::text::Span::styled(
                                " ",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                            ratatui::text::Span::styled(
                                "Help",
                                Style::default().fg(crate::colors::text()),
                            ),
                            ratatui::text::Span::styled(
                                " ——— ",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                            ratatui::text::Span::styled(
                                "Esc",
                                Style::default().fg(crate::colors::text()),
                            ),
                            ratatui::text::Span::styled(
                                " close ",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]))
                        .style(Style::default().bg(crate::colors::background()))
                        .border_style(
                            Style::default()
                                .fg(crate::colors::border())
                                .bg(crate::colors::background()),
                        );
                    let inner = block.inner(window_area);
                    block.render(window_area, buf);

                    // Paint inner bg
                    let inner_bg = Style::default().bg(crate::colors::background());
                    for y in inner.y..inner.y + inner.height {
                        for x in inner.x..inner.x + inner.width {
                            buf[(x, y)].set_style(inner_bg);
                        }
                    }

                    // Body area with one cell padding
                    let body = inner.inner(ratatui::layout::Margin::new(1, 1));

                    // Compute visible slice
                    let visible_rows = body.height as usize;
                    self.help.body_visible_rows.set(body.height);
                    let max_off = overlay.lines.len().saturating_sub(visible_rows.max(1));
                    let skip = (overlay.scroll as usize).min(max_off);
                    let end = (skip + visible_rows).min(overlay.lines.len());
                    let visible = if skip < overlay.lines.len() {
                        &overlay.lines[skip..end]
                    } else {
                        &[]
                    };
                    let paragraph = Paragraph::new(RtText::from(visible.to_vec()))
                        .wrap(ratatui::widgets::Wrap { trim: false });
                    ratatui::widgets::Widget::render(paragraph, body, buf);
                }
            }
        }
        // Finalize widget render timing
        if let Some(t0) = _perf_widget_start {
            let dt = t0.elapsed().as_nanos();
            let mut p = self.perf_state.stats.borrow_mut();
            p.ns_widget_render_total = p.ns_widget_render_total.saturating_add(dt);
        }
    }
}

// Coalesce adjacent Read entries of the same file with contiguous ranges in a rendered lines vector.
// Expects the vector to contain a header line at index 0 (e.g., "Read"). Modifies in place.
#[allow(dead_code)]
fn coalesce_read_ranges_in_lines(lines: &mut Vec<ratatui::text::Line<'static>>) {
    use ratatui::style::Modifier;
    use ratatui::style::Style;
    use ratatui::text::Line;
    use ratatui::text::Span;

    if lines.len() <= 1 {
        return;
    }

    // Helper to parse a content line into (filename, start, end, prefix)
    fn parse_read_line(line: &Line<'_>) -> Option<(String, u32, u32, String)> {
        if line.spans.is_empty() {
            return None;
        }
        let prefix = line.spans[0].content.to_string();
        if !(prefix == "└ " || prefix == "  ") {
            return None;
        }
        let rest: String = line
            .spans
            .iter()
            .skip(1)
            .map(|s| s.content.as_ref())
            .collect();
        if let Some(idx) = rest.rfind(" (lines ") {
            let fname = rest[..idx].to_string();
            let tail = &rest[idx + 1..];
            if tail.starts_with("(lines ") && tail.ends_with(")") {
                let inner = &tail[7..tail.len() - 1];
                if let Some((s1, s2)) = inner.split_once(" to ") {
                    if let (Ok(start), Ok(end)) =
                        (s1.trim().parse::<u32>(), s2.trim().parse::<u32>())
                    {
                        return Some((fname, start, end, prefix));
                    }
                }
            }
        }
        None
    }

    // Merge overlapping or touching ranges for the same file, regardless of adjacency.
    let mut i: usize = 0; // works for vectors with or without a header line
    while i < lines.len() {
        let Some((fname_a, mut a1, mut a2, prefix_a)) = parse_read_line(&lines[i]) else {
            i += 1;
            continue;
        };
        let mut k = i + 1;
        while k < lines.len() {
            if let Some((fname_b, b1, b2, _prefix_b)) = parse_read_line(&lines[k]) {
                if fname_b == fname_a {
                    let touch_or_overlap = b1 <= a2.saturating_add(1) && b2.saturating_add(1) >= a1;
                    if touch_or_overlap {
                        a1 = a1.min(b1);
                        a2 = a2.max(b2);
                        let new_spans: Vec<Span<'static>> = vec![
                            Span::styled(
                                prefix_a.clone(),
                                Style::default().add_modifier(Modifier::DIM),
                            ),
                            Span::styled(
                                fname_a.clone(),
                                Style::default().fg(crate::colors::text()),
                            ),
                            Span::styled(
                                format!(" (lines {} to {})", a1, a2),
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ];
                        lines[i] = Line::from(new_spans);
                        lines.remove(k);
                        continue;
                    }
                }
            }
            k += 1;
        }
        i += 1;
    }
}
#[derive(Default)]
struct ExecState {
    running_commands: HashMap<ExecCallId, RunningCommand>,
    running_explore_agg_index: Option<usize>,
    // Pairing map for out-of-order exec events. If an ExecEnd arrives before
    // ExecBegin, we stash it briefly and either pair it when Begin arrives or
    // flush it after a short timeout to show a fallback cell.
    pending_exec_ends: HashMap<
        ExecCallId,
        (
            ExecCommandEndEvent,
            code_core::protocol::OrderMeta,
            std::time::Instant,
        ),
    >,
    suppressed_exec_end_call_ids: HashSet<ExecCallId>,
    suppressed_exec_end_order: VecDeque<ExecCallId>,
}

impl ExecState {
    fn suppress_exec_end(&mut self, call_id: ExecCallId) {
        if self.suppressed_exec_end_call_ids.insert(call_id.clone()) {
            self.suppressed_exec_end_order.push_back(call_id);
            const MAX_TRACKED_SUPPRESSED_IDS: usize = 64;
            if self.suppressed_exec_end_order.len() > MAX_TRACKED_SUPPRESSED_IDS {
                if let Some(old) = self.suppressed_exec_end_order.pop_front() {
                    self.suppressed_exec_end_call_ids.remove(&old);
                }
            }
        }
    }

    fn unsuppress_exec_end(&mut self, call_id: &ExecCallId) {
        if self.suppressed_exec_end_call_ids.remove(call_id) {
            self.suppressed_exec_end_order.retain(|cid| cid != call_id);
        }
    }

    fn should_suppress_exec_end(&self, call_id: &ExecCallId) -> bool {
        self.suppressed_exec_end_call_ids.contains(call_id)
    }
}

#[derive(Clone, Copy, Debug)]
pub(super) struct RunningToolEntry {
    order_key: OrderKey,
    fallback_index: usize,
    history_id: Option<HistoryId>,
}

impl RunningToolEntry {
    fn new(order_key: OrderKey, fallback_index: usize) -> Self {
        Self {
            order_key,
            fallback_index,
            history_id: None,
        }
    }

    fn with_history_id(mut self, id: Option<HistoryId>) -> Self {
        self.history_id = id;
        self
    }
}

#[derive(Default)]
struct ToolState {
    running_custom_tools: HashMap<ToolCallId, RunningToolEntry>,
    web_search_sessions: HashMap<String, web_search_sessions::WebSearchTracker>,
    web_search_by_call: HashMap<String, String>,
    web_search_by_order: HashMap<u64, String>,
    running_wait_tools: HashMap<ToolCallId, ExecCallId>,
    running_kill_tools: HashMap<ToolCallId, ExecCallId>,
    browser_sessions: HashMap<String, browser_sessions::BrowserSessionTracker>,
    browser_session_by_call: HashMap<String, String>,
    browser_session_by_order: HashMap<u64, String>,
    browser_last_key: Option<String>,
    agent_runs: HashMap<String, agent_runs::AgentRunTracker>,
    agent_run_by_call: HashMap<String, String>,
    agent_run_by_order: HashMap<u64, String>,
    agent_run_by_batch: HashMap<String, String>,
    agent_run_by_agent: HashMap<String, String>,
    agent_last_key: Option<String>,
    auto_drive_tracker: Option<auto_drive_cards::AutoDriveTracker>,
}
#[derive(Default)]
struct StreamState {
    current_kind: Option<StreamKind>,
    closed_answer_ids: HashSet<StreamId>,
    closed_reasoning_ids: HashSet<StreamId>,
    seq_answer_final: Option<u64>,
    drop_streaming: bool,
}

#[derive(Default)]
struct LayoutState {
    // Scroll offset from bottom (0 = bottom)
    scroll_offset: u16,
    // Cached max scroll from last render
    last_max_scroll: std::cell::Cell<u16>,
    // Track last viewport height of the history content area
    last_history_viewport_height: std::cell::Cell<u16>,
    // Stateful vertical scrollbar for history view
    vertical_scrollbar_state: std::cell::RefCell<ScrollbarState>,
    // Auto-hide scrollbar timer
    scrollbar_visible_until: std::cell::Cell<Option<std::time::Instant>>,
    // Last effective bottom pane height used by layout (rows)
    last_bottom_reserved_rows: std::cell::Cell<u16>,
    last_frame_height: std::cell::Cell<u16>,
    last_frame_width: std::cell::Cell<u16>,
}

#[derive(Default)]
struct DiffsState {
    session_patch_sets: Vec<HashMap<PathBuf, code_core::protocol::FileChange>>,
    baseline_file_contents: HashMap<PathBuf, String>,
    overlay: Option<DiffOverlay>,
    confirm: Option<DiffConfirm>,
    body_visible_rows: std::cell::Cell<u16>,
}

#[derive(Default)]
struct HelpState {
    overlay: Option<HelpOverlay>,
    body_visible_rows: std::cell::Cell<u16>,
}

#[derive(Default)]
struct SettingsState {
    overlay: Option<SettingsOverlayView>,
}

struct BrowserOverlayState {
    session_key: RefCell<Option<String>>,
    screenshot_index: Cell<usize>,
    action_scroll: Cell<u16>,
    last_action_view_height: Cell<u16>,
    max_action_scroll: Cell<u16>,
}

impl Default for BrowserOverlayState {
    fn default() -> Self {
        Self {
            session_key: RefCell::new(None),
            screenshot_index: Cell::new(0),
            action_scroll: Cell::new(0),
            last_action_view_height: Cell::new(0),
            max_action_scroll: Cell::new(0),
        }
    }
}

impl BrowserOverlayState {
    fn reset(&self) {
        self.screenshot_index.set(0);
        self.action_scroll.set(0);
        self.last_action_view_height.set(0);
        self.max_action_scroll.set(0);
    }

    fn session_key(&self) -> Option<String> {
        self.session_key.borrow().clone()
    }

    fn set_session_key(&self, key: Option<String>) {
        *self.session_key.borrow_mut() = key;
    }

    fn screenshot_index(&self) -> usize {
        self.screenshot_index.get()
    }

    fn set_screenshot_index(&self, index: usize) {
        self.screenshot_index.set(index);
    }

    fn action_scroll(&self) -> u16 {
        self.action_scroll.get()
    }

    fn set_action_scroll(&self, value: u16) {
        self.action_scroll.set(value);
    }

    fn update_action_metrics(&self, height: u16, max_scroll: u16) {
        self.last_action_view_height.set(height);
        self.max_action_scroll.set(max_scroll);
        if self.action_scroll.get() > max_scroll {
            self.action_scroll.set(max_scroll);
        }
    }

    fn last_action_view_height(&self) -> u16 {
        self.last_action_view_height.get()
    }

    fn max_action_scroll(&self) -> u16 {
        self.max_action_scroll.get()
    }
}

#[derive(Default)]
struct LimitsState {
    cached_content: Option<LimitsOverlayContent>,
}

struct HelpOverlay {
    lines: Vec<RtLine<'static>>,
    scroll: u16,
}

impl HelpOverlay {
    fn new(lines: Vec<RtLine<'static>>) -> Self {
        Self { lines, scroll: 0 }
    }
}

struct CommandDisplayLine {
    text: String,
    start: usize,
    end: usize,
}

fn wrap_pending_command_lines(input: &str, width: usize) -> Vec<CommandDisplayLine> {
    if width == 0 {
        return vec![CommandDisplayLine {
            text: String::new(),
            start: 0,
            end: input.len(),
        }];
    }

    let mut lines = Vec::new();
    let mut current = String::new();
    let mut current_width = 0usize;
    let mut current_start = 0usize;

    for (byte_idx, grapheme) in input.grapheme_indices(true) {
        let g_width = UnicodeWidthStr::width(grapheme);
        if current_width + g_width > width && !current.is_empty() {
            lines.push(CommandDisplayLine {
                text: current,
                start: current_start,
                end: byte_idx,
            });
            current = String::new();
            current_width = 0;
            current_start = byte_idx;
        }
        current.push_str(grapheme);
        current_width += g_width;
    }

    let end = input.len();
    lines.push(CommandDisplayLine {
        text: current,
        start: current_start,
        end,
    });

    if lines.is_empty() {
        lines.push(CommandDisplayLine {
            text: String::new(),
            start: 0,
            end: 0,
        });
    }

    lines
}

fn pending_command_box_lines(
    pending: &PendingCommand,
    width: u16,
) -> Option<(Vec<RtLine<'static>>, u16)> {
    if width <= 4 {
        return None;
    }
    let inner_width = width.saturating_sub(2);
    if inner_width <= 4 {
        return None;
    }

    let padded_width = inner_width.saturating_sub(2).max(1) as usize;
    let command_width = inner_width.saturating_sub(4).max(1) as usize;

    const INSTRUCTION_TEXT: &str =
        "Press Enter to run this command. Press Esc to cancel.";
    let instruction_segments = wrap(INSTRUCTION_TEXT, padded_width);
    let instruction_style = Style::default().fg(crate::colors::text_dim());
    let mut lines: Vec<RtLine<'static>> = instruction_segments
        .into_iter()
        .map(|segment| {
            ratatui::text::Line::from(vec![
                ratatui::text::Span::raw(" "),
                ratatui::text::Span::styled(segment.into_owned(), instruction_style),
                ratatui::text::Span::raw(" "),
            ])
        })
        .collect();

    let command_lines = wrap_pending_command_lines(pending.input(), command_width);
    let cursor_line_idx = command_line_index_for_cursor(&command_lines, pending.cursor());
    let prefix_style = Style::default().fg(crate::colors::primary());
    let text_style = Style::default().fg(crate::colors::text());
    let cursor_style = Style::default()
        .bg(crate::colors::primary())
        .fg(crate::colors::background());

    if !lines.is_empty() {
        lines.push(ratatui::text::Line::from(vec![ratatui::text::Span::raw(String::new())]));
    }

    for (idx, line) in command_lines.iter().enumerate() {
        let mut spans = Vec::new();
        spans.push(ratatui::text::Span::raw(" "));
        if idx == 0 {
            spans.push(ratatui::text::Span::styled("$ ", prefix_style));
        } else {
            spans.push(ratatui::text::Span::raw("  "));
        }

        if idx == cursor_line_idx {
            let cursor_offset = pending.cursor().saturating_sub(line.start);
            let cursor_offset = cursor_offset.min(line.text.len());
            let (before, cursor_span, after) = split_line_for_cursor(&line.text, cursor_offset);
            if !before.is_empty() {
                spans.push(ratatui::text::Span::styled(before, text_style));
            }
            match cursor_span {
                Some(token) => spans.push(ratatui::text::Span::styled(token, cursor_style)),
                None => spans.push(ratatui::text::Span::styled(" ", cursor_style)),
            }
            if let Some(after_text) = after {
                if !after_text.is_empty() {
                    spans.push(ratatui::text::Span::styled(after_text, text_style));
                }
            }
        } else {
            spans.push(ratatui::text::Span::styled(line.text.clone(), text_style));
        }

        spans.push(ratatui::text::Span::raw(" "));
        lines.push(ratatui::text::Line::from(spans));
    }

    let height = (lines.len() as u16).saturating_add(2).max(3);
    Some((lines, height))
}

fn command_line_index_for_cursor(lines: &[CommandDisplayLine], cursor: usize) -> usize {
    if lines.is_empty() {
        return 0;
    }
    for (idx, line) in lines.iter().enumerate() {
        if cursor < line.end {
            return idx;
        }
        if cursor == line.end {
            return (idx + 1).min(lines.len().saturating_sub(1));
        }
    }
    lines.len().saturating_sub(1)
}

fn split_line_for_cursor(text: &str, cursor_offset: usize) -> (String, Option<String>, Option<String>) {
    if cursor_offset >= text.len() {
        return (text.to_string(), None, None);
    }

    let (before, remainder) = text.split_at(cursor_offset);
    let mut graphemes = remainder.graphemes(true);
    if let Some(first) = graphemes.next() {
        let after = graphemes.collect::<String>();
        (
            before.to_string(),
            Some(first.to_string()),
            if after.is_empty() { None } else { Some(after) },
        )
    } else {
        (before.to_string(), None, None)
    }
}

fn render_text_box(
    area: Rect,
    title: &str,
    border_color: ratatui::style::Color,
    lines: Vec<RtLine<'static>>,
    buf: &mut Buffer,
) {
    let block = Block::default()
        .borders(Borders::ALL)
        .style(Style::default().bg(crate::colors::background()))
        .border_style(Style::default().fg(border_color))
        .title(ratatui::text::Span::styled(
            title.to_string(),
            Style::default().fg(border_color),
        ));
    block.render(area, buf);

    let inner = area.inner(ratatui::layout::Margin::new(1, 1));
    if inner.height == 0 || inner.width == 0 {
        return;
    }

    let inner_bg = Style::default().bg(crate::colors::background());
    for y in inner.y..inner.y + inner.height {
        for x in inner.x..inner.x + inner.width {
            buf[(x, y)].set_style(inner_bg);
        }
    }

    Paragraph::new(RtText::from(lines))
        .wrap(ratatui::widgets::Wrap { trim: false })
        .render(inner, buf);
}

#[derive(Default)]
struct PerfState {
    enabled: bool,
    stats: RefCell<PerfStats>,
    pending_scroll_rows: Cell<u64>,
}

impl ChatWidget<'_> {
    fn clear_backgrounds_in(&self, buf: &mut Buffer, rect: Rect) {
        for y in rect.y..rect.y.saturating_add(rect.height) {
            for x in rect.x..rect.x.saturating_add(rect.width) {
                let cell = &mut buf[(x, y)];
                // Reset background; keep fg/content as-is
                cell.set_bg(ratatui::style::Color::Reset);
            }
        }
    }
    pub(crate) fn set_github_watcher(&mut self, enabled: bool) {
        self.config.github.check_workflows_on_push = enabled;
        match find_code_home() {
            Ok(home) => {
                if let Err(e) = set_github_check_on_push(&home, enabled) {
                    tracing::warn!("Failed to persist GitHub watcher setting: {}", e);
                    let msg = format!(
                        "✅ {} GitHub watcher (persist failed; see logs)",
                        if enabled { "Enabled" } else { "Disabled" }
                    );
                    self.push_background_tail(msg);
                } else {
                    let msg = format!(
                        "✅ {} GitHub watcher (persisted)",
                        if enabled { "Enabled" } else { "Disabled" }
                    );
                    self.push_background_tail(msg);
                }
            }
            Err(_) => {
                let msg = format!(
                    "✅ {} GitHub watcher (not persisted: CODE_HOME/CODEX_HOME not found)",
                    if enabled { "Enabled" } else { "Disabled" }
                );
                self.push_background_tail(msg);
            }
        }

        self.refresh_settings_overview_rows();
    }

    pub(crate) fn set_tui_notifications(&mut self, enabled: bool) {
        let new_state = Notifications::Enabled(enabled);
        self.config.tui.notifications = new_state.clone();
        self.config.tui_notifications = new_state.clone();

        match find_code_home() {
            Ok(home) => {
                match code_core::config::set_tui_notifications(&home, new_state) {
                    Ok(()) => {
                        let msg = format!(
                            "✅ {} TUI notifications",
                            if enabled { "Enabled" } else { "Disabled" }
                        );
                        self.push_background_tail(msg);
                    }
                    Err(err) => {
                        let msg = format!(
                            "⚠️ Failed to persist TUI notifications setting: {}",
                            err
                        );
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                }
            }
            Err(_) => {
                let msg = format!(
                    "✅ {} TUI notifications (not persisted: CODE_HOME/CODEX_HOME not found)",
                    if enabled { "Enabled" } else { "Disabled" }
                );
                self.push_background_tail(msg);
            }
        }

        self.refresh_settings_overview_rows();
    }

    fn emit_turn_complete_notification(&self, last_agent_message: Option<String>) {
        if !self.should_emit_tui_notification("agent-turn-complete") {
            return;
        }

        let snippet = last_agent_message
            .as_deref()
            .map(Self::notification_snippet)
            .filter(|text| !text.is_empty());

        self.app_event_tx.send(AppEvent::EmitTuiNotification {
            title: "Code".to_string(),
            body: snippet,
        });
    }

    fn should_emit_tui_notification(&self, event: &str) -> bool {
        if self.replay_history_depth > 0 {
            return false;
        }
        self.tui_notification_filter_allows(event)
    }

    fn tui_notification_filter_allows(&self, event: &str) -> bool {
        match &self.config.tui.notifications {
            Notifications::Enabled(enabled) => *enabled,
            Notifications::Custom(entries) => entries
                .iter()
                .any(|entry| entry.eq_ignore_ascii_case(event)),
        }
    }

    fn notification_snippet(input: &str) -> String {
        let collapsed = input
            .split_whitespace()
            .collect::<Vec<_>>()
            .join(" ");

        const LIMIT: usize = 120;
        if collapsed.chars().count() <= LIMIT {
            return collapsed;
        }

        let mut truncated = String::new();
        let mut count = 0usize;
        for ch in collapsed.chars() {
            if count >= LIMIT.saturating_sub(3) {
                break;
            }
            truncated.push(ch);
            count += 1;
        }
        truncated.push_str("...");
        truncated
    }

    pub(crate) fn toggle_mcp_server(&mut self, name: &str, enable: bool) {
        match code_core::config::find_code_home() {
            Ok(home) => match code_core::config::set_mcp_server_enabled(&home, name, enable) {
                Ok(changed) => {
                    if changed {
                        if enable {
                            if let Ok((enabled, _)) = code_core::config::list_mcp_servers(&home) {
                                if let Some((_, cfg)) = enabled.into_iter().find(|(n, _)| n == name)
                                {
                                    self.config.mcp_servers.insert(name.to_string(), cfg);
                                }
                            }
                        } else {
                            self.config.mcp_servers.remove(name);
                        }
                        let msg = format!(
                            "{} MCP server '{}'",
                            if enable { "Enabled" } else { "Disabled" },
                            name
                        );
                        self.push_background_tail(msg);
                    }
                }
                Err(e) => {
                    let msg = format!("Failed to update MCP server '{}': {}", name, e);
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                }
            },
            Err(e) => {
                let msg = format!("Failed to locate CODEX_HOME: {}", e);
                self.history_push_plain_state(history_cell::new_error_event(msg));
            }
        }
    }
}
